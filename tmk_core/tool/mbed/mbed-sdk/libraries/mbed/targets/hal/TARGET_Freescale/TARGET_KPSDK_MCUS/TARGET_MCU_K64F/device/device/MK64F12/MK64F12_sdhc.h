/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    K64P144M120SF5RM, Rev.2, January 2014
**     Version:             rev. 2.5, 2014-02-10
**     Build:               b140604
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2014 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2013-08-12)
**         Initial version.
**     - rev. 2.0 (2013-10-29)
**         Register accessor macros added to the memory map.
**         Symbols for Processor Expert memory map compatibility added to the memory map.
**         Startup file for gcc has been updated according to CMSIS 3.2.
**         System initialization updated.
**         MCG - registers updated.
**         PORTA, PORTB, PORTC, PORTE - registers for digital filter removed.
**     - rev. 2.1 (2013-10-30)
**         Definition of BITBAND macros updated to support peripherals with 32-bit acces disabled.
**     - rev. 2.2 (2013-12-09)
**         DMA - EARS register removed.
**         AIPS0, AIPS1 - MPRA register updated.
**     - rev. 2.3 (2014-01-24)
**         Update according to reference manual rev. 2
**         ENET, MCG, MCM, SIM, USB - registers updated
**     - rev. 2.4 (2014-02-10)
**         The declaration of clock configurations has been moved to separate header file system_MK64F12.h
**         Update of SystemInit() and SystemCoreClockUpdate() functions.
**     - rev. 2.5 (2014-02-10)
**         The declaration of clock configurations has been moved to separate header file system_MK64F12.h
**         Update of SystemInit() and SystemCoreClockUpdate() functions.
**         Module access macro module_BASES replaced by module_BASE_PTRS.
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_SDHC_REGISTERS_H__
#define __HW_SDHC_REGISTERS_H__

#include "MK64F12.h"
#include "fsl_bitaccess.h"

/*
 * MK64F12 SDHC
 *
 * Secured Digital Host Controller
 *
 * Registers defined in this header file:
 * - HW_SDHC_DSADDR - DMA System Address register
 * - HW_SDHC_BLKATTR - Block Attributes register
 * - HW_SDHC_CMDARG - Command Argument register
 * - HW_SDHC_XFERTYP - Transfer Type register
 * - HW_SDHC_CMDRSP0 - Command Response 0
 * - HW_SDHC_CMDRSP1 - Command Response 1
 * - HW_SDHC_CMDRSP2 - Command Response 2
 * - HW_SDHC_CMDRSP3 - Command Response 3
 * - HW_SDHC_DATPORT - Buffer Data Port register
 * - HW_SDHC_PRSSTAT - Present State register
 * - HW_SDHC_PROCTL - Protocol Control register
 * - HW_SDHC_SYSCTL - System Control register
 * - HW_SDHC_IRQSTAT - Interrupt Status register
 * - HW_SDHC_IRQSTATEN - Interrupt Status Enable register
 * - HW_SDHC_IRQSIGEN - Interrupt Signal Enable register
 * - HW_SDHC_AC12ERR - Auto CMD12 Error Status Register
 * - HW_SDHC_HTCAPBLT - Host Controller Capabilities
 * - HW_SDHC_WML - Watermark Level Register
 * - HW_SDHC_FEVT - Force Event register
 * - HW_SDHC_ADMAES - ADMA Error Status register
 * - HW_SDHC_ADSADDR - ADMA System Addressregister
 * - HW_SDHC_VENDOR - Vendor Specific register
 * - HW_SDHC_MMCBOOT - MMC Boot register
 * - HW_SDHC_HOSTVER - Host Controller Version
 *
 * - hw_sdhc_t - Struct containing all module registers.
 */

#define HW_SDHC_INSTANCE_COUNT (1U) /*!< Number of instances of the SDHC module. */

/*******************************************************************************
 * HW_SDHC_DSADDR - DMA System Address register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_DSADDR - DMA System Address register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the physical system memory address used for DMA
 * transfers.
 */
typedef union _hw_sdhc_dsaddr
{
    uint32_t U;
    struct _hw_sdhc_dsaddr_bitfields
    {
        uint32_t RESERVED0 : 2;        /*!< [1:0]  */
        uint32_t DSADDR : 30;          /*!< [31:2] DMA System Address */
    } B;
} hw_sdhc_dsaddr_t;

/*!
 * @name Constants and macros for entire SDHC_DSADDR register
 */
/*@{*/
#define HW_SDHC_DSADDR_ADDR(x)   ((x) + 0x0U)

#define HW_SDHC_DSADDR(x)        (*(__IO hw_sdhc_dsaddr_t *) HW_SDHC_DSADDR_ADDR(x))
#define HW_SDHC_DSADDR_RD(x)     (HW_SDHC_DSADDR(x).U)
#define HW_SDHC_DSADDR_WR(x, v)  (HW_SDHC_DSADDR(x).U = (v))
#define HW_SDHC_DSADDR_SET(x, v) (HW_SDHC_DSADDR_WR(x, HW_SDHC_DSADDR_RD(x) |  (v)))
#define HW_SDHC_DSADDR_CLR(x, v) (HW_SDHC_DSADDR_WR(x, HW_SDHC_DSADDR_RD(x) & ~(v)))
#define HW_SDHC_DSADDR_TOG(x, v) (HW_SDHC_DSADDR_WR(x, HW_SDHC_DSADDR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_DSADDR bitfields
 */

/*!
 * @name Register SDHC_DSADDR, field DSADDR[31:2] (RW)
 *
 * Contains the 32-bit system memory address for a DMA transfer. Because the
 * address must be word (4 bytes) align, the least 2 bits are reserved, always 0.
 * When the SDHC stops a DMA transfer, this register points to the system address
 * of the next contiguous data position. It can be accessed only when no
 * transaction is executing, that is, after a transaction has stopped. Read operation
 * during transfers may return an invalid value. The host driver shall initialize
 * this register before starting a DMA transaction. After DMA has stopped, the
 * system address of the next contiguous data position can be read from this register.
 * This register is protected during a data transfer. When data lines are
 * active, write to this register is ignored. The host driver shall wait, until
 * PRSSTAT[DLA] is cleared, before writing to this register. The SDHC internal DMA does
 * not support a virtual memory system. It supports only continuous physical
 * memory access. And due to AHB burst limitations, if the burst must cross the 1 KB
 * boundary, SDHC will automatically change SEQ burst type to NSEQ. Because this
 * register supports dynamic address reflecting, when IRQSTAT[TC] bit is set, it
 * automatically alters the value of internal address counter, so SW cannot
 * change this register when IRQSTAT[TC] is set.
 */
/*@{*/
#define BP_SDHC_DSADDR_DSADDR (2U)         /*!< Bit position for SDHC_DSADDR_DSADDR. */
#define BM_SDHC_DSADDR_DSADDR (0xFFFFFFFCU) /*!< Bit mask for SDHC_DSADDR_DSADDR. */
#define BS_SDHC_DSADDR_DSADDR (30U)        /*!< Bit field size in bits for SDHC_DSADDR_DSADDR. */

/*! @brief Read current value of the SDHC_DSADDR_DSADDR field. */
#define BR_SDHC_DSADDR_DSADDR(x) (HW_SDHC_DSADDR(x).B.DSADDR)

/*! @brief Format value for bitfield SDHC_DSADDR_DSADDR. */
#define BF_SDHC_DSADDR_DSADDR(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_DSADDR_DSADDR) & BM_SDHC_DSADDR_DSADDR)

/*! @brief Set the DSADDR field to a new value. */
#define BW_SDHC_DSADDR_DSADDR(x, v) (HW_SDHC_DSADDR_WR(x, (HW_SDHC_DSADDR_RD(x) & ~BM_SDHC_DSADDR_DSADDR) | BF_SDHC_DSADDR_DSADDR(v)))
/*@}*/

/*******************************************************************************
 * HW_SDHC_BLKATTR - Block Attributes register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_BLKATTR - Block Attributes register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to configure the number of data blocks and the number
 * of bytes in each block.
 */
typedef union _hw_sdhc_blkattr
{
    uint32_t U;
    struct _hw_sdhc_blkattr_bitfields
    {
        uint32_t BLKSIZE : 13;         /*!< [12:0] Transfer Block Size */
        uint32_t RESERVED0 : 3;        /*!< [15:13]  */
        uint32_t BLKCNT : 16;          /*!< [31:16] Blocks Count For Current Transfer
                                        * */
    } B;
} hw_sdhc_blkattr_t;

/*!
 * @name Constants and macros for entire SDHC_BLKATTR register
 */
/*@{*/
#define HW_SDHC_BLKATTR_ADDR(x)  ((x) + 0x4U)

#define HW_SDHC_BLKATTR(x)       (*(__IO hw_sdhc_blkattr_t *) HW_SDHC_BLKATTR_ADDR(x))
#define HW_SDHC_BLKATTR_RD(x)    (HW_SDHC_BLKATTR(x).U)
#define HW_SDHC_BLKATTR_WR(x, v) (HW_SDHC_BLKATTR(x).U = (v))
#define HW_SDHC_BLKATTR_SET(x, v) (HW_SDHC_BLKATTR_WR(x, HW_SDHC_BLKATTR_RD(x) |  (v)))
#define HW_SDHC_BLKATTR_CLR(x, v) (HW_SDHC_BLKATTR_WR(x, HW_SDHC_BLKATTR_RD(x) & ~(v)))
#define HW_SDHC_BLKATTR_TOG(x, v) (HW_SDHC_BLKATTR_WR(x, HW_SDHC_BLKATTR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_BLKATTR bitfields
 */

/*!
 * @name Register SDHC_BLKATTR, field BLKSIZE[12:0] (RW)
 *
 * Specifies the block size for block data transfers. Values ranging from 1 byte
 * up to the maximum buffer size can be set. It can be accessed only when no
 * transaction is executing, that is, after a transaction has stopped. Read
 * operations during transfers may return an invalid value, and write operations will be
 * ignored.
 *
 * Values:
 * - 0 - No data transfer.
 * - 1 - 1 Byte
 * - 10 - 2 Bytes
 * - 11 - 3 Bytes
 * - 100 - 4 Bytes
 * - 111111111 - 511 Bytes
 * - 1000000000 - 512 Bytes
 * - 100000000000 - 2048 Bytes
 * - 1000000000000 - 4096 Bytes
 */
/*@{*/
#define BP_SDHC_BLKATTR_BLKSIZE (0U)       /*!< Bit position for SDHC_BLKATTR_BLKSIZE. */
#define BM_SDHC_BLKATTR_BLKSIZE (0x00001FFFU) /*!< Bit mask for SDHC_BLKATTR_BLKSIZE. */
#define BS_SDHC_BLKATTR_BLKSIZE (13U)      /*!< Bit field size in bits for SDHC_BLKATTR_BLKSIZE. */

/*! @brief Read current value of the SDHC_BLKATTR_BLKSIZE field. */
#define BR_SDHC_BLKATTR_BLKSIZE(x) (HW_SDHC_BLKATTR(x).B.BLKSIZE)

/*! @brief Format value for bitfield SDHC_BLKATTR_BLKSIZE. */
#define BF_SDHC_BLKATTR_BLKSIZE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_BLKATTR_BLKSIZE) & BM_SDHC_BLKATTR_BLKSIZE)

/*! @brief Set the BLKSIZE field to a new value. */
#define BW_SDHC_BLKATTR_BLKSIZE(x, v) (HW_SDHC_BLKATTR_WR(x, (HW_SDHC_BLKATTR_RD(x) & ~BM_SDHC_BLKATTR_BLKSIZE) | BF_SDHC_BLKATTR_BLKSIZE(v)))
/*@}*/

/*!
 * @name Register SDHC_BLKATTR, field BLKCNT[31:16] (RW)
 *
 * This register is enabled when XFERTYP[BCEN] is set to 1 and is valid only for
 * multiple block transfers. For single block transfer, this register will
 * always read as 1. The host driver shall set this register to a value between 1 and
 * the maximum block count. The SDHC decrements the block count after each block
 * transfer and stops when the count reaches zero. Setting the block count to 0
 * results in no data blocks being transferred. This register must be accessed
 * only when no transaction is executing, that is, after transactions are stopped.
 * During data transfer, read operations on this register may return an invalid
 * value and write operations are ignored. When saving transfer content as a result
 * of a suspend command, the number of blocks yet to be transferred can be
 * determined by reading this register. The reading of this register must be applied
 * after transfer is paused by stop at block gap operation and before sending the
 * command marked as suspend. This is because when suspend command is sent out,
 * SDHC will regard the current transfer as aborted and change BLKCNT back to its
 * original value instead of keeping the dynamical indicator of remained block
 * count. When restoring transfer content prior to issuing a resume command, the
 * host driver shall restore the previously saved block count. Although the BLKCNT
 * field is 0 after reset, the read of reset value is 0x1. This is because when
 * XFERTYP[MSBSEL] is 0, indicating a single block transfer, the read value of
 * BLKCNT is always 1.
 *
 * Values:
 * - 0 - Stop count.
 * - 1 - 1 block
 * - 10 - 2 blocks
 * - 1111111111111111 - 65535 blocks
 */
/*@{*/
#define BP_SDHC_BLKATTR_BLKCNT (16U)       /*!< Bit position for SDHC_BLKATTR_BLKCNT. */
#define BM_SDHC_BLKATTR_BLKCNT (0xFFFF0000U) /*!< Bit mask for SDHC_BLKATTR_BLKCNT. */
#define BS_SDHC_BLKATTR_BLKCNT (16U)       /*!< Bit field size in bits for SDHC_BLKATTR_BLKCNT. */

/*! @brief Read current value of the SDHC_BLKATTR_BLKCNT field. */
#define BR_SDHC_BLKATTR_BLKCNT(x) (HW_SDHC_BLKATTR(x).B.BLKCNT)

/*! @brief Format value for bitfield SDHC_BLKATTR_BLKCNT. */
#define BF_SDHC_BLKATTR_BLKCNT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_BLKATTR_BLKCNT) & BM_SDHC_BLKATTR_BLKCNT)

/*! @brief Set the BLKCNT field to a new value. */
#define BW_SDHC_BLKATTR_BLKCNT(x, v) (HW_SDHC_BLKATTR_WR(x, (HW_SDHC_BLKATTR_RD(x) & ~BM_SDHC_BLKATTR_BLKCNT) | BF_SDHC_BLKATTR_BLKCNT(v)))
/*@}*/

/*******************************************************************************
 * HW_SDHC_CMDARG - Command Argument register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_CMDARG - Command Argument register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the SD/MMC command argument.
 */
typedef union _hw_sdhc_cmdarg
{
    uint32_t U;
    struct _hw_sdhc_cmdarg_bitfields
    {
        uint32_t CMDARG : 32;          /*!< [31:0] Command Argument */
    } B;
} hw_sdhc_cmdarg_t;

/*!
 * @name Constants and macros for entire SDHC_CMDARG register
 */
/*@{*/
#define HW_SDHC_CMDARG_ADDR(x)   ((x) + 0x8U)

#define HW_SDHC_CMDARG(x)        (*(__IO hw_sdhc_cmdarg_t *) HW_SDHC_CMDARG_ADDR(x))
#define HW_SDHC_CMDARG_RD(x)     (HW_SDHC_CMDARG(x).U)
#define HW_SDHC_CMDARG_WR(x, v)  (HW_SDHC_CMDARG(x).U = (v))
#define HW_SDHC_CMDARG_SET(x, v) (HW_SDHC_CMDARG_WR(x, HW_SDHC_CMDARG_RD(x) |  (v)))
#define HW_SDHC_CMDARG_CLR(x, v) (HW_SDHC_CMDARG_WR(x, HW_SDHC_CMDARG_RD(x) & ~(v)))
#define HW_SDHC_CMDARG_TOG(x, v) (HW_SDHC_CMDARG_WR(x, HW_SDHC_CMDARG_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_CMDARG bitfields
 */

/*!
 * @name Register SDHC_CMDARG, field CMDARG[31:0] (RW)
 *
 * The SD/MMC command argument is specified as bits 39-8 of the command format
 * in the SD or MMC specification. This register is write protected when
 * PRSSTAT[CDIHB0] is set.
 */
/*@{*/
#define BP_SDHC_CMDARG_CMDARG (0U)         /*!< Bit position for SDHC_CMDARG_CMDARG. */
#define BM_SDHC_CMDARG_CMDARG (0xFFFFFFFFU) /*!< Bit mask for SDHC_CMDARG_CMDARG. */
#define BS_SDHC_CMDARG_CMDARG (32U)        /*!< Bit field size in bits for SDHC_CMDARG_CMDARG. */

/*! @brief Read current value of the SDHC_CMDARG_CMDARG field. */
#define BR_SDHC_CMDARG_CMDARG(x) (HW_SDHC_CMDARG(x).U)

/*! @brief Format value for bitfield SDHC_CMDARG_CMDARG. */
#define BF_SDHC_CMDARG_CMDARG(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_CMDARG_CMDARG) & BM_SDHC_CMDARG_CMDARG)

/*! @brief Set the CMDARG field to a new value. */
#define BW_SDHC_CMDARG_CMDARG(x, v) (HW_SDHC_CMDARG_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_XFERTYP - Transfer Type register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_XFERTYP - Transfer Type register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to control the operation of data transfers. The host
 * driver shall set this register before issuing a command followed by a data
 * transfer, or before issuing a resume command. To prevent data loss, the SDHC
 * prevents writing to the bits that are involved in the data transfer of this
 * register, when data transfer is active. These bits are DPSEL, MBSEL, DTDSEL, AC12EN,
 * BCEN, and DMAEN. The host driver shall check PRSSTAT[CDIHB] and PRSSTAT[CIHB]
 * before writing to this register. When PRSSTAT[CDIHB] is set, any attempt to
 * send a command with data by writing to this register is ignored; when
 * PRSSTAT[CIHB] bit is set, any write to this register is ignored. On sending commands with
 * data transfer involved, it is mandatory that the block size is nonzero.
 * Besides, block count must also be nonzero, or indicated as single block transfer
 * (bit 5 of this register is 0 when written), or block count is disabled (bit 1 of
 * this register is 0 when written), otherwise SDHC will ignore the sending of
 * this command and do nothing. For write command, with all above restrictions, it
 * is also mandatory that the write protect switch is not active (WPSPL bit of
 * Present State Register is 1), otherwise SDHC will also ignore the command. If
 * the commands with data transfer does not receive the response in 64 clock
 * cycles, that is, response time-out, SDHC will regard the external device does not
 * accept the command and abort the data transfer. In this scenario, the driver
 * must issue the command again to retry the transfer. It is also possible that,
 * for some reason, the card responds to the command but SDHC does not receive the
 * response, and if it is internal DMA (either simple DMA or ADMA) read
 * operation, the external system memory is over-written by the internal DMA with data
 * sent back from the card. The following table shows the summary of how register
 * settings determine the type of data transfer. Transfer Type register setting for
 * various transfer types Multi/Single block select Block count enable Block
 * count Function 0 Don't care Don't care Single transfer 1 0 Don't care Infinite
 * transfer 1 1 Positive number Multiple transfer 1 1 Zero No data transfer The
 * following table shows the relationship between XFERTYP[CICEN] and XFERTYP[CCCEN],
 * in regards to XFERTYP[RSPTYP] as well as the name of the response type.
 * Relationship between parameters and the name of the response type Response type
 * (RSPTYP) Index check enable (CICEN) CRC check enable (CCCEN) Name of response
 * type 00 0 0 No Response 01 0 1 IR2 10 0 0 R3,R4 10 1 1 R1,R5,R6 11 1 1 R1b,R5b In
 * the SDIO specification, response type notation for R5b is not defined. R5
 * includes R5b in the SDIO specification. But R5b is defined in this specification
 * to specify that the SDHC will check the busy status after receiving a
 * response. For example, usually CMD52 is used with R5, but the I/O abort command shall
 * be used with R5b. The CRC field for R3 and R4 is expected to be all 1 bits.
 * The CRC check shall be disabled for these response types.
 */
typedef union _hw_sdhc_xfertyp
{
    uint32_t U;
    struct _hw_sdhc_xfertyp_bitfields
    {
        uint32_t DMAEN : 1;            /*!< [0] DMA Enable */
        uint32_t BCEN : 1;             /*!< [1] Block Count Enable */
        uint32_t AC12EN : 1;           /*!< [2] Auto CMD12 Enable */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t DTDSEL : 1;           /*!< [4] Data Transfer Direction Select */
        uint32_t MSBSEL : 1;           /*!< [5] Multi/Single Block Select */
        uint32_t RESERVED1 : 10;       /*!< [15:6]  */
        uint32_t RSPTYP : 2;           /*!< [17:16] Response Type Select */
        uint32_t RESERVED2 : 1;        /*!< [18]  */
        uint32_t CCCEN : 1;            /*!< [19] Command CRC Check Enable */
        uint32_t CICEN : 1;            /*!< [20] Command Index Check Enable */
        uint32_t DPSEL : 1;            /*!< [21] Data Present Select */
        uint32_t CMDTYP : 2;           /*!< [23:22] Command Type */
        uint32_t CMDINX : 6;           /*!< [29:24] Command Index */
        uint32_t RESERVED3 : 2;        /*!< [31:30]  */
    } B;
} hw_sdhc_xfertyp_t;

/*!
 * @name Constants and macros for entire SDHC_XFERTYP register
 */
/*@{*/
#define HW_SDHC_XFERTYP_ADDR(x)  ((x) + 0xCU)

#define HW_SDHC_XFERTYP(x)       (*(__IO hw_sdhc_xfertyp_t *) HW_SDHC_XFERTYP_ADDR(x))
#define HW_SDHC_XFERTYP_RD(x)    (HW_SDHC_XFERTYP(x).U)
#define HW_SDHC_XFERTYP_WR(x, v) (HW_SDHC_XFERTYP(x).U = (v))
#define HW_SDHC_XFERTYP_SET(x, v) (HW_SDHC_XFERTYP_WR(x, HW_SDHC_XFERTYP_RD(x) |  (v)))
#define HW_SDHC_XFERTYP_CLR(x, v) (HW_SDHC_XFERTYP_WR(x, HW_SDHC_XFERTYP_RD(x) & ~(v)))
#define HW_SDHC_XFERTYP_TOG(x, v) (HW_SDHC_XFERTYP_WR(x, HW_SDHC_XFERTYP_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_XFERTYP bitfields
 */

/*!
 * @name Register SDHC_XFERTYP, field DMAEN[0] (RW)
 *
 * Enables DMA functionality. If this bit is set to 1, a DMA operation shall
 * begin when the host driver sets the DPSEL bit of this register. Whether the
 * simple DMA, or the advanced DMA, is active depends on PROCTL[DMAS].
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
/*@{*/
#define BP_SDHC_XFERTYP_DMAEN (0U)         /*!< Bit position for SDHC_XFERTYP_DMAEN. */
#define BM_SDHC_XFERTYP_DMAEN (0x00000001U) /*!< Bit mask for SDHC_XFERTYP_DMAEN. */
#define BS_SDHC_XFERTYP_DMAEN (1U)         /*!< Bit field size in bits for SDHC_XFERTYP_DMAEN. */

/*! @brief Read current value of the SDHC_XFERTYP_DMAEN field. */
#define BR_SDHC_XFERTYP_DMAEN(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_DMAEN))

/*! @brief Format value for bitfield SDHC_XFERTYP_DMAEN. */
#define BF_SDHC_XFERTYP_DMAEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_DMAEN) & BM_SDHC_XFERTYP_DMAEN)

/*! @brief Set the DMAEN field to a new value. */
#define BW_SDHC_XFERTYP_DMAEN(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_DMAEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field BCEN[1] (RW)
 *
 * Used to enable the Block Count register, which is only relevant for multiple
 * block transfers. When this bit is 0, the internal counter for block is
 * disabled, which is useful in executing an infinite transfer.
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
/*@{*/
#define BP_SDHC_XFERTYP_BCEN (1U)          /*!< Bit position for SDHC_XFERTYP_BCEN. */
#define BM_SDHC_XFERTYP_BCEN (0x00000002U) /*!< Bit mask for SDHC_XFERTYP_BCEN. */
#define BS_SDHC_XFERTYP_BCEN (1U)          /*!< Bit field size in bits for SDHC_XFERTYP_BCEN. */

/*! @brief Read current value of the SDHC_XFERTYP_BCEN field. */
#define BR_SDHC_XFERTYP_BCEN(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_BCEN))

/*! @brief Format value for bitfield SDHC_XFERTYP_BCEN. */
#define BF_SDHC_XFERTYP_BCEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_BCEN) & BM_SDHC_XFERTYP_BCEN)

/*! @brief Set the BCEN field to a new value. */
#define BW_SDHC_XFERTYP_BCEN(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_BCEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field AC12EN[2] (RW)
 *
 * Multiple block transfers for memory require a CMD12 to stop the transaction.
 * When this bit is set to 1, the SDHC will issue a CMD12 automatically when the
 * last block transfer has completed. The host driver shall not set this bit to
 * issue commands that do not require CMD12 to stop a multiple block data
 * transfer. In particular, secure commands defined in File Security Specification (see
 * reference list) do not require CMD12. In single block transfer, the SDHC will
 * ignore this bit whether it is set or not.
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
/*@{*/
#define BP_SDHC_XFERTYP_AC12EN (2U)        /*!< Bit position for SDHC_XFERTYP_AC12EN. */
#define BM_SDHC_XFERTYP_AC12EN (0x00000004U) /*!< Bit mask for SDHC_XFERTYP_AC12EN. */
#define BS_SDHC_XFERTYP_AC12EN (1U)        /*!< Bit field size in bits for SDHC_XFERTYP_AC12EN. */

/*! @brief Read current value of the SDHC_XFERTYP_AC12EN field. */
#define BR_SDHC_XFERTYP_AC12EN(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_AC12EN))

/*! @brief Format value for bitfield SDHC_XFERTYP_AC12EN. */
#define BF_SDHC_XFERTYP_AC12EN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_AC12EN) & BM_SDHC_XFERTYP_AC12EN)

/*! @brief Set the AC12EN field to a new value. */
#define BW_SDHC_XFERTYP_AC12EN(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_AC12EN) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field DTDSEL[4] (RW)
 *
 * Defines the direction of DAT line data transfers. The bit is set to 1 by the
 * host driver to transfer data from the SD card to the SDHC and is set to 0 for
 * all other commands.
 *
 * Values:
 * - 0 - Write host to card.
 * - 1 - Read card to host.
 */
/*@{*/
#define BP_SDHC_XFERTYP_DTDSEL (4U)        /*!< Bit position for SDHC_XFERTYP_DTDSEL. */
#define BM_SDHC_XFERTYP_DTDSEL (0x00000010U) /*!< Bit mask for SDHC_XFERTYP_DTDSEL. */
#define BS_SDHC_XFERTYP_DTDSEL (1U)        /*!< Bit field size in bits for SDHC_XFERTYP_DTDSEL. */

/*! @brief Read current value of the SDHC_XFERTYP_DTDSEL field. */
#define BR_SDHC_XFERTYP_DTDSEL(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_DTDSEL))

/*! @brief Format value for bitfield SDHC_XFERTYP_DTDSEL. */
#define BF_SDHC_XFERTYP_DTDSEL(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_DTDSEL) & BM_SDHC_XFERTYP_DTDSEL)

/*! @brief Set the DTDSEL field to a new value. */
#define BW_SDHC_XFERTYP_DTDSEL(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_DTDSEL) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field MSBSEL[5] (RW)
 *
 * Enables multiple block DAT line data transfers. For any other commands, this
 * bit shall be set to 0. If this bit is 0, it is not necessary to set the block
 * count register.
 *
 * Values:
 * - 0 - Single block.
 * - 1 - Multiple blocks.
 */
/*@{*/
#define BP_SDHC_XFERTYP_MSBSEL (5U)        /*!< Bit position for SDHC_XFERTYP_MSBSEL. */
#define BM_SDHC_XFERTYP_MSBSEL (0x00000020U) /*!< Bit mask for SDHC_XFERTYP_MSBSEL. */
#define BS_SDHC_XFERTYP_MSBSEL (1U)        /*!< Bit field size in bits for SDHC_XFERTYP_MSBSEL. */

/*! @brief Read current value of the SDHC_XFERTYP_MSBSEL field. */
#define BR_SDHC_XFERTYP_MSBSEL(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_MSBSEL))

/*! @brief Format value for bitfield SDHC_XFERTYP_MSBSEL. */
#define BF_SDHC_XFERTYP_MSBSEL(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_MSBSEL) & BM_SDHC_XFERTYP_MSBSEL)

/*! @brief Set the MSBSEL field to a new value. */
#define BW_SDHC_XFERTYP_MSBSEL(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_MSBSEL) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field RSPTYP[17:16] (RW)
 *
 * Values:
 * - 00 - No response.
 * - 01 - Response length 136.
 * - 10 - Response length 48.
 * - 11 - Response length 48, check busy after response.
 */
/*@{*/
#define BP_SDHC_XFERTYP_RSPTYP (16U)       /*!< Bit position for SDHC_XFERTYP_RSPTYP. */
#define BM_SDHC_XFERTYP_RSPTYP (0x00030000U) /*!< Bit mask for SDHC_XFERTYP_RSPTYP. */
#define BS_SDHC_XFERTYP_RSPTYP (2U)        /*!< Bit field size in bits for SDHC_XFERTYP_RSPTYP. */

/*! @brief Read current value of the SDHC_XFERTYP_RSPTYP field. */
#define BR_SDHC_XFERTYP_RSPTYP(x) (HW_SDHC_XFERTYP(x).B.RSPTYP)

/*! @brief Format value for bitfield SDHC_XFERTYP_RSPTYP. */
#define BF_SDHC_XFERTYP_RSPTYP(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_RSPTYP) & BM_SDHC_XFERTYP_RSPTYP)

/*! @brief Set the RSPTYP field to a new value. */
#define BW_SDHC_XFERTYP_RSPTYP(x, v) (HW_SDHC_XFERTYP_WR(x, (HW_SDHC_XFERTYP_RD(x) & ~BM_SDHC_XFERTYP_RSPTYP) | BF_SDHC_XFERTYP_RSPTYP(v)))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field CCCEN[19] (RW)
 *
 * If this bit is set to 1, the SDHC shall check the CRC field in the response.
 * If an error is detected, it is reported as a Command CRC Error. If this bit is
 * set to 0, the CRC field is not checked. The number of bits checked by the CRC
 * field value changes according to the length of the response.
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
/*@{*/
#define BP_SDHC_XFERTYP_CCCEN (19U)        /*!< Bit position for SDHC_XFERTYP_CCCEN. */
#define BM_SDHC_XFERTYP_CCCEN (0x00080000U) /*!< Bit mask for SDHC_XFERTYP_CCCEN. */
#define BS_SDHC_XFERTYP_CCCEN (1U)         /*!< Bit field size in bits for SDHC_XFERTYP_CCCEN. */

/*! @brief Read current value of the SDHC_XFERTYP_CCCEN field. */
#define BR_SDHC_XFERTYP_CCCEN(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_CCCEN))

/*! @brief Format value for bitfield SDHC_XFERTYP_CCCEN. */
#define BF_SDHC_XFERTYP_CCCEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_CCCEN) & BM_SDHC_XFERTYP_CCCEN)

/*! @brief Set the CCCEN field to a new value. */
#define BW_SDHC_XFERTYP_CCCEN(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_CCCEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field CICEN[20] (RW)
 *
 * If this bit is set to 1, the SDHC will check the index field in the response
 * to see if it has the same value as the command index. If it is not, it is
 * reported as a command index error. If this bit is set to 0, the index field is not
 * checked.
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
/*@{*/
#define BP_SDHC_XFERTYP_CICEN (20U)        /*!< Bit position for SDHC_XFERTYP_CICEN. */
#define BM_SDHC_XFERTYP_CICEN (0x00100000U) /*!< Bit mask for SDHC_XFERTYP_CICEN. */
#define BS_SDHC_XFERTYP_CICEN (1U)         /*!< Bit field size in bits for SDHC_XFERTYP_CICEN. */

/*! @brief Read current value of the SDHC_XFERTYP_CICEN field. */
#define BR_SDHC_XFERTYP_CICEN(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_CICEN))

/*! @brief Format value for bitfield SDHC_XFERTYP_CICEN. */
#define BF_SDHC_XFERTYP_CICEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_CICEN) & BM_SDHC_XFERTYP_CICEN)

/*! @brief Set the CICEN field to a new value. */
#define BW_SDHC_XFERTYP_CICEN(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_CICEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field DPSEL[21] (RW)
 *
 * This bit is set to 1 to indicate that data is present and shall be
 * transferred using the DAT line. It is set to 0 for the following: Commands using only
 * the CMD line, for example: CMD52. Commands with no data transfer, but using the
 * busy signal on DAT[0] line, R1b or R5b, for example: CMD38. In resume command,
 * this bit shall be set, and other bits in this register shall be set the same
 * as when the transfer was initially launched. When the Write Protect switch is
 * on, that is, the WPSPL bit is active as 0, any command with a write operation
 * will be ignored. That is to say, when this bit is set, while the DTDSEL bit is
 * 0, writes to the register Transfer Type are ignored.
 *
 * Values:
 * - 0 - No data present.
 * - 1 - Data present.
 */
/*@{*/
#define BP_SDHC_XFERTYP_DPSEL (21U)        /*!< Bit position for SDHC_XFERTYP_DPSEL. */
#define BM_SDHC_XFERTYP_DPSEL (0x00200000U) /*!< Bit mask for SDHC_XFERTYP_DPSEL. */
#define BS_SDHC_XFERTYP_DPSEL (1U)         /*!< Bit field size in bits for SDHC_XFERTYP_DPSEL. */

/*! @brief Read current value of the SDHC_XFERTYP_DPSEL field. */
#define BR_SDHC_XFERTYP_DPSEL(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_DPSEL))

/*! @brief Format value for bitfield SDHC_XFERTYP_DPSEL. */
#define BF_SDHC_XFERTYP_DPSEL(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_DPSEL) & BM_SDHC_XFERTYP_DPSEL)

/*! @brief Set the DPSEL field to a new value. */
#define BW_SDHC_XFERTYP_DPSEL(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_DPSEL) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field CMDTYP[23:22] (RW)
 *
 * There are three types of special commands: suspend, resume, and abort. These
 * bits shall be set to 00b for all other commands. Suspend command: If the
 * suspend command succeeds, the SDHC shall assume that the card bus has been released
 * and that it is possible to issue the next command which uses the DAT line.
 * Because the SDHC does not monitor the content of command response, it does not
 * know if the suspend command succeeded or not. It is the host driver's
 * responsibility to check the status of the suspend command and send another command
 * marked as suspend to inform the SDHC that a suspend command was successfully
 * issued. After the end bit of command is sent, the SDHC deasserts read wait for read
 * transactions and stops checking busy for write transactions. In 4-bit mode,
 * the interrupt cycle starts. If the suspend command fails, the SDHC will
 * maintain its current state, and the host driver shall restart the transfer by setting
 * PROCTL[CREQ]. Resume command: The host driver restarts the data transfer by
 * restoring the registers saved before sending the suspend command and then sends
 * the resume command. The SDHC will check for a pending busy state before
 * starting write transfers. Abort command: If this command is set when executing a
 * read transfer, the SDHC will stop reads to the buffer. If this command is set
 * when executing a write transfer, the SDHC will stop driving the DAT line. After
 * issuing the abort command, the host driver must issue a software reset (abort
 * transaction).
 *
 * Values:
 * - 00 - Normal other commands.
 * - 01 - Suspend CMD52 for writing bus suspend in CCCR.
 * - 10 - Resume CMD52 for writing function select in CCCR.
 * - 11 - Abort CMD12, CMD52 for writing I/O abort in CCCR.
 */
/*@{*/
#define BP_SDHC_XFERTYP_CMDTYP (22U)       /*!< Bit position for SDHC_XFERTYP_CMDTYP. */
#define BM_SDHC_XFERTYP_CMDTYP (0x00C00000U) /*!< Bit mask for SDHC_XFERTYP_CMDTYP. */
#define BS_SDHC_XFERTYP_CMDTYP (2U)        /*!< Bit field size in bits for SDHC_XFERTYP_CMDTYP. */

/*! @brief Read current value of the SDHC_XFERTYP_CMDTYP field. */
#define BR_SDHC_XFERTYP_CMDTYP(x) (HW_SDHC_XFERTYP(x).B.CMDTYP)

/*! @brief Format value for bitfield SDHC_XFERTYP_CMDTYP. */
#define BF_SDHC_XFERTYP_CMDTYP(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_CMDTYP) & BM_SDHC_XFERTYP_CMDTYP)

/*! @brief Set the CMDTYP field to a new value. */
#define BW_SDHC_XFERTYP_CMDTYP(x, v) (HW_SDHC_XFERTYP_WR(x, (HW_SDHC_XFERTYP_RD(x) & ~BM_SDHC_XFERTYP_CMDTYP) | BF_SDHC_XFERTYP_CMDTYP(v)))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field CMDINX[29:24] (RW)
 *
 * These bits shall be set to the command number that is specified in bits 45-40
 * of the command-format in the SD Memory Card Physical Layer Specification and
 * SDIO Card Specification.
 */
/*@{*/
#define BP_SDHC_XFERTYP_CMDINX (24U)       /*!< Bit position for SDHC_XFERTYP_CMDINX. */
#define BM_SDHC_XFERTYP_CMDINX (0x3F000000U) /*!< Bit mask for SDHC_XFERTYP_CMDINX. */
#define BS_SDHC_XFERTYP_CMDINX (6U)        /*!< Bit field size in bits for SDHC_XFERTYP_CMDINX. */

/*! @brief Read current value of the SDHC_XFERTYP_CMDINX field. */
#define BR_SDHC_XFERTYP_CMDINX(x) (HW_SDHC_XFERTYP(x).B.CMDINX)

/*! @brief Format value for bitfield SDHC_XFERTYP_CMDINX. */
#define BF_SDHC_XFERTYP_CMDINX(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_CMDINX) & BM_SDHC_XFERTYP_CMDINX)

/*! @brief Set the CMDINX field to a new value. */
#define BW_SDHC_XFERTYP_CMDINX(x, v) (HW_SDHC_XFERTYP_WR(x, (HW_SDHC_XFERTYP_RD(x) & ~BM_SDHC_XFERTYP_CMDINX) | BF_SDHC_XFERTYP_CMDINX(v)))
/*@}*/

/*******************************************************************************
 * HW_SDHC_CMDRSP0 - Command Response 0
 ******************************************************************************/

/*!
 * @brief HW_SDHC_CMDRSP0 - Command Response 0 (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to store part 0 of the response bits from the card.
 */
typedef union _hw_sdhc_cmdrsp0
{
    uint32_t U;
    struct _hw_sdhc_cmdrsp0_bitfields
    {
        uint32_t CMDRSP0 : 32;         /*!< [31:0] Command Response 0 */
    } B;
} hw_sdhc_cmdrsp0_t;

/*!
 * @name Constants and macros for entire SDHC_CMDRSP0 register
 */
/*@{*/
#define HW_SDHC_CMDRSP0_ADDR(x)  ((x) + 0x10U)

#define HW_SDHC_CMDRSP0(x)       (*(__I hw_sdhc_cmdrsp0_t *) HW_SDHC_CMDRSP0_ADDR(x))
#define HW_SDHC_CMDRSP0_RD(x)    (HW_SDHC_CMDRSP0(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_CMDRSP0 bitfields
 */

/*!
 * @name Register SDHC_CMDRSP0, field CMDRSP0[31:0] (RO)
 */
/*@{*/
#define BP_SDHC_CMDRSP0_CMDRSP0 (0U)       /*!< Bit position for SDHC_CMDRSP0_CMDRSP0. */
#define BM_SDHC_CMDRSP0_CMDRSP0 (0xFFFFFFFFU) /*!< Bit mask for SDHC_CMDRSP0_CMDRSP0. */
#define BS_SDHC_CMDRSP0_CMDRSP0 (32U)      /*!< Bit field size in bits for SDHC_CMDRSP0_CMDRSP0. */

/*! @brief Read current value of the SDHC_CMDRSP0_CMDRSP0 field. */
#define BR_SDHC_CMDRSP0_CMDRSP0(x) (HW_SDHC_CMDRSP0(x).U)
/*@}*/

/*******************************************************************************
 * HW_SDHC_CMDRSP1 - Command Response 1
 ******************************************************************************/

/*!
 * @brief HW_SDHC_CMDRSP1 - Command Response 1 (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to store part 1 of the response bits from the card.
 */
typedef union _hw_sdhc_cmdrsp1
{
    uint32_t U;
    struct _hw_sdhc_cmdrsp1_bitfields
    {
        uint32_t CMDRSP1 : 32;         /*!< [31:0] Command Response 1 */
    } B;
} hw_sdhc_cmdrsp1_t;

/*!
 * @name Constants and macros for entire SDHC_CMDRSP1 register
 */
/*@{*/
#define HW_SDHC_CMDRSP1_ADDR(x)  ((x) + 0x14U)

#define HW_SDHC_CMDRSP1(x)       (*(__I hw_sdhc_cmdrsp1_t *) HW_SDHC_CMDRSP1_ADDR(x))
#define HW_SDHC_CMDRSP1_RD(x)    (HW_SDHC_CMDRSP1(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_CMDRSP1 bitfields
 */

/*!
 * @name Register SDHC_CMDRSP1, field CMDRSP1[31:0] (RO)
 */
/*@{*/
#define BP_SDHC_CMDRSP1_CMDRSP1 (0U)       /*!< Bit position for SDHC_CMDRSP1_CMDRSP1. */
#define BM_SDHC_CMDRSP1_CMDRSP1 (0xFFFFFFFFU) /*!< Bit mask for SDHC_CMDRSP1_CMDRSP1. */
#define BS_SDHC_CMDRSP1_CMDRSP1 (32U)      /*!< Bit field size in bits for SDHC_CMDRSP1_CMDRSP1. */

/*! @brief Read current value of the SDHC_CMDRSP1_CMDRSP1 field. */
#define BR_SDHC_CMDRSP1_CMDRSP1(x) (HW_SDHC_CMDRSP1(x).U)
/*@}*/

/*******************************************************************************
 * HW_SDHC_CMDRSP2 - Command Response 2
 ******************************************************************************/

/*!
 * @brief HW_SDHC_CMDRSP2 - Command Response 2 (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to store part 2 of the response bits from the card.
 */
typedef union _hw_sdhc_cmdrsp2
{
    uint32_t U;
    struct _hw_sdhc_cmdrsp2_bitfields
    {
        uint32_t CMDRSP2 : 32;         /*!< [31:0] Command Response 2 */
    } B;
} hw_sdhc_cmdrsp2_t;

/*!
 * @name Constants and macros for entire SDHC_CMDRSP2 register
 */
/*@{*/
#define HW_SDHC_CMDRSP2_ADDR(x)  ((x) + 0x18U)

#define HW_SDHC_CMDRSP2(x)       (*(__I hw_sdhc_cmdrsp2_t *) HW_SDHC_CMDRSP2_ADDR(x))
#define HW_SDHC_CMDRSP2_RD(x)    (HW_SDHC_CMDRSP2(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_CMDRSP2 bitfields
 */

/*!
 * @name Register SDHC_CMDRSP2, field CMDRSP2[31:0] (RO)
 */
/*@{*/
#define BP_SDHC_CMDRSP2_CMDRSP2 (0U)       /*!< Bit position for SDHC_CMDRSP2_CMDRSP2. */
#define BM_SDHC_CMDRSP2_CMDRSP2 (0xFFFFFFFFU) /*!< Bit mask for SDHC_CMDRSP2_CMDRSP2. */
#define BS_SDHC_CMDRSP2_CMDRSP2 (32U)      /*!< Bit field size in bits for SDHC_CMDRSP2_CMDRSP2. */

/*! @brief Read current value of the SDHC_CMDRSP2_CMDRSP2 field. */
#define BR_SDHC_CMDRSP2_CMDRSP2(x) (HW_SDHC_CMDRSP2(x).U)
/*@}*/

/*******************************************************************************
 * HW_SDHC_CMDRSP3 - Command Response 3
 ******************************************************************************/

/*!
 * @brief HW_SDHC_CMDRSP3 - Command Response 3 (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to store part 3 of the response bits from the card. The
 * following table describes the mapping of command responses from the SD bus to
 * command response registers for each response type. In the table, R[ ] refers
 * to a bit range within the response data as transmitted on the SD bus. Response
 * bit definition for each response type Response type Meaning of response
 * Response field Response register R1,R1b (normal response) Card status R[39:8]
 * CMDRSP0 R1b (Auto CMD12 response) Card status for auto CMD12 R[39:8] CMDRSP3 R2
 * (CID, CSD register) CID/CSD register [127:8] R[127:8] {CMDRSP3[23:0], CMDRSP2,
 * CMDRSP1, CMDRSP0} R3 (OCR register) OCR register for memory R[39:8] CMDRSP0 R4
 * (OCR register) OCR register for I/O etc. R[39:8] CMDRSP0 R5, R5b SDIO response
 * R[39:8] CMDRSP0 R6 (Publish RCA) New published RCA[31:16] and card
 * status[15:0] R[39:9] CMDRSP0 This table shows that most responses with a length of 48
 * (R[47:0]) have 32-bit of the response data (R[39:8]) stored in the CMDRSP0
 * register. Responses of type R1b (auto CMD12 responses) have response data bits
 * (R[39:8]) stored in the CMDRSP3 register. Responses with length 136 (R[135:0]) have
 * 120-bit of the response data (R[127:8]) stored in the CMDRSP0, 1, 2, and 3
 * registers. To be able to read the response status efficiently, the SDHC stores
 * only a part of the response data in the command response registers. This
 * enables the host driver to efficiently read 32-bit of response data in one read
 * cycle on a 32-bit bus system. Parts of the response, the index field and the CRC,
 * are checked by the SDHC, as specified by XFERTYP[CICEN] and XFERTYP[CCCEN],
 * and generate an error interrupt if any error is detected. The bit range for the
 * CRC check depends on the response length. If the response length is 48, the
 * SDHC will check R[47:1], and if the response length is 136 the SDHC will check
 * R[119:1]. Because the SDHC may have a multiple block data transfer executing
 * concurrently with a CMD_wo_DAT command, the SDHC stores the auto CMD12 response
 * in the CMDRSP3 register. The CMD_wo_DAT response is stored in CMDRSP0. This
 * allows the SDHC to avoid overwriting the Auto CMD12 response with the CMD_wo_DAT
 * and vice versa. When the SDHC modifies part of the command response
 * registers, as shown in the table above, it preserves the unmodified bits.
 */
typedef union _hw_sdhc_cmdrsp3
{
    uint32_t U;
    struct _hw_sdhc_cmdrsp3_bitfields
    {
        uint32_t CMDRSP3 : 32;         /*!< [31:0] Command Response 3 */
    } B;
} hw_sdhc_cmdrsp3_t;

/*!
 * @name Constants and macros for entire SDHC_CMDRSP3 register
 */
/*@{*/
#define HW_SDHC_CMDRSP3_ADDR(x)  ((x) + 0x1CU)

#define HW_SDHC_CMDRSP3(x)       (*(__I hw_sdhc_cmdrsp3_t *) HW_SDHC_CMDRSP3_ADDR(x))
#define HW_SDHC_CMDRSP3_RD(x)    (HW_SDHC_CMDRSP3(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_CMDRSP3 bitfields
 */

/*!
 * @name Register SDHC_CMDRSP3, field CMDRSP3[31:0] (RO)
 */
/*@{*/
#define BP_SDHC_CMDRSP3_CMDRSP3 (0U)       /*!< Bit position for SDHC_CMDRSP3_CMDRSP3. */
#define BM_SDHC_CMDRSP3_CMDRSP3 (0xFFFFFFFFU) /*!< Bit mask for SDHC_CMDRSP3_CMDRSP3. */
#define BS_SDHC_CMDRSP3_CMDRSP3 (32U)      /*!< Bit field size in bits for SDHC_CMDRSP3_CMDRSP3. */

/*! @brief Read current value of the SDHC_CMDRSP3_CMDRSP3 field. */
#define BR_SDHC_CMDRSP3_CMDRSP3(x) (HW_SDHC_CMDRSP3(x).U)
/*@}*/

/*******************************************************************************
 * HW_SDHC_DATPORT - Buffer Data Port register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_DATPORT - Buffer Data Port register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This is a 32-bit data port register used to access the internal buffer and it
 * cannot be updated in Idle mode.
 */
typedef union _hw_sdhc_datport
{
    uint32_t U;
    struct _hw_sdhc_datport_bitfields
    {
        uint32_t DATCONT : 32;         /*!< [31:0] Data Content */
    } B;
} hw_sdhc_datport_t;

/*!
 * @name Constants and macros for entire SDHC_DATPORT register
 */
/*@{*/
#define HW_SDHC_DATPORT_ADDR(x)  ((x) + 0x20U)

#define HW_SDHC_DATPORT(x)       (*(__IO hw_sdhc_datport_t *) HW_SDHC_DATPORT_ADDR(x))
#define HW_SDHC_DATPORT_RD(x)    (HW_SDHC_DATPORT(x).U)
#define HW_SDHC_DATPORT_WR(x, v) (HW_SDHC_DATPORT(x).U = (v))
#define HW_SDHC_DATPORT_SET(x, v) (HW_SDHC_DATPORT_WR(x, HW_SDHC_DATPORT_RD(x) |  (v)))
#define HW_SDHC_DATPORT_CLR(x, v) (HW_SDHC_DATPORT_WR(x, HW_SDHC_DATPORT_RD(x) & ~(v)))
#define HW_SDHC_DATPORT_TOG(x, v) (HW_SDHC_DATPORT_WR(x, HW_SDHC_DATPORT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_DATPORT bitfields
 */

/*!
 * @name Register SDHC_DATPORT, field DATCONT[31:0] (RW)
 *
 * The Buffer Data Port register is for 32-bit data access by the CPU or the
 * external DMA. When the internal DMA is enabled, any write to this register is
 * ignored, and any read from this register will always yield 0s.
 */
/*@{*/
#define BP_SDHC_DATPORT_DATCONT (0U)       /*!< Bit position for SDHC_DATPORT_DATCONT. */
#define BM_SDHC_DATPORT_DATCONT (0xFFFFFFFFU) /*!< Bit mask for SDHC_DATPORT_DATCONT. */
#define BS_SDHC_DATPORT_DATCONT (32U)      /*!< Bit field size in bits for SDHC_DATPORT_DATCONT. */

/*! @brief Read current value of the SDHC_DATPORT_DATCONT field. */
#define BR_SDHC_DATPORT_DATCONT(x) (HW_SDHC_DATPORT(x).U)

/*! @brief Format value for bitfield SDHC_DATPORT_DATCONT. */
#define BF_SDHC_DATPORT_DATCONT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_DATPORT_DATCONT) & BM_SDHC_DATPORT_DATCONT)

/*! @brief Set the DATCONT field to a new value. */
#define BW_SDHC_DATPORT_DATCONT(x, v) (HW_SDHC_DATPORT_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_PRSSTAT - Present State register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_PRSSTAT - Present State register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The host driver can get status of the SDHC from this 32-bit read-only
 * register. The host driver can issue CMD0, CMD12, CMD13 (for memory) and CMD52 (for
 * SDIO) when the DAT lines are busy during a data transfer. These commands can be
 * issued when Command Inhibit (CIHB) is set to zero. Other commands shall be
 * issued when Command Inhibit (CDIHB) is set to zero. Possible changes to the SD
 * Physical Specification may add other commands to this list in the future.
 */
typedef union _hw_sdhc_prsstat
{
    uint32_t U;
    struct _hw_sdhc_prsstat_bitfields
    {
        uint32_t CIHB : 1;             /*!< [0] Command Inhibit (CMD) */
        uint32_t CDIHB : 1;            /*!< [1] Command Inhibit (DAT) */
        uint32_t DLA : 1;              /*!< [2] Data Line Active */
        uint32_t SDSTB : 1;            /*!< [3] SD Clock Stable */
        uint32_t IPGOFF : 1;           /*!< [4] Bus Clock Gated Off Internally */
        uint32_t HCKOFF : 1;           /*!< [5] System Clock Gated Off Internally */
        uint32_t PEROFF : 1;           /*!< [6] SDHC clock Gated Off Internally */
        uint32_t SDOFF : 1;            /*!< [7] SD Clock Gated Off Internally */
        uint32_t WTA : 1;              /*!< [8] Write Transfer Active */
        uint32_t RTA : 1;              /*!< [9] Read Transfer Active */
        uint32_t BWEN : 1;             /*!< [10] Buffer Write Enable */
        uint32_t BREN : 1;             /*!< [11] Buffer Read Enable */
        uint32_t RESERVED0 : 4;        /*!< [15:12]  */
        uint32_t CINS : 1;             /*!< [16] Card Inserted */
        uint32_t RESERVED1 : 6;        /*!< [22:17]  */
        uint32_t CLSL : 1;             /*!< [23] CMD Line Signal Level */
        uint32_t DLSL : 8;             /*!< [31:24] DAT Line Signal Level */
    } B;
} hw_sdhc_prsstat_t;

/*!
 * @name Constants and macros for entire SDHC_PRSSTAT register
 */
/*@{*/
#define HW_SDHC_PRSSTAT_ADDR(x)  ((x) + 0x24U)

#define HW_SDHC_PRSSTAT(x)       (*(__I hw_sdhc_prsstat_t *) HW_SDHC_PRSSTAT_ADDR(x))
#define HW_SDHC_PRSSTAT_RD(x)    (HW_SDHC_PRSSTAT(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_PRSSTAT bitfields
 */

/*!
 * @name Register SDHC_PRSSTAT, field CIHB[0] (RO)
 *
 * If this status bit is 0, it indicates that the CMD line is not in use and the
 * SDHC can issue a SD/MMC Command using the CMD line. This bit is set also
 * immediately after the Transfer Type register is written. This bit is cleared when
 * the command response is received. Even if the CDIHB bit is set to 1, Commands
 * using only the CMD line can be issued if this bit is 0. Changing from 1 to 0
 * generates a command complete interrupt in the interrupt status register. If the
 * SDHC cannot issue the command because of a command conflict error (see
 * command CRC error) or because of a command not issued by auto CMD12 error, this bit
 * will remain 1 and the command complete is not set. The status of issuing an
 * auto CMD12 does not show on this bit.
 *
 * Values:
 * - 0 - Can issue command using only CMD line.
 * - 1 - Cannot issue command.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_CIHB (0U)          /*!< Bit position for SDHC_PRSSTAT_CIHB. */
#define BM_SDHC_PRSSTAT_CIHB (0x00000001U) /*!< Bit mask for SDHC_PRSSTAT_CIHB. */
#define BS_SDHC_PRSSTAT_CIHB (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_CIHB. */

/*! @brief Read current value of the SDHC_PRSSTAT_CIHB field. */
#define BR_SDHC_PRSSTAT_CIHB(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_CIHB))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field CDIHB[1] (RO)
 *
 * This status bit is generated if either the DLA or the RTA is set to 1. If
 * this bit is 0, it indicates that the SDHC can issue the next SD/MMC Command.
 * Commands with a busy signal belong to CDIHB, for example, R1b, R5b type. Except in
 * the case when the command busy is finished, changing from 1 to 0 generates a
 * transfer complete interrupt in the Interrupt Status register. The SD host
 * driver can save registers for a suspend transaction after this bit has changed
 * from 1 to 0.
 *
 * Values:
 * - 0 - Can issue command which uses the DAT line.
 * - 1 - Cannot issue command which uses the DAT line.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_CDIHB (1U)         /*!< Bit position for SDHC_PRSSTAT_CDIHB. */
#define BM_SDHC_PRSSTAT_CDIHB (0x00000002U) /*!< Bit mask for SDHC_PRSSTAT_CDIHB. */
#define BS_SDHC_PRSSTAT_CDIHB (1U)         /*!< Bit field size in bits for SDHC_PRSSTAT_CDIHB. */

/*! @brief Read current value of the SDHC_PRSSTAT_CDIHB field. */
#define BR_SDHC_PRSSTAT_CDIHB(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_CDIHB))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field DLA[2] (RO)
 *
 * Indicates whether one of the DAT lines on the SD bus is in use. In the case
 * of read transactions: This status indicates whether a read transfer is
 * executing on the SD bus. Changes in this value from 1 to 0, between data blocks,
 * generates a block gap event interrupt in the Interrupt Status register. This bit
 * will be set in either of the following cases: After the end bit of the read
 * command. When writing a 1 to PROCTL[CREQ] to restart a read transfer. This bit
 * will be cleared in either of the following cases: When the end bit of the last
 * data block is sent from the SD bus to the SDHC. When the read wait state is
 * stopped by a suspend command and the DAT2 line is released. The SDHC will wait at
 * the next block gap by driving read wait at the start of the interrupt cycle.
 * If the read wait signal is already driven (data buffer cannot receive data),
 * the SDHC can wait for a current block gap by continuing to drive the read wait
 * signal. It is necessary to support read wait to use the suspend / resume
 * function. This bit will remain 1 during read wait. In the case of write
 * transactions: This status indicates that a write transfer is executing on the SD bus.
 * Changes in this value from 1 to 0 generate a transfer complete interrupt in the
 * interrupt status register. This bit will be set in either of the following
 * cases: After the end bit of the write command. When writing to 1 to PROCTL[CREQ] to
 * continue a write transfer. This bit will be cleared in either of the
 * following cases: When the SD card releases write busy of the last data block, the SDHC
 * will also detect if the output is not busy. If the SD card does not drive the
 * busy signal after the CRC status is received, the SDHC shall assume the card
 * drive "Not busy". When the SD card releases write busy, prior to waiting for
 * write transfer, and as a result of a stop at block gap request. In the case of
 * command with busy pending: This status indicates that a busy state follows the
 * command and the data line is in use. This bit will be cleared when the DAT0
 * line is released.
 *
 * Values:
 * - 0 - DAT line inactive.
 * - 1 - DAT line active.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_DLA  (2U)          /*!< Bit position for SDHC_PRSSTAT_DLA. */
#define BM_SDHC_PRSSTAT_DLA  (0x00000004U) /*!< Bit mask for SDHC_PRSSTAT_DLA. */
#define BS_SDHC_PRSSTAT_DLA  (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_DLA. */

/*! @brief Read current value of the SDHC_PRSSTAT_DLA field. */
#define BR_SDHC_PRSSTAT_DLA(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_DLA))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field SDSTB[3] (RO)
 *
 * Indicates that the internal card clock is stable. This bit is for the host
 * driver to poll clock status when changing the clock frequency. It is recommended
 * to clear SYSCTL[SDCLKEN] to remove glitch on the card clock when the
 * frequency is changing.
 *
 * Values:
 * - 0 - Clock is changing frequency and not stable.
 * - 1 - Clock is stable.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_SDSTB (3U)         /*!< Bit position for SDHC_PRSSTAT_SDSTB. */
#define BM_SDHC_PRSSTAT_SDSTB (0x00000008U) /*!< Bit mask for SDHC_PRSSTAT_SDSTB. */
#define BS_SDHC_PRSSTAT_SDSTB (1U)         /*!< Bit field size in bits for SDHC_PRSSTAT_SDSTB. */

/*! @brief Read current value of the SDHC_PRSSTAT_SDSTB field. */
#define BR_SDHC_PRSSTAT_SDSTB(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_SDSTB))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field IPGOFF[4] (RO)
 *
 * Indicates that the bus clock is internally gated off. This bit is for the
 * host driver to debug.
 *
 * Values:
 * - 0 - Bus clock is active.
 * - 1 - Bus clock is gated off.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_IPGOFF (4U)        /*!< Bit position for SDHC_PRSSTAT_IPGOFF. */
#define BM_SDHC_PRSSTAT_IPGOFF (0x00000010U) /*!< Bit mask for SDHC_PRSSTAT_IPGOFF. */
#define BS_SDHC_PRSSTAT_IPGOFF (1U)        /*!< Bit field size in bits for SDHC_PRSSTAT_IPGOFF. */

/*! @brief Read current value of the SDHC_PRSSTAT_IPGOFF field. */
#define BR_SDHC_PRSSTAT_IPGOFF(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_IPGOFF))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field HCKOFF[5] (RO)
 *
 * Indicates that the system clock is internally gated off. This bit is for the
 * host driver to debug during a data transfer.
 *
 * Values:
 * - 0 - System clock is active.
 * - 1 - System clock is gated off.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_HCKOFF (5U)        /*!< Bit position for SDHC_PRSSTAT_HCKOFF. */
#define BM_SDHC_PRSSTAT_HCKOFF (0x00000020U) /*!< Bit mask for SDHC_PRSSTAT_HCKOFF. */
#define BS_SDHC_PRSSTAT_HCKOFF (1U)        /*!< Bit field size in bits for SDHC_PRSSTAT_HCKOFF. */

/*! @brief Read current value of the SDHC_PRSSTAT_HCKOFF field. */
#define BR_SDHC_PRSSTAT_HCKOFF(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_HCKOFF))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field PEROFF[6] (RO)
 *
 * Indicates that the is internally gated off. This bit is for the host driver
 * to debug transaction on the SD bus. When INITA bit is set, SDHC sending 80
 * clock cycles to the card, SDCLKEN must be 1 to enable the output card clock,
 * otherwise the will never be gate off, so and will be always active. SDHC clock SDHC
 * clock SDHC clock bus clock
 *
 * Values:
 * - 0 - SDHC clock is active.
 * - 1 - SDHC clock is gated off.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_PEROFF (6U)        /*!< Bit position for SDHC_PRSSTAT_PEROFF. */
#define BM_SDHC_PRSSTAT_PEROFF (0x00000040U) /*!< Bit mask for SDHC_PRSSTAT_PEROFF. */
#define BS_SDHC_PRSSTAT_PEROFF (1U)        /*!< Bit field size in bits for SDHC_PRSSTAT_PEROFF. */

/*! @brief Read current value of the SDHC_PRSSTAT_PEROFF field. */
#define BR_SDHC_PRSSTAT_PEROFF(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_PEROFF))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field SDOFF[7] (RO)
 *
 * Indicates that the SD clock is internally gated off, because of buffer
 * over/under-run or read pause without read wait assertion, or the driver has cleared
 * SYSCTL[SDCLKEN] to stop the SD clock. This bit is for the host driver to debug
 * data transaction on the SD bus.
 *
 * Values:
 * - 0 - SD clock is active.
 * - 1 - SD clock is gated off.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_SDOFF (7U)         /*!< Bit position for SDHC_PRSSTAT_SDOFF. */
#define BM_SDHC_PRSSTAT_SDOFF (0x00000080U) /*!< Bit mask for SDHC_PRSSTAT_SDOFF. */
#define BS_SDHC_PRSSTAT_SDOFF (1U)         /*!< Bit field size in bits for SDHC_PRSSTAT_SDOFF. */

/*! @brief Read current value of the SDHC_PRSSTAT_SDOFF field. */
#define BR_SDHC_PRSSTAT_SDOFF(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_SDOFF))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field WTA[8] (RO)
 *
 * Indicates that a write transfer is active. If this bit is 0, it means no
 * valid write data exists in the SDHC. This bit is set in either of the following
 * cases: After the end bit of the write command. When writing 1 to PROCTL[CREQ] to
 * restart a write transfer. This bit is cleared in either of the following
 * cases: After getting the CRC status of the last data block as specified by the
 * transfer count (single and multiple). After getting the CRC status of any block
 * where data transmission is about to be stopped by a stop at block gap request.
 * During a write transaction, a block gap event interrupt is generated when this
 * bit is changed to 0, as result of the stop at block gap request being set.
 * This status is useful for the host driver in determining when to issue commands
 * during write busy state.
 *
 * Values:
 * - 0 - No valid data.
 * - 1 - Transferring data.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_WTA  (8U)          /*!< Bit position for SDHC_PRSSTAT_WTA. */
#define BM_SDHC_PRSSTAT_WTA  (0x00000100U) /*!< Bit mask for SDHC_PRSSTAT_WTA. */
#define BS_SDHC_PRSSTAT_WTA  (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_WTA. */

/*! @brief Read current value of the SDHC_PRSSTAT_WTA field. */
#define BR_SDHC_PRSSTAT_WTA(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_WTA))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field RTA[9] (RO)
 *
 * Used for detecting completion of a read transfer. This bit is set for either
 * of the following conditions: After the end bit of the read command. When
 * writing a 1 to PROCTL[CREQ] to restart a read transfer. A transfer complete
 * interrupt is generated when this bit changes to 0. This bit is cleared for either of
 * the following conditions: When the last data block as specified by block
 * length is transferred to the system, that is, all data are read away from SDHC
 * internal buffer. When all valid data blocks have been transferred from SDHC
 * internal buffer to the system and no current block transfers are being sent as a
 * result of the stop at block gap request being set to 1.
 *
 * Values:
 * - 0 - No valid data.
 * - 1 - Transferring data.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_RTA  (9U)          /*!< Bit position for SDHC_PRSSTAT_RTA. */
#define BM_SDHC_PRSSTAT_RTA  (0x00000200U) /*!< Bit mask for SDHC_PRSSTAT_RTA. */
#define BS_SDHC_PRSSTAT_RTA  (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_RTA. */

/*! @brief Read current value of the SDHC_PRSSTAT_RTA field. */
#define BR_SDHC_PRSSTAT_RTA(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_RTA))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field BWEN[10] (RO)
 *
 * Used for non-DMA write transfers. The SDHC can implement multiple buffers to
 * transfer data efficiently. This read-only flag indicates whether space is
 * available for write data. If this bit is 1, valid data greater than the watermark
 * level can be written to the buffer. This read-only flag indicates whether
 * space is available for write data.
 *
 * Values:
 * - 0 - Write disable, the buffer can hold valid data less than the write
 *     watermark level.
 * - 1 - Write enable, the buffer can hold valid data greater than the write
 *     watermark level.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_BWEN (10U)         /*!< Bit position for SDHC_PRSSTAT_BWEN. */
#define BM_SDHC_PRSSTAT_BWEN (0x00000400U) /*!< Bit mask for SDHC_PRSSTAT_BWEN. */
#define BS_SDHC_PRSSTAT_BWEN (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_BWEN. */

/*! @brief Read current value of the SDHC_PRSSTAT_BWEN field. */
#define BR_SDHC_PRSSTAT_BWEN(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_BWEN))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field BREN[11] (RO)
 *
 * Used for non-DMA read transfers. The SDHC may implement multiple buffers to
 * transfer data efficiently. This read-only flag indicates that valid data exists
 * in the host side buffer. If this bit is high, valid data greater than the
 * watermark level exist in the buffer. This read-only flag indicates that valid
 * data exists in the host side buffer.
 *
 * Values:
 * - 0 - Read disable, valid data less than the watermark level exist in the
 *     buffer.
 * - 1 - Read enable, valid data greater than the watermark level exist in the
 *     buffer.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_BREN (11U)         /*!< Bit position for SDHC_PRSSTAT_BREN. */
#define BM_SDHC_PRSSTAT_BREN (0x00000800U) /*!< Bit mask for SDHC_PRSSTAT_BREN. */
#define BS_SDHC_PRSSTAT_BREN (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_BREN. */

/*! @brief Read current value of the SDHC_PRSSTAT_BREN field. */
#define BR_SDHC_PRSSTAT_BREN(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_BREN))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field CINS[16] (RO)
 *
 * Indicates whether a card has been inserted. The SDHC debounces this signal so
 * that the host driver will not need to wait for it to stabilize. Changing from
 * a 0 to 1 generates a card insertion interrupt in the Interrupt Status
 * register. Changing from a 1 to 0 generates a card removal interrupt in the Interrupt
 * Status register. A write to the force event register does not effect this bit.
 * SYSCTL[RSTA] does not effect this bit. A software reset does not effect this
 * bit.
 *
 * Values:
 * - 0 - Power on reset or no card.
 * - 1 - Card inserted.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_CINS (16U)         /*!< Bit position for SDHC_PRSSTAT_CINS. */
#define BM_SDHC_PRSSTAT_CINS (0x00010000U) /*!< Bit mask for SDHC_PRSSTAT_CINS. */
#define BS_SDHC_PRSSTAT_CINS (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_CINS. */

/*! @brief Read current value of the SDHC_PRSSTAT_CINS field. */
#define BR_SDHC_PRSSTAT_CINS(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_CINS))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field CLSL[23] (RO)
 *
 * Used to check the CMD line level to recover from errors, and for debugging.
 * The reset value is effected by the external pullup/pulldown resistor, by
 * default, the read value of this bit after reset is 1b, when the command line is
 * pulled up.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_CLSL (23U)         /*!< Bit position for SDHC_PRSSTAT_CLSL. */
#define BM_SDHC_PRSSTAT_CLSL (0x00800000U) /*!< Bit mask for SDHC_PRSSTAT_CLSL. */
#define BS_SDHC_PRSSTAT_CLSL (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_CLSL. */

/*! @brief Read current value of the SDHC_PRSSTAT_CLSL field. */
#define BR_SDHC_PRSSTAT_CLSL(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_CLSL))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field DLSL[31:24] (RO)
 *
 * Used to check the DAT line level to recover from errors, and for debugging.
 * This is especially useful in detecting the busy signal level from DAT[0]. The
 * reset value is effected by the external pullup/pulldown resistors. By default,
 * the read value of this field after reset is 8'b11110111, when DAT[3] is pulled
 * down and the other lines are pulled up.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_DLSL (24U)         /*!< Bit position for SDHC_PRSSTAT_DLSL. */
#define BM_SDHC_PRSSTAT_DLSL (0xFF000000U) /*!< Bit mask for SDHC_PRSSTAT_DLSL. */
#define BS_SDHC_PRSSTAT_DLSL (8U)          /*!< Bit field size in bits for SDHC_PRSSTAT_DLSL. */

/*! @brief Read current value of the SDHC_PRSSTAT_DLSL field. */
#define BR_SDHC_PRSSTAT_DLSL(x) (HW_SDHC_PRSSTAT(x).B.DLSL)
/*@}*/

/*******************************************************************************
 * HW_SDHC_PROCTL - Protocol Control register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_PROCTL - Protocol Control register (RW)
 *
 * Reset value: 0x00000020U
 *
 * There are three cases to restart the transfer after stop at the block gap.
 * Which case is appropriate depends on whether the SDHC issues a suspend command
 * or the SD card accepts the suspend command: If the host driver does not issue a
 * suspend command, the continue request shall be used to restart the transfer.
 * If the host driver issues a suspend command and the SD card accepts it, a
 * resume command shall be used to restart the transfer. If the host driver issues a
 * suspend command and the SD card does not accept it, the continue request shall
 * be used to restart the transfer. Any time stop at block gap request stops the
 * data transfer, the host driver shall wait for a transfer complete (in the
 * interrupt status register), before attempting to restart the transfer. When
 * restarting the data transfer by continue request, the host driver shall clear the
 * stop at block gap request before or simultaneously.
 */
typedef union _hw_sdhc_proctl
{
    uint32_t U;
    struct _hw_sdhc_proctl_bitfields
    {
        uint32_t LCTL : 1;             /*!< [0] LED Control */
        uint32_t DTW : 2;              /*!< [2:1] Data Transfer Width */
        uint32_t D3CD : 1;             /*!< [3] DAT3 As Card Detection Pin */
        uint32_t EMODE : 2;            /*!< [5:4] Endian Mode */
        uint32_t CDTL : 1;             /*!< [6] Card Detect Test Level */
        uint32_t CDSS : 1;             /*!< [7] Card Detect Signal Selection */
        uint32_t DMAS : 2;             /*!< [9:8] DMA Select */
        uint32_t RESERVED0 : 6;        /*!< [15:10]  */
        uint32_t SABGREQ : 1;          /*!< [16] Stop At Block Gap Request */
        uint32_t CREQ : 1;             /*!< [17] Continue Request */
        uint32_t RWCTL : 1;            /*!< [18] Read Wait Control */
        uint32_t IABG : 1;             /*!< [19] Interrupt At Block Gap */
        uint32_t RESERVED1 : 4;        /*!< [23:20]  */
        uint32_t WECINT : 1;           /*!< [24] Wakeup Event Enable On Card Interrupt
                                        * */
        uint32_t WECINS : 1;           /*!< [25] Wakeup Event Enable On SD Card
                                        * Insertion */
        uint32_t WECRM : 1;            /*!< [26] Wakeup Event Enable On SD Card Removal
                                        * */
        uint32_t RESERVED2 : 5;        /*!< [31:27]  */
    } B;
} hw_sdhc_proctl_t;

/*!
 * @name Constants and macros for entire SDHC_PROCTL register
 */
/*@{*/
#define HW_SDHC_PROCTL_ADDR(x)   ((x) + 0x28U)

#define HW_SDHC_PROCTL(x)        (*(__IO hw_sdhc_proctl_t *) HW_SDHC_PROCTL_ADDR(x))
#define HW_SDHC_PROCTL_RD(x)     (HW_SDHC_PROCTL(x).U)
#define HW_SDHC_PROCTL_WR(x, v)  (HW_SDHC_PROCTL(x).U = (v))
#define HW_SDHC_PROCTL_SET(x, v) (HW_SDHC_PROCTL_WR(x, HW_SDHC_PROCTL_RD(x) |  (v)))
#define HW_SDHC_PROCTL_CLR(x, v) (HW_SDHC_PROCTL_WR(x, HW_SDHC_PROCTL_RD(x) & ~(v)))
#define HW_SDHC_PROCTL_TOG(x, v) (HW_SDHC_PROCTL_WR(x, HW_SDHC_PROCTL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_PROCTL bitfields
 */

/*!
 * @name Register SDHC_PROCTL, field LCTL[0] (RW)
 *
 * This bit, fully controlled by the host driver, is used to caution the user
 * not to remove the card while the card is being accessed. If the software is
 * going to issue multiple SD commands, this bit can be set during all these
 * transactions. It is not necessary to change for each transaction. When the software
 * issues multiple SD commands, setting the bit once before the first command is
 * sufficient: it is not necessary to reset the bit between commands.
 *
 * Values:
 * - 0 - LED off.
 * - 1 - LED on.
 */
/*@{*/
#define BP_SDHC_PROCTL_LCTL  (0U)          /*!< Bit position for SDHC_PROCTL_LCTL. */
#define BM_SDHC_PROCTL_LCTL  (0x00000001U) /*!< Bit mask for SDHC_PROCTL_LCTL. */
#define BS_SDHC_PROCTL_LCTL  (1U)          /*!< Bit field size in bits for SDHC_PROCTL_LCTL. */

/*! @brief Read current value of the SDHC_PROCTL_LCTL field. */
#define BR_SDHC_PROCTL_LCTL(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_LCTL))

/*! @brief Format value for bitfield SDHC_PROCTL_LCTL. */
#define BF_SDHC_PROCTL_LCTL(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_LCTL) & BM_SDHC_PROCTL_LCTL)

/*! @brief Set the LCTL field to a new value. */
#define BW_SDHC_PROCTL_LCTL(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_LCTL) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field DTW[2:1] (RW)
 *
 * Selects the data width of the SD bus for a data transfer. The host driver
 * shall set it to match the data width of the card. Possible data transfer width is
 * 1-bit, 4-bits or 8-bits.
 *
 * Values:
 * - 00 - 1-bit mode
 * - 01 - 4-bit mode
 * - 10 - 8-bit mode
 * - 11 - Reserved
 */
/*@{*/
#define BP_SDHC_PROCTL_DTW   (1U)          /*!< Bit position for SDHC_PROCTL_DTW. */
#define BM_SDHC_PROCTL_DTW   (0x00000006U) /*!< Bit mask for SDHC_PROCTL_DTW. */
#define BS_SDHC_PROCTL_DTW   (2U)          /*!< Bit field size in bits for SDHC_PROCTL_DTW. */

/*! @brief Read current value of the SDHC_PROCTL_DTW field. */
#define BR_SDHC_PROCTL_DTW(x) (HW_SDHC_PROCTL(x).B.DTW)

/*! @brief Format value for bitfield SDHC_PROCTL_DTW. */
#define BF_SDHC_PROCTL_DTW(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_DTW) & BM_SDHC_PROCTL_DTW)

/*! @brief Set the DTW field to a new value. */
#define BW_SDHC_PROCTL_DTW(x, v) (HW_SDHC_PROCTL_WR(x, (HW_SDHC_PROCTL_RD(x) & ~BM_SDHC_PROCTL_DTW) | BF_SDHC_PROCTL_DTW(v)))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field D3CD[3] (RW)
 *
 * If this bit is set, DAT3 should be pulled down to act as a card detection
 * pin. Be cautious when using this feature, because DAT3 is also a chip-select for
 * the SPI mode. A pulldown on this pin and CMD0 may set the card into the SPI
 * mode, which the SDHC does not support. Note: Keep this bit set if SDIO interrupt
 * is used.
 *
 * Values:
 * - 0 - DAT3 does not monitor card Insertion.
 * - 1 - DAT3 as card detection pin.
 */
/*@{*/
#define BP_SDHC_PROCTL_D3CD  (3U)          /*!< Bit position for SDHC_PROCTL_D3CD. */
#define BM_SDHC_PROCTL_D3CD  (0x00000008U) /*!< Bit mask for SDHC_PROCTL_D3CD. */
#define BS_SDHC_PROCTL_D3CD  (1U)          /*!< Bit field size in bits for SDHC_PROCTL_D3CD. */

/*! @brief Read current value of the SDHC_PROCTL_D3CD field. */
#define BR_SDHC_PROCTL_D3CD(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_D3CD))

/*! @brief Format value for bitfield SDHC_PROCTL_D3CD. */
#define BF_SDHC_PROCTL_D3CD(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_D3CD) & BM_SDHC_PROCTL_D3CD)

/*! @brief Set the D3CD field to a new value. */
#define BW_SDHC_PROCTL_D3CD(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_D3CD) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field EMODE[5:4] (RW)
 *
 * The SDHC supports all four endian modes in data transfer.
 *
 * Values:
 * - 00 - Big endian mode
 * - 01 - Half word big endian mode
 * - 10 - Little endian mode
 * - 11 - Reserved
 */
/*@{*/
#define BP_SDHC_PROCTL_EMODE (4U)          /*!< Bit position for SDHC_PROCTL_EMODE. */
#define BM_SDHC_PROCTL_EMODE (0x00000030U) /*!< Bit mask for SDHC_PROCTL_EMODE. */
#define BS_SDHC_PROCTL_EMODE (2U)          /*!< Bit field size in bits for SDHC_PROCTL_EMODE. */

/*! @brief Read current value of the SDHC_PROCTL_EMODE field. */
#define BR_SDHC_PROCTL_EMODE(x) (HW_SDHC_PROCTL(x).B.EMODE)

/*! @brief Format value for bitfield SDHC_PROCTL_EMODE. */
#define BF_SDHC_PROCTL_EMODE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_EMODE) & BM_SDHC_PROCTL_EMODE)

/*! @brief Set the EMODE field to a new value. */
#define BW_SDHC_PROCTL_EMODE(x, v) (HW_SDHC_PROCTL_WR(x, (HW_SDHC_PROCTL_RD(x) & ~BM_SDHC_PROCTL_EMODE) | BF_SDHC_PROCTL_EMODE(v)))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field CDTL[6] (RW)
 *
 * Enabled while the CDSS is set to 1 and it indicates card insertion.
 *
 * Values:
 * - 0 - Card detect test level is 0, no card inserted.
 * - 1 - Card detect test level is 1, card inserted.
 */
/*@{*/
#define BP_SDHC_PROCTL_CDTL  (6U)          /*!< Bit position for SDHC_PROCTL_CDTL. */
#define BM_SDHC_PROCTL_CDTL  (0x00000040U) /*!< Bit mask for SDHC_PROCTL_CDTL. */
#define BS_SDHC_PROCTL_CDTL  (1U)          /*!< Bit field size in bits for SDHC_PROCTL_CDTL. */

/*! @brief Read current value of the SDHC_PROCTL_CDTL field. */
#define BR_SDHC_PROCTL_CDTL(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_CDTL))

/*! @brief Format value for bitfield SDHC_PROCTL_CDTL. */
#define BF_SDHC_PROCTL_CDTL(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_CDTL) & BM_SDHC_PROCTL_CDTL)

/*! @brief Set the CDTL field to a new value. */
#define BW_SDHC_PROCTL_CDTL(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_CDTL) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field CDSS[7] (RW)
 *
 * Selects the source for the card detection.
 *
 * Values:
 * - 0 - Card detection level is selected for normal purpose.
 * - 1 - Card detection test level is selected for test purpose.
 */
/*@{*/
#define BP_SDHC_PROCTL_CDSS  (7U)          /*!< Bit position for SDHC_PROCTL_CDSS. */
#define BM_SDHC_PROCTL_CDSS  (0x00000080U) /*!< Bit mask for SDHC_PROCTL_CDSS. */
#define BS_SDHC_PROCTL_CDSS  (1U)          /*!< Bit field size in bits for SDHC_PROCTL_CDSS. */

/*! @brief Read current value of the SDHC_PROCTL_CDSS field. */
#define BR_SDHC_PROCTL_CDSS(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_CDSS))

/*! @brief Format value for bitfield SDHC_PROCTL_CDSS. */
#define BF_SDHC_PROCTL_CDSS(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_CDSS) & BM_SDHC_PROCTL_CDSS)

/*! @brief Set the CDSS field to a new value. */
#define BW_SDHC_PROCTL_CDSS(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_CDSS) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field DMAS[9:8] (RW)
 *
 * This field is valid while DMA (SDMA or ADMA) is enabled and selects the DMA
 * operation.
 *
 * Values:
 * - 00 - No DMA or simple DMA is selected.
 * - 01 - ADMA1 is selected.
 * - 10 - ADMA2 is selected.
 * - 11 - Reserved
 */
/*@{*/
#define BP_SDHC_PROCTL_DMAS  (8U)          /*!< Bit position for SDHC_PROCTL_DMAS. */
#define BM_SDHC_PROCTL_DMAS  (0x00000300U) /*!< Bit mask for SDHC_PROCTL_DMAS. */
#define BS_SDHC_PROCTL_DMAS  (2U)          /*!< Bit field size in bits for SDHC_PROCTL_DMAS. */

/*! @brief Read current value of the SDHC_PROCTL_DMAS field. */
#define BR_SDHC_PROCTL_DMAS(x) (HW_SDHC_PROCTL(x).B.DMAS)

/*! @brief Format value for bitfield SDHC_PROCTL_DMAS. */
#define BF_SDHC_PROCTL_DMAS(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_DMAS) & BM_SDHC_PROCTL_DMAS)

/*! @brief Set the DMAS field to a new value. */
#define BW_SDHC_PROCTL_DMAS(x, v) (HW_SDHC_PROCTL_WR(x, (HW_SDHC_PROCTL_RD(x) & ~BM_SDHC_PROCTL_DMAS) | BF_SDHC_PROCTL_DMAS(v)))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field SABGREQ[16] (RW)
 *
 * Used to stop executing a transaction at the next block gap for both DMA and
 * non-DMA transfers. Until the IRQSTATEN[TCSEN] is set to 1, indicating a
 * transfer completion, the host driver shall leave this bit set to 1. Clearing both
 * PROCTL[SABGREQ] and PROCTL[CREQ] does not cause the transaction to restart. Read
 * Wait is used to stop the read transaction at the block gap. The SDHC will
 * honor the PROCTL[SABGREQ] for write transfers, but for read transfers it requires
 * that SDIO card support read wait. Therefore, the host driver shall not set
 * this bit during read transfers unless the SDIO card supports read wait and has
 * set PROCTL[RWCTL] to 1, otherwise the SDHC will stop the SD bus clock to pause
 * the read operation during block gap. In the case of write transfers in which
 * the host driver writes data to the data port register, the host driver shall set
 * this bit after all block data is written. If this bit is set to 1, the host
 * driver shall not write data to the Data Port register after a block is sent.
 * Once this bit is set, the host driver shall not clear this bit before
 * IRQSTATEN[TCSEN] is set, otherwise the SDHC's behavior is undefined. This bit effects
 * PRSSTAT[RTA], PRSSTAT[WTA], and PRSSTAT[CDIHB].
 *
 * Values:
 * - 0 - Transfer
 * - 1 - Stop
 */
/*@{*/
#define BP_SDHC_PROCTL_SABGREQ (16U)       /*!< Bit position for SDHC_PROCTL_SABGREQ. */
#define BM_SDHC_PROCTL_SABGREQ (0x00010000U) /*!< Bit mask for SDHC_PROCTL_SABGREQ. */
#define BS_SDHC_PROCTL_SABGREQ (1U)        /*!< Bit field size in bits for SDHC_PROCTL_SABGREQ. */

/*! @brief Read current value of the SDHC_PROCTL_SABGREQ field. */
#define BR_SDHC_PROCTL_SABGREQ(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_SABGREQ))

/*! @brief Format value for bitfield SDHC_PROCTL_SABGREQ. */
#define BF_SDHC_PROCTL_SABGREQ(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_SABGREQ) & BM_SDHC_PROCTL_SABGREQ)

/*! @brief Set the SABGREQ field to a new value. */
#define BW_SDHC_PROCTL_SABGREQ(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_SABGREQ) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field CREQ[17] (RW)
 *
 * Used to restart a transaction which was stopped using the PROCTL[SABGREQ].
 * When a suspend operation is not accepted by the card, it is also by setting this
 * bit to restart the paused transfer. To cancel stop at the block gap, set
 * PROCTL[SABGREQ] to 0 and set this bit to 1 to restart the transfer. The SDHC
 * automatically clears this bit, therefore it is not necessary for the host driver to
 * set this bit to 0. If both PROCTL[SABGREQ] and this bit are 1, the continue
 * request is ignored.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Restart
 */
/*@{*/
#define BP_SDHC_PROCTL_CREQ  (17U)         /*!< Bit position for SDHC_PROCTL_CREQ. */
#define BM_SDHC_PROCTL_CREQ  (0x00020000U) /*!< Bit mask for SDHC_PROCTL_CREQ. */
#define BS_SDHC_PROCTL_CREQ  (1U)          /*!< Bit field size in bits for SDHC_PROCTL_CREQ. */

/*! @brief Read current value of the SDHC_PROCTL_CREQ field. */
#define BR_SDHC_PROCTL_CREQ(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_CREQ))

/*! @brief Format value for bitfield SDHC_PROCTL_CREQ. */
#define BF_SDHC_PROCTL_CREQ(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_CREQ) & BM_SDHC_PROCTL_CREQ)

/*! @brief Set the CREQ field to a new value. */
#define BW_SDHC_PROCTL_CREQ(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_CREQ) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field RWCTL[18] (RW)
 *
 * The read wait function is optional for SDIO cards. If the card supports read
 * wait, set this bit to enable use of the read wait protocol to stop read data
 * using the DAT[2] line. Otherwise, the SDHC has to stop the SD Clock to hold
 * read data, which restricts commands generation. When the host driver detects an
 * SDIO card insertion, it shall set this bit according to the CCCR of the card.
 * If the card does not support read wait, this bit shall never be set to 1,
 * otherwise DAT line conflicts may occur. If this bit is set to 0, stop at block gap
 * during read operation is also supported, but the SDHC will stop the SD Clock
 * to pause reading operation.
 *
 * Values:
 * - 0 - Disable read wait control, and stop SD clock at block gap when SABGREQ
 *     is set.
 * - 1 - Enable read wait control, and assert read wait without stopping SD
 *     clock at block gap when SABGREQ bit is set.
 */
/*@{*/
#define BP_SDHC_PROCTL_RWCTL (18U)         /*!< Bit position for SDHC_PROCTL_RWCTL. */
#define BM_SDHC_PROCTL_RWCTL (0x00040000U) /*!< Bit mask for SDHC_PROCTL_RWCTL. */
#define BS_SDHC_PROCTL_RWCTL (1U)          /*!< Bit field size in bits for SDHC_PROCTL_RWCTL. */

/*! @brief Read current value of the SDHC_PROCTL_RWCTL field. */
#define BR_SDHC_PROCTL_RWCTL(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_RWCTL))

/*! @brief Format value for bitfield SDHC_PROCTL_RWCTL. */
#define BF_SDHC_PROCTL_RWCTL(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_RWCTL) & BM_SDHC_PROCTL_RWCTL)

/*! @brief Set the RWCTL field to a new value. */
#define BW_SDHC_PROCTL_RWCTL(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_RWCTL) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field IABG[19] (RW)
 *
 * Valid only in 4-bit mode, of the SDIO card, and selects a sample point in the
 * interrupt cycle. Setting to 1 enables interrupt detection at the block gap
 * for a multiple block transfer. Setting to 0 disables interrupt detection during
 * a multiple block transfer. If the SDIO card can't signal an interrupt during a
 * multiple block transfer, this bit must be set to 0 to avoid an inadvertent
 * interrupt. When the host driver detects an SDIO card insertion, it shall set
 * this bit according to the CCCR of the card.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_PROCTL_IABG  (19U)         /*!< Bit position for SDHC_PROCTL_IABG. */
#define BM_SDHC_PROCTL_IABG  (0x00080000U) /*!< Bit mask for SDHC_PROCTL_IABG. */
#define BS_SDHC_PROCTL_IABG  (1U)          /*!< Bit field size in bits for SDHC_PROCTL_IABG. */

/*! @brief Read current value of the SDHC_PROCTL_IABG field. */
#define BR_SDHC_PROCTL_IABG(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_IABG))

/*! @brief Format value for bitfield SDHC_PROCTL_IABG. */
#define BF_SDHC_PROCTL_IABG(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_IABG) & BM_SDHC_PROCTL_IABG)

/*! @brief Set the IABG field to a new value. */
#define BW_SDHC_PROCTL_IABG(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_IABG) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field WECINT[24] (RW)
 *
 * Enables a wakeup event, via IRQSTAT[CINT]. This bit can be set to 1 if FN_WUS
 * (Wake Up Support) in CIS is set to 1. When this bit is set, the card
 * interrupt status and the SDHC interrupt can be asserted without SD_CLK toggling. When
 * the wakeup feature is not enabled, the SD_CLK must be active to assert the
 * card interrupt status and the SDHC interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_PROCTL_WECINT (24U)        /*!< Bit position for SDHC_PROCTL_WECINT. */
#define BM_SDHC_PROCTL_WECINT (0x01000000U) /*!< Bit mask for SDHC_PROCTL_WECINT. */
#define BS_SDHC_PROCTL_WECINT (1U)         /*!< Bit field size in bits for SDHC_PROCTL_WECINT. */

/*! @brief Read current value of the SDHC_PROCTL_WECINT field. */
#define BR_SDHC_PROCTL_WECINT(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_WECINT))

/*! @brief Format value for bitfield SDHC_PROCTL_WECINT. */
#define BF_SDHC_PROCTL_WECINT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_WECINT) & BM_SDHC_PROCTL_WECINT)

/*! @brief Set the WECINT field to a new value. */
#define BW_SDHC_PROCTL_WECINT(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_WECINT) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field WECINS[25] (RW)
 *
 * Enables a wakeup event, via IRQSTAT[CINS]. FN_WUS (Wake Up Support) in CIS
 * does not effect this bit. When this bit is set, IRQSTATEN[CINSEN] and the SDHC
 * interrupt can be asserted without SD_CLK toggling. When the wakeup feature is
 * not enabled, the SD_CLK must be active to assert IRQSTATEN[CINSEN] and the SDHC
 * interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_PROCTL_WECINS (25U)        /*!< Bit position for SDHC_PROCTL_WECINS. */
#define BM_SDHC_PROCTL_WECINS (0x02000000U) /*!< Bit mask for SDHC_PROCTL_WECINS. */
#define BS_SDHC_PROCTL_WECINS (1U)         /*!< Bit field size in bits for SDHC_PROCTL_WECINS. */

/*! @brief Read current value of the SDHC_PROCTL_WECINS field. */
#define BR_SDHC_PROCTL_WECINS(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_WECINS))

/*! @brief Format value for bitfield SDHC_PROCTL_WECINS. */
#define BF_SDHC_PROCTL_WECINS(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_WECINS) & BM_SDHC_PROCTL_WECINS)

/*! @brief Set the WECINS field to a new value. */
#define BW_SDHC_PROCTL_WECINS(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_WECINS) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field WECRM[26] (RW)
 *
 * Enables a wakeup event, via IRQSTAT[CRM]. FN_WUS (Wake Up Support) in CIS
 * does not effect this bit. When this bit is set, IRQSTAT[CRM] and the SDHC
 * interrupt can be asserted without SD_CLK toggling. When the wakeup feature is not
 * enabled, the SD_CLK must be active to assert IRQSTAT[CRM] and the SDHC interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_PROCTL_WECRM (26U)         /*!< Bit position for SDHC_PROCTL_WECRM. */
#define BM_SDHC_PROCTL_WECRM (0x04000000U) /*!< Bit mask for SDHC_PROCTL_WECRM. */
#define BS_SDHC_PROCTL_WECRM (1U)          /*!< Bit field size in bits for SDHC_PROCTL_WECRM. */

/*! @brief Read current value of the SDHC_PROCTL_WECRM field. */
#define BR_SDHC_PROCTL_WECRM(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_WECRM))

/*! @brief Format value for bitfield SDHC_PROCTL_WECRM. */
#define BF_SDHC_PROCTL_WECRM(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_WECRM) & BM_SDHC_PROCTL_WECRM)

/*! @brief Set the WECRM field to a new value. */
#define BW_SDHC_PROCTL_WECRM(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_WECRM) = (v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_SYSCTL - System Control register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_SYSCTL - System Control register (RW)
 *
 * Reset value: 0x00008008U
 */
typedef union _hw_sdhc_sysctl
{
    uint32_t U;
    struct _hw_sdhc_sysctl_bitfields
    {
        uint32_t IPGEN : 1;            /*!< [0] IPG Clock Enable */
        uint32_t HCKEN : 1;            /*!< [1] System Clock Enable */
        uint32_t PEREN : 1;            /*!< [2] Peripheral Clock Enable */
        uint32_t SDCLKEN : 1;          /*!< [3] SD Clock Enable */
        uint32_t DVS : 4;              /*!< [7:4] Divisor */
        uint32_t SDCLKFS : 8;          /*!< [15:8] SDCLK Frequency Select */
        uint32_t DTOCV : 4;            /*!< [19:16] Data Timeout Counter Value */
        uint32_t RESERVED0 : 4;        /*!< [23:20]  */
        uint32_t RSTA : 1;             /*!< [24] Software Reset For ALL */
        uint32_t RSTC : 1;             /*!< [25] Software Reset For CMD Line */
        uint32_t RSTD : 1;             /*!< [26] Software Reset For DAT Line */
        uint32_t INITA : 1;            /*!< [27] Initialization Active */
        uint32_t RESERVED1 : 4;        /*!< [31:28]  */
    } B;
} hw_sdhc_sysctl_t;

/*!
 * @name Constants and macros for entire SDHC_SYSCTL register
 */
/*@{*/
#define HW_SDHC_SYSCTL_ADDR(x)   ((x) + 0x2CU)

#define HW_SDHC_SYSCTL(x)        (*(__IO hw_sdhc_sysctl_t *) HW_SDHC_SYSCTL_ADDR(x))
#define HW_SDHC_SYSCTL_RD(x)     (HW_SDHC_SYSCTL(x).U)
#define HW_SDHC_SYSCTL_WR(x, v)  (HW_SDHC_SYSCTL(x).U = (v))
#define HW_SDHC_SYSCTL_SET(x, v) (HW_SDHC_SYSCTL_WR(x, HW_SDHC_SYSCTL_RD(x) |  (v)))
#define HW_SDHC_SYSCTL_CLR(x, v) (HW_SDHC_SYSCTL_WR(x, HW_SDHC_SYSCTL_RD(x) & ~(v)))
#define HW_SDHC_SYSCTL_TOG(x, v) (HW_SDHC_SYSCTL_WR(x, HW_SDHC_SYSCTL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_SYSCTL bitfields
 */

/*!
 * @name Register SDHC_SYSCTL, field IPGEN[0] (RW)
 *
 * If this bit is set, bus clock will always be active and no automatic gating
 * is applied. The bus clock will be internally gated off, if none of the
 * following factors are met: The cmd part is reset, or Data part is reset, or Soft
 * reset, or The cmd is about to send, or Clock divisor is just updated, or Continue
 * request is just set, or This bit is set, or Card insertion is detected, or Card
 * removal is detected, or Card external interrupt is detected, or The SDHC
 * clock is not gated off The bus clock will not be auto gated off if the SDHC clock
 * is not gated off. So clearing only this bit has no effect unless the PEREN bit
 * is also cleared.
 *
 * Values:
 * - 0 - Bus clock will be internally gated off.
 * - 1 - Bus clock will not be automatically gated off.
 */
/*@{*/
#define BP_SDHC_SYSCTL_IPGEN (0U)          /*!< Bit position for SDHC_SYSCTL_IPGEN. */
#define BM_SDHC_SYSCTL_IPGEN (0x00000001U) /*!< Bit mask for SDHC_SYSCTL_IPGEN. */
#define BS_SDHC_SYSCTL_IPGEN (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_IPGEN. */

/*! @brief Read current value of the SDHC_SYSCTL_IPGEN field. */
#define BR_SDHC_SYSCTL_IPGEN(x) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_IPGEN))

/*! @brief Format value for bitfield SDHC_SYSCTL_IPGEN. */
#define BF_SDHC_SYSCTL_IPGEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_IPGEN) & BM_SDHC_SYSCTL_IPGEN)

/*! @brief Set the IPGEN field to a new value. */
#define BW_SDHC_SYSCTL_IPGEN(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_IPGEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field HCKEN[1] (RW)
 *
 * If this bit is set, system clock will always be active and no automatic
 * gating is applied. When this bit is cleared, system clock will be automatically off
 * when no data transfer is on the SD bus.
 *
 * Values:
 * - 0 - System clock will be internally gated off.
 * - 1 - System clock will not be automatically gated off.
 */
/*@{*/
#define BP_SDHC_SYSCTL_HCKEN (1U)          /*!< Bit position for SDHC_SYSCTL_HCKEN. */
#define BM_SDHC_SYSCTL_HCKEN (0x00000002U) /*!< Bit mask for SDHC_SYSCTL_HCKEN. */
#define BS_SDHC_SYSCTL_HCKEN (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_HCKEN. */

/*! @brief Read current value of the SDHC_SYSCTL_HCKEN field. */
#define BR_SDHC_SYSCTL_HCKEN(x) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_HCKEN))

/*! @brief Format value for bitfield SDHC_SYSCTL_HCKEN. */
#define BF_SDHC_SYSCTL_HCKEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_HCKEN) & BM_SDHC_SYSCTL_HCKEN)

/*! @brief Set the HCKEN field to a new value. */
#define BW_SDHC_SYSCTL_HCKEN(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_HCKEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field PEREN[2] (RW)
 *
 * If this bit is set, SDHC clock will always be active and no automatic gating
 * is applied. Thus the SDCLK is active except for when auto gating-off during
 * buffer danger (buffer about to over-run or under-run). When this bit is cleared,
 * the SDHC clock will be automatically off whenever there is no transaction on
 * the SD bus. Because this bit is only a feature enabling bit, clearing this bit
 * does not stop SDCLK immediately. The SDHC clock will be internally gated off,
 * if none of the following factors are met: The cmd part is reset, or Data part
 * is reset, or A soft reset, or The cmd is about to send, or Clock divisor is
 * just updated, or Continue request is just set, or This bit is set, or Card
 * insertion is detected, or Card removal is detected, or Card external interrupt is
 * detected, or 80 clocks for initialization phase is ongoing
 *
 * Values:
 * - 0 - SDHC clock will be internally gated off.
 * - 1 - SDHC clock will not be automatically gated off.
 */
/*@{*/
#define BP_SDHC_SYSCTL_PEREN (2U)          /*!< Bit position for SDHC_SYSCTL_PEREN. */
#define BM_SDHC_SYSCTL_PEREN (0x00000004U) /*!< Bit mask for SDHC_SYSCTL_PEREN. */
#define BS_SDHC_SYSCTL_PEREN (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_PEREN. */

/*! @brief Read current value of the SDHC_SYSCTL_PEREN field. */
#define BR_SDHC_SYSCTL_PEREN(x) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_PEREN))

/*! @brief Format value for bitfield SDHC_SYSCTL_PEREN. */
#define BF_SDHC_SYSCTL_PEREN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_PEREN) & BM_SDHC_SYSCTL_PEREN)

/*! @brief Set the PEREN field to a new value. */
#define BW_SDHC_SYSCTL_PEREN(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_PEREN) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field SDCLKEN[3] (RW)
 *
 * The host controller shall stop SDCLK when writing this bit to 0. SDCLK
 * frequency can be changed when this bit is 0. Then, the host controller shall
 * maintain the same clock frequency until SDCLK is stopped (stop at SDCLK = 0). If the
 * IRQSTAT[CINS] is cleared, this bit must be cleared by the host driver to save
 * power.
 */
/*@{*/
#define BP_SDHC_SYSCTL_SDCLKEN (3U)        /*!< Bit position for SDHC_SYSCTL_SDCLKEN. */
#define BM_SDHC_SYSCTL_SDCLKEN (0x00000008U) /*!< Bit mask for SDHC_SYSCTL_SDCLKEN. */
#define BS_SDHC_SYSCTL_SDCLKEN (1U)        /*!< Bit field size in bits for SDHC_SYSCTL_SDCLKEN. */

/*! @brief Read current value of the SDHC_SYSCTL_SDCLKEN field. */
#define BR_SDHC_SYSCTL_SDCLKEN(x) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_SDCLKEN))

/*! @brief Format value for bitfield SDHC_SYSCTL_SDCLKEN. */
#define BF_SDHC_SYSCTL_SDCLKEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_SDCLKEN) & BM_SDHC_SYSCTL_SDCLKEN)

/*! @brief Set the SDCLKEN field to a new value. */
#define BW_SDHC_SYSCTL_SDCLKEN(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_SDCLKEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field DVS[7:4] (RW)
 *
 * Used to provide a more exact divisor to generate the desired SD clock
 * frequency. Note the divider can even support odd divisor without deterioration of
 * duty cycle. The setting are as following:
 *
 * Values:
 * - 0 - Divisor by 1.
 * - 1 - Divisor by 2.
 * - 1110 - Divisor by 15.
 * - 1111 - Divisor by 16.
 */
/*@{*/
#define BP_SDHC_SYSCTL_DVS   (4U)          /*!< Bit position for SDHC_SYSCTL_DVS. */
#define BM_SDHC_SYSCTL_DVS   (0x000000F0U) /*!< Bit mask for SDHC_SYSCTL_DVS. */
#define BS_SDHC_SYSCTL_DVS   (4U)          /*!< Bit field size in bits for SDHC_SYSCTL_DVS. */

/*! @brief Read current value of the SDHC_SYSCTL_DVS field. */
#define BR_SDHC_SYSCTL_DVS(x) (HW_SDHC_SYSCTL(x).B.DVS)

/*! @brief Format value for bitfield SDHC_SYSCTL_DVS. */
#define BF_SDHC_SYSCTL_DVS(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_DVS) & BM_SDHC_SYSCTL_DVS)

/*! @brief Set the DVS field to a new value. */
#define BW_SDHC_SYSCTL_DVS(x, v) (HW_SDHC_SYSCTL_WR(x, (HW_SDHC_SYSCTL_RD(x) & ~BM_SDHC_SYSCTL_DVS) | BF_SDHC_SYSCTL_DVS(v)))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field SDCLKFS[15:8] (RW)
 *
 * Used to select the frequency of the SDCLK pin. The frequency is not
 * programmed directly. Rather this register holds the prescaler (this register) and
 * divisor (next register) of the base clock frequency register. Setting 00h bypasses
 * the frequency prescaler of the SD Clock. Multiple bits must not be set, or the
 * behavior of this prescaler is undefined. The two default divider values can
 * be calculated by the frequency of SDHC clock and the following divisor bits.
 * The frequency of SDCLK is set by the following formula: Clock frequency = (Base
 * clock) / (prescaler x divisor) For example, if the base clock frequency is 96
 * MHz, and the target frequency is 25 MHz, then choosing the prescaler value of
 * 01h and divisor value of 1h will yield 24 MHz, which is the nearest frequency
 * less than or equal to the target. Similarly, to approach a clock value of 400
 * kHz, the prescaler value of 08h and divisor value of eh yields the exact clock
 * value of 400 kHz. The reset value of this field is 80h, so if the input base
 * clock ( SDHC clock ) is about 96 MHz, the default SD clock after reset is 375
 * kHz. According to the SD Physical Specification Version 1.1 and the SDIO Card
 * Specification Version 1.2, the maximum SD clock frequency is 50 MHz and shall
 * never exceed this limit. Only the following settings are allowed:
 *
 * Values:
 * - 1 - Base clock divided by 2.
 * - 10 - Base clock divided by 4.
 * - 100 - Base clock divided by 8.
 * - 1000 - Base clock divided by 16.
 * - 10000 - Base clock divided by 32.
 * - 100000 - Base clock divided by 64.
 * - 1000000 - Base clock divided by 128.
 * - 10000000 - Base clock divided by 256.
 */
/*@{*/
#define BP_SDHC_SYSCTL_SDCLKFS (8U)        /*!< Bit position for SDHC_SYSCTL_SDCLKFS. */
#define BM_SDHC_SYSCTL_SDCLKFS (0x0000FF00U) /*!< Bit mask for SDHC_SYSCTL_SDCLKFS. */
#define BS_SDHC_SYSCTL_SDCLKFS (8U)        /*!< Bit field size in bits for SDHC_SYSCTL_SDCLKFS. */

/*! @brief Read current value of the SDHC_SYSCTL_SDCLKFS field. */
#define BR_SDHC_SYSCTL_SDCLKFS(x) (HW_SDHC_SYSCTL(x).B.SDCLKFS)

/*! @brief Format value for bitfield SDHC_SYSCTL_SDCLKFS. */
#define BF_SDHC_SYSCTL_SDCLKFS(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_SDCLKFS) & BM_SDHC_SYSCTL_SDCLKFS)

/*! @brief Set the SDCLKFS field to a new value. */
#define BW_SDHC_SYSCTL_SDCLKFS(x, v) (HW_SDHC_SYSCTL_WR(x, (HW_SDHC_SYSCTL_RD(x) & ~BM_SDHC_SYSCTL_SDCLKFS) | BF_SDHC_SYSCTL_SDCLKFS(v)))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field DTOCV[19:16] (RW)
 *
 * Determines the interval by which DAT line timeouts are detected. See
 * IRQSTAT[DTOE] for information on factors that dictate time-out generation. Time-out
 * clock frequency will be generated by dividing the base clock SDCLK value by this
 * value. The host driver can clear IRQSTATEN[DTOESEN] to prevent inadvertent
 * time-out events.
 *
 * Values:
 * - 0000 - SDCLK x 2 13
 * - 0001 - SDCLK x 2 14
 * - 1110 - SDCLK x 2 27
 * - 1111 - Reserved
 */
/*@{*/
#define BP_SDHC_SYSCTL_DTOCV (16U)         /*!< Bit position for SDHC_SYSCTL_DTOCV. */
#define BM_SDHC_SYSCTL_DTOCV (0x000F0000U) /*!< Bit mask for SDHC_SYSCTL_DTOCV. */
#define BS_SDHC_SYSCTL_DTOCV (4U)          /*!< Bit field size in bits for SDHC_SYSCTL_DTOCV. */

/*! @brief Read current value of the SDHC_SYSCTL_DTOCV field. */
#define BR_SDHC_SYSCTL_DTOCV(x) (HW_SDHC_SYSCTL(x).B.DTOCV)

/*! @brief Format value for bitfield SDHC_SYSCTL_DTOCV. */
#define BF_SDHC_SYSCTL_DTOCV(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_DTOCV) & BM_SDHC_SYSCTL_DTOCV)

/*! @brief Set the DTOCV field to a new value. */
#define BW_SDHC_SYSCTL_DTOCV(x, v) (HW_SDHC_SYSCTL_WR(x, (HW_SDHC_SYSCTL_RD(x) & ~BM_SDHC_SYSCTL_DTOCV) | BF_SDHC_SYSCTL_DTOCV(v)))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field RSTA[24] (WORZ)
 *
 * Effects the entire host controller except for the card detection circuit.
 * Register bits of type ROC, RW, RW1C, RWAC are cleared. During its initialization,
 * the host driver shall set this bit to 1 to reset the SDHC. The SDHC shall
 * reset this bit to 0 when the capabilities registers are valid and the host driver
 * can read them. Additional use of software reset for all does not affect the
 * value of the capabilities registers. After this bit is set, it is recommended
 * that the host driver reset the external card and reinitialize it.
 *
 * Values:
 * - 0 - No reset.
 * - 1 - Reset.
 */
/*@{*/
#define BP_SDHC_SYSCTL_RSTA  (24U)         /*!< Bit position for SDHC_SYSCTL_RSTA. */
#define BM_SDHC_SYSCTL_RSTA  (0x01000000U) /*!< Bit mask for SDHC_SYSCTL_RSTA. */
#define BS_SDHC_SYSCTL_RSTA  (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_RSTA. */

/*! @brief Format value for bitfield SDHC_SYSCTL_RSTA. */
#define BF_SDHC_SYSCTL_RSTA(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_RSTA) & BM_SDHC_SYSCTL_RSTA)

/*! @brief Set the RSTA field to a new value. */
#define BW_SDHC_SYSCTL_RSTA(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_RSTA) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field RSTC[25] (WORZ)
 *
 * Only part of the command circuit is reset. The following registers and bits
 * are cleared by this bit: PRSSTAT[CIHB] IRQSTAT[CC]
 *
 * Values:
 * - 0 - No reset.
 * - 1 - Reset.
 */
/*@{*/
#define BP_SDHC_SYSCTL_RSTC  (25U)         /*!< Bit position for SDHC_SYSCTL_RSTC. */
#define BM_SDHC_SYSCTL_RSTC  (0x02000000U) /*!< Bit mask for SDHC_SYSCTL_RSTC. */
#define BS_SDHC_SYSCTL_RSTC  (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_RSTC. */

/*! @brief Format value for bitfield SDHC_SYSCTL_RSTC. */
#define BF_SDHC_SYSCTL_RSTC(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_RSTC) & BM_SDHC_SYSCTL_RSTC)

/*! @brief Set the RSTC field to a new value. */
#define BW_SDHC_SYSCTL_RSTC(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_RSTC) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field RSTD[26] (WORZ)
 *
 * Only part of the data circuit is reset. DMA circuit is also reset. The
 * following registers and bits are cleared by this bit: Data Port register Buffer Is
 * Cleared And Initialized.Present State register Buffer Read Enable Buffer Write
 * Enable Read Transfer Active Write Transfer Active DAT Line Active Command
 * Inhibit (DAT) Protocol Control register Continue Request Stop At Block Gap Request
 * Interrupt Status register Buffer Read Ready Buffer Write Ready DMA Interrupt
 * Block Gap Event Transfer Complete
 *
 * Values:
 * - 0 - No reset.
 * - 1 - Reset.
 */
/*@{*/
#define BP_SDHC_SYSCTL_RSTD  (26U)         /*!< Bit position for SDHC_SYSCTL_RSTD. */
#define BM_SDHC_SYSCTL_RSTD  (0x04000000U) /*!< Bit mask for SDHC_SYSCTL_RSTD. */
#define BS_SDHC_SYSCTL_RSTD  (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_RSTD. */

/*! @brief Format value for bitfield SDHC_SYSCTL_RSTD. */
#define BF_SDHC_SYSCTL_RSTD(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_RSTD) & BM_SDHC_SYSCTL_RSTD)

/*! @brief Set the RSTD field to a new value. */
#define BW_SDHC_SYSCTL_RSTD(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_RSTD) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field INITA[27] (RW)
 *
 * When this bit is set, 80 SD-clocks are sent to the card. After the 80 clocks
 * are sent, this bit is self-cleared. This bit is very useful during the card
 * power-up period when 74 SD-clocks are needed and the clock auto gating feature
 * is enabled. Writing 1 to this bit when this bit is already 1 has no effect.
 * Writing 0 to this bit at any time has no effect. When either of the PRSSTAT[CIHB]
 * and PRSSTAT[CDIHB] bits are set, writing 1 to this bit is ignored, that is,
 * when command line or data lines are active, write to this bit is not allowed.
 * On the otherhand, when this bit is set, that is, during intialization active
 * period, it is allowed to issue command, and the command bit stream will appear
 * on the CMD pad after all 80 clock cycles are done. So when this command ends,
 * the driver can make sure the 80 clock cycles are sent out. This is very useful
 * when the driver needs send 80 cycles to the card and does not want to wait
 * till this bit is self-cleared.
 */
/*@{*/
#define BP_SDHC_SYSCTL_INITA (27U)         /*!< Bit position for SDHC_SYSCTL_INITA. */
#define BM_SDHC_SYSCTL_INITA (0x08000000U) /*!< Bit mask for SDHC_SYSCTL_INITA. */
#define BS_SDHC_SYSCTL_INITA (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_INITA. */

/*! @brief Read current value of the SDHC_SYSCTL_INITA field. */
#define BR_SDHC_SYSCTL_INITA(x) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_INITA))

/*! @brief Format value for bitfield SDHC_SYSCTL_INITA. */
#define BF_SDHC_SYSCTL_INITA(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_INITA) & BM_SDHC_SYSCTL_INITA)

/*! @brief Set the INITA field to a new value. */
#define BW_SDHC_SYSCTL_INITA(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_INITA) = (v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_IRQSTAT - Interrupt Status register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_IRQSTAT - Interrupt Status register (RW)
 *
 * Reset value: 0x00000000U
 *
 * An interrupt is generated when the Normal Interrupt Signal Enable is enabled
 * and at least one of the status bits is set to 1. For all bits, writing 1 to a
 * bit clears it; writing to 0 keeps the bit unchanged. More than one status can
 * be cleared with a single register write. For Card Interrupt, before writing 1
 * to clear, it is required that the card stops asserting the interrupt, meaning
 * that when the Card Driver services the interrupt condition, otherwise the CINT
 * bit will be asserted again. The table below shows the relationship between
 * the CTOE and the CC bits. SDHC status for CTOE/CC bit combinations Command
 * complete Command timeout error Meaning of the status 0 0 X X 1 Response not
 * received within 64 SDCLK cycles 1 0 Response received The table below shows the
 * relationship between the Transfer Complete and the Data Timeout Error. SDHC status
 * for data timeout error/transfer complete bit combinations Transfer complete
 * Data timeout error Meaning of the status 0 0 X 0 1 Timeout occurred during
 * transfer 1 X Data transfer complete The table below shows the relationship between
 * the command CRC Error (CCE) and Command Timeout Error (CTOE). SDHC status for
 * CCE/CTOE Bit Combinations Command complete Command timeout error Meaning of
 * the status 0 0 No error 0 1 Response timeout error 1 0 Response CRC error 1 1
 * CMD line conflict
 */
typedef union _hw_sdhc_irqstat
{
    uint32_t U;
    struct _hw_sdhc_irqstat_bitfields
    {
        uint32_t CC : 1;               /*!< [0] Command Complete */
        uint32_t TC : 1;               /*!< [1] Transfer Complete */
        uint32_t BGE : 1;              /*!< [2] Block Gap Event */
        uint32_t DINT : 1;             /*!< [3] DMA Interrupt */
        uint32_t BWR : 1;              /*!< [4] Buffer Write Ready */
        uint32_t BRR : 1;              /*!< [5] Buffer Read Ready */
        uint32_t CINS : 1;             /*!< [6] Card Insertion */
        uint32_t CRM : 1;              /*!< [7] Card Removal */
        uint32_t CINT : 1;             /*!< [8] Card Interrupt */
        uint32_t RESERVED0 : 7;        /*!< [15:9]  */
        uint32_t CTOE : 1;             /*!< [16] Command Timeout Error */
        uint32_t CCE : 1;              /*!< [17] Command CRC Error */
        uint32_t CEBE : 1;             /*!< [18] Command End Bit Error */
        uint32_t CIE : 1;              /*!< [19] Command Index Error */
        uint32_t DTOE : 1;             /*!< [20] Data Timeout Error */
        uint32_t DCE : 1;              /*!< [21] Data CRC Error */
        uint32_t DEBE : 1;             /*!< [22] Data End Bit Error */
        uint32_t RESERVED1 : 1;        /*!< [23]  */
        uint32_t AC12E : 1;            /*!< [24] Auto CMD12 Error */
        uint32_t RESERVED2 : 3;        /*!< [27:25]  */
        uint32_t DMAE : 1;             /*!< [28] DMA Error */
        uint32_t RESERVED3 : 3;        /*!< [31:29]  */
    } B;
} hw_sdhc_irqstat_t;

/*!
 * @name Constants and macros for entire SDHC_IRQSTAT register
 */
/*@{*/
#define HW_SDHC_IRQSTAT_ADDR(x)  ((x) + 0x30U)

#define HW_SDHC_IRQSTAT(x)       (*(__IO hw_sdhc_irqstat_t *) HW_SDHC_IRQSTAT_ADDR(x))
#define HW_SDHC_IRQSTAT_RD(x)    (HW_SDHC_IRQSTAT(x).U)
#define HW_SDHC_IRQSTAT_WR(x, v) (HW_SDHC_IRQSTAT(x).U = (v))
#define HW_SDHC_IRQSTAT_SET(x, v) (HW_SDHC_IRQSTAT_WR(x, HW_SDHC_IRQSTAT_RD(x) |  (v)))
#define HW_SDHC_IRQSTAT_CLR(x, v) (HW_SDHC_IRQSTAT_WR(x, HW_SDHC_IRQSTAT_RD(x) & ~(v)))
#define HW_SDHC_IRQSTAT_TOG(x, v) (HW_SDHC_IRQSTAT_WR(x, HW_SDHC_IRQSTAT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_IRQSTAT bitfields
 */

/*!
 * @name Register SDHC_IRQSTAT, field CC[0] (W1C)
 *
 * This bit is set when you receive the end bit of the command response, except
 * Auto CMD12. See PRSSTAT[CIHB].
 *
 * Values:
 * - 0 - Command not complete.
 * - 1 - Command complete.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CC   (0U)          /*!< Bit position for SDHC_IRQSTAT_CC. */
#define BM_SDHC_IRQSTAT_CC   (0x00000001U) /*!< Bit mask for SDHC_IRQSTAT_CC. */
#define BS_SDHC_IRQSTAT_CC   (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CC. */

/*! @brief Read current value of the SDHC_IRQSTAT_CC field. */
#define BR_SDHC_IRQSTAT_CC(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CC))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CC. */
#define BF_SDHC_IRQSTAT_CC(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CC) & BM_SDHC_IRQSTAT_CC)

/*! @brief Set the CC field to a new value. */
#define BW_SDHC_IRQSTAT_CC(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CC) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field TC[1] (W1C)
 *
 * This bit is set when a read or write transfer is completed. In the case of a
 * read transaction: This bit is set at the falling edge of the read transfer
 * active status. There are two cases in which this interrupt is generated. The
 * first is when a data transfer is completed as specified by the data length, after
 * the last data has been read to the host system. The second is when data has
 * stopped at the block gap and completed the data transfer by setting
 * PROCTL[SABGREQ], after valid data has been read to the host system. In the case of a write
 * transaction: This bit is set at the falling edge of the DAT line active
 * status. There are two cases in which this interrupt is generated. The first is when
 * the last data is written to the SD card as specified by the data length and
 * the busy signal is released. The second is when data transfers are stopped at
 * the block gap, by setting PROCTL[SABGREQ], and the data transfers are
 * completed,after valid data is written to the SD card and the busy signal released.
 *
 * Values:
 * - 0 - Transfer not complete.
 * - 1 - Transfer complete.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_TC   (1U)          /*!< Bit position for SDHC_IRQSTAT_TC. */
#define BM_SDHC_IRQSTAT_TC   (0x00000002U) /*!< Bit mask for SDHC_IRQSTAT_TC. */
#define BS_SDHC_IRQSTAT_TC   (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_TC. */

/*! @brief Read current value of the SDHC_IRQSTAT_TC field. */
#define BR_SDHC_IRQSTAT_TC(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_TC))

/*! @brief Format value for bitfield SDHC_IRQSTAT_TC. */
#define BF_SDHC_IRQSTAT_TC(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_TC) & BM_SDHC_IRQSTAT_TC)

/*! @brief Set the TC field to a new value. */
#define BW_SDHC_IRQSTAT_TC(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_TC) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field BGE[2] (W1C)
 *
 * If PROCTL[SABGREQ] is set, this bit is set when a read or write transaction
 * is stopped at a block gap. If PROCTL[SABGREQ] is not set to 1, this bit is not
 * set to 1. In the case of a read transaction: This bit is set at the falling
 * edge of the DAT line active status, when the transaction is stopped at SD Bus
 * timing. The read wait must be supported in order to use this function. In the
 * case of write transaction: This bit is set at the falling edge of write transfer
 * active status, after getting CRC status at SD bus timing.
 *
 * Values:
 * - 0 - No block gap event.
 * - 1 - Transaction stopped at block gap.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_BGE  (2U)          /*!< Bit position for SDHC_IRQSTAT_BGE. */
#define BM_SDHC_IRQSTAT_BGE  (0x00000004U) /*!< Bit mask for SDHC_IRQSTAT_BGE. */
#define BS_SDHC_IRQSTAT_BGE  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_BGE. */

/*! @brief Read current value of the SDHC_IRQSTAT_BGE field. */
#define BR_SDHC_IRQSTAT_BGE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_BGE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_BGE. */
#define BF_SDHC_IRQSTAT_BGE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_BGE) & BM_SDHC_IRQSTAT_BGE)

/*! @brief Set the BGE field to a new value. */
#define BW_SDHC_IRQSTAT_BGE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_BGE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field DINT[3] (W1C)
 *
 * Occurs only when the internal DMA finishes the data transfer successfully.
 * Whenever errors occur during data transfer, this bit will not be set. Instead,
 * the DMAE bit will be set. Either Simple DMA or ADMA finishes data transferring,
 * this bit will be set.
 *
 * Values:
 * - 0 - No DMA Interrupt.
 * - 1 - DMA Interrupt is generated.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_DINT (3U)          /*!< Bit position for SDHC_IRQSTAT_DINT. */
#define BM_SDHC_IRQSTAT_DINT (0x00000008U) /*!< Bit mask for SDHC_IRQSTAT_DINT. */
#define BS_SDHC_IRQSTAT_DINT (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_DINT. */

/*! @brief Read current value of the SDHC_IRQSTAT_DINT field. */
#define BR_SDHC_IRQSTAT_DINT(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DINT))

/*! @brief Format value for bitfield SDHC_IRQSTAT_DINT. */
#define BF_SDHC_IRQSTAT_DINT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_DINT) & BM_SDHC_IRQSTAT_DINT)

/*! @brief Set the DINT field to a new value. */
#define BW_SDHC_IRQSTAT_DINT(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DINT) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field BWR[4] (W1C)
 *
 * This status bit is set if the Buffer Write Enable bit, in the Present State
 * register, changes from 0 to 1. See the Buffer Write Enable bit in the Present
 * State register for additional information.
 *
 * Values:
 * - 0 - Not ready to write buffer.
 * - 1 - Ready to write buffer.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_BWR  (4U)          /*!< Bit position for SDHC_IRQSTAT_BWR. */
#define BM_SDHC_IRQSTAT_BWR  (0x00000010U) /*!< Bit mask for SDHC_IRQSTAT_BWR. */
#define BS_SDHC_IRQSTAT_BWR  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_BWR. */

/*! @brief Read current value of the SDHC_IRQSTAT_BWR field. */
#define BR_SDHC_IRQSTAT_BWR(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_BWR))

/*! @brief Format value for bitfield SDHC_IRQSTAT_BWR. */
#define BF_SDHC_IRQSTAT_BWR(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_BWR) & BM_SDHC_IRQSTAT_BWR)

/*! @brief Set the BWR field to a new value. */
#define BW_SDHC_IRQSTAT_BWR(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_BWR) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field BRR[5] (W1C)
 *
 * This status bit is set if the Buffer Read Enable bit, in the Present State
 * register, changes from 0 to 1. See the Buffer Read Enable bit in the Present
 * State register for additional information.
 *
 * Values:
 * - 0 - Not ready to read buffer.
 * - 1 - Ready to read buffer.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_BRR  (5U)          /*!< Bit position for SDHC_IRQSTAT_BRR. */
#define BM_SDHC_IRQSTAT_BRR  (0x00000020U) /*!< Bit mask for SDHC_IRQSTAT_BRR. */
#define BS_SDHC_IRQSTAT_BRR  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_BRR. */

/*! @brief Read current value of the SDHC_IRQSTAT_BRR field. */
#define BR_SDHC_IRQSTAT_BRR(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_BRR))

/*! @brief Format value for bitfield SDHC_IRQSTAT_BRR. */
#define BF_SDHC_IRQSTAT_BRR(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_BRR) & BM_SDHC_IRQSTAT_BRR)

/*! @brief Set the BRR field to a new value. */
#define BW_SDHC_IRQSTAT_BRR(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_BRR) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CINS[6] (W1C)
 *
 * This status bit is set if the Card Inserted bit in the Present State register
 * changes from 0 to 1. When the host driver writes this bit to 1 to clear this
 * status, the status of the Card Inserted in the Present State register must be
 * confirmed. Because the card state may possibly be changed when the host driver
 * clears this bit and the interrupt event may not be generated. When this bit
 * is cleared, it will be set again if a card is inserted. To leave it cleared,
 * clear the Card Inserted Status Enable bit in Interrupt Status Enable register.
 *
 * Values:
 * - 0 - Card state unstable or removed.
 * - 1 - Card inserted.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CINS (6U)          /*!< Bit position for SDHC_IRQSTAT_CINS. */
#define BM_SDHC_IRQSTAT_CINS (0x00000040U) /*!< Bit mask for SDHC_IRQSTAT_CINS. */
#define BS_SDHC_IRQSTAT_CINS (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CINS. */

/*! @brief Read current value of the SDHC_IRQSTAT_CINS field. */
#define BR_SDHC_IRQSTAT_CINS(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CINS))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CINS. */
#define BF_SDHC_IRQSTAT_CINS(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CINS) & BM_SDHC_IRQSTAT_CINS)

/*! @brief Set the CINS field to a new value. */
#define BW_SDHC_IRQSTAT_CINS(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CINS) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CRM[7] (W1C)
 *
 * This status bit is set if the Card Inserted bit in the Present State register
 * changes from 1 to 0. When the host driver writes this bit to 1 to clear this
 * status, the status of the Card Inserted in the Present State register must be
 * confirmed. Because the card state may possibly be changed when the host driver
 * clears this bit and the interrupt event may not be generated. When this bit
 * is cleared, it will be set again if no card is inserted. To leave it cleared,
 * clear the Card Removal Status Enable bit in Interrupt Status Enable register.
 *
 * Values:
 * - 0 - Card state unstable or inserted.
 * - 1 - Card removed.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CRM  (7U)          /*!< Bit position for SDHC_IRQSTAT_CRM. */
#define BM_SDHC_IRQSTAT_CRM  (0x00000080U) /*!< Bit mask for SDHC_IRQSTAT_CRM. */
#define BS_SDHC_IRQSTAT_CRM  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CRM. */

/*! @brief Read current value of the SDHC_IRQSTAT_CRM field. */
#define BR_SDHC_IRQSTAT_CRM(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CRM))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CRM. */
#define BF_SDHC_IRQSTAT_CRM(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CRM) & BM_SDHC_IRQSTAT_CRM)

/*! @brief Set the CRM field to a new value. */
#define BW_SDHC_IRQSTAT_CRM(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CRM) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CINT[8] (W1C)
 *
 * This status bit is set when an interrupt signal is detected from the external
 * card. In 1-bit mode, the SDHC will detect the Card Interrupt without the SD
 * Clock to support wakeup. In 4-bit mode, the card interrupt signal is sampled
 * during the interrupt cycle, so the interrupt from card can only be sampled
 * during interrupt cycle, introducing some delay between the interrupt signal from
 * the SDIO card and the interrupt to the host system. Writing this bit to 1 can
 * clear this bit, but as the interrupt factor from the SDIO card does not clear,
 * this bit is set again. To clear this bit, it is required to reset the interrupt
 * factor from the external card followed by a writing 1 to this bit. When this
 * status has been set, and the host driver needs to service this interrupt, the
 * Card Interrupt Signal Enable in the Interrupt Signal Enable register should be
 * 0 to stop driving the interrupt signal to the host system. After completion
 * of the card interrupt service (it must reset the interrupt factors in the SDIO
 * card and the interrupt signal may not be asserted), write 1 to clear this bit,
 * set the Card Interrupt Signal Enable to 1, and start sampling the interrupt
 * signal again.
 *
 * Values:
 * - 0 - No Card Interrupt.
 * - 1 - Generate Card Interrupt.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CINT (8U)          /*!< Bit position for SDHC_IRQSTAT_CINT. */
#define BM_SDHC_IRQSTAT_CINT (0x00000100U) /*!< Bit mask for SDHC_IRQSTAT_CINT. */
#define BS_SDHC_IRQSTAT_CINT (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CINT. */

/*! @brief Read current value of the SDHC_IRQSTAT_CINT field. */
#define BR_SDHC_IRQSTAT_CINT(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CINT))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CINT. */
#define BF_SDHC_IRQSTAT_CINT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CINT) & BM_SDHC_IRQSTAT_CINT)

/*! @brief Set the CINT field to a new value. */
#define BW_SDHC_IRQSTAT_CINT(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CINT) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CTOE[16] (W1C)
 *
 * Occurs only if no response is returned within 64 SDCLK cycles from the end
 * bit of the command. If the SDHC detects a CMD line conflict, in which case a
 * Command CRC Error shall also be set, this bit shall be set without waiting for 64
 * SDCLK cycles. This is because the command will be aborted by the SDHC.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Time out.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CTOE (16U)         /*!< Bit position for SDHC_IRQSTAT_CTOE. */
#define BM_SDHC_IRQSTAT_CTOE (0x00010000U) /*!< Bit mask for SDHC_IRQSTAT_CTOE. */
#define BS_SDHC_IRQSTAT_CTOE (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CTOE. */

/*! @brief Read current value of the SDHC_IRQSTAT_CTOE field. */
#define BR_SDHC_IRQSTAT_CTOE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CTOE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CTOE. */
#define BF_SDHC_IRQSTAT_CTOE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CTOE) & BM_SDHC_IRQSTAT_CTOE)

/*! @brief Set the CTOE field to a new value. */
#define BW_SDHC_IRQSTAT_CTOE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CTOE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CCE[17] (W1C)
 *
 * Command CRC Error is generated in two cases. If a response is returned and
 * the Command Timeout Error is set to 0, indicating no time-out, this bit is set
 * when detecting a CRC error in the command response. The SDHC detects a CMD line
 * conflict by monitoring the CMD line when a command is issued. If the SDHC
 * drives the CMD line to 1, but detects 0 on the CMD line at the next SDCLK edge,
 * then the SDHC shall abort the command (Stop driving CMD line) and set this bit
 * to 1. The Command Timeout Error shall also be set to 1 to distinguish CMD line
 * conflict.
 *
 * Values:
 * - 0 - No error.
 * - 1 - CRC Error generated.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CCE  (17U)         /*!< Bit position for SDHC_IRQSTAT_CCE. */
#define BM_SDHC_IRQSTAT_CCE  (0x00020000U) /*!< Bit mask for SDHC_IRQSTAT_CCE. */
#define BS_SDHC_IRQSTAT_CCE  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CCE. */

/*! @brief Read current value of the SDHC_IRQSTAT_CCE field. */
#define BR_SDHC_IRQSTAT_CCE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CCE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CCE. */
#define BF_SDHC_IRQSTAT_CCE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CCE) & BM_SDHC_IRQSTAT_CCE)

/*! @brief Set the CCE field to a new value. */
#define BW_SDHC_IRQSTAT_CCE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CCE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CEBE[18] (W1C)
 *
 * Occurs when detecting that the end bit of a command response is 0.
 *
 * Values:
 * - 0 - No error.
 * - 1 - End Bit Error generated.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CEBE (18U)         /*!< Bit position for SDHC_IRQSTAT_CEBE. */
#define BM_SDHC_IRQSTAT_CEBE (0x00040000U) /*!< Bit mask for SDHC_IRQSTAT_CEBE. */
#define BS_SDHC_IRQSTAT_CEBE (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CEBE. */

/*! @brief Read current value of the SDHC_IRQSTAT_CEBE field. */
#define BR_SDHC_IRQSTAT_CEBE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CEBE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CEBE. */
#define BF_SDHC_IRQSTAT_CEBE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CEBE) & BM_SDHC_IRQSTAT_CEBE)

/*! @brief Set the CEBE field to a new value. */
#define BW_SDHC_IRQSTAT_CEBE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CEBE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CIE[19] (W1C)
 *
 * Occurs if a Command Index error occurs in the command response.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CIE  (19U)         /*!< Bit position for SDHC_IRQSTAT_CIE. */
#define BM_SDHC_IRQSTAT_CIE  (0x00080000U) /*!< Bit mask for SDHC_IRQSTAT_CIE. */
#define BS_SDHC_IRQSTAT_CIE  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CIE. */

/*! @brief Read current value of the SDHC_IRQSTAT_CIE field. */
#define BR_SDHC_IRQSTAT_CIE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CIE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CIE. */
#define BF_SDHC_IRQSTAT_CIE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CIE) & BM_SDHC_IRQSTAT_CIE)

/*! @brief Set the CIE field to a new value. */
#define BW_SDHC_IRQSTAT_CIE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CIE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field DTOE[20] (W1C)
 *
 * Occurs when detecting one of following time-out conditions. Busy time-out for
 * R1b,R5b type Busy time-out after Write CRC status Read Data time-out
 *
 * Values:
 * - 0 - No error.
 * - 1 - Time out.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_DTOE (20U)         /*!< Bit position for SDHC_IRQSTAT_DTOE. */
#define BM_SDHC_IRQSTAT_DTOE (0x00100000U) /*!< Bit mask for SDHC_IRQSTAT_DTOE. */
#define BS_SDHC_IRQSTAT_DTOE (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_DTOE. */

/*! @brief Read current value of the SDHC_IRQSTAT_DTOE field. */
#define BR_SDHC_IRQSTAT_DTOE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DTOE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_DTOE. */
#define BF_SDHC_IRQSTAT_DTOE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_DTOE) & BM_SDHC_IRQSTAT_DTOE)

/*! @brief Set the DTOE field to a new value. */
#define BW_SDHC_IRQSTAT_DTOE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DTOE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field DCE[21] (W1C)
 *
 * Occurs when detecting a CRC error when transferring read data, which uses the
 * DAT line, or when detecting the Write CRC status having a value other than
 * 010.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_DCE  (21U)         /*!< Bit position for SDHC_IRQSTAT_DCE. */
#define BM_SDHC_IRQSTAT_DCE  (0x00200000U) /*!< Bit mask for SDHC_IRQSTAT_DCE. */
#define BS_SDHC_IRQSTAT_DCE  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_DCE. */

/*! @brief Read current value of the SDHC_IRQSTAT_DCE field. */
#define BR_SDHC_IRQSTAT_DCE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DCE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_DCE. */
#define BF_SDHC_IRQSTAT_DCE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_DCE) & BM_SDHC_IRQSTAT_DCE)

/*! @brief Set the DCE field to a new value. */
#define BW_SDHC_IRQSTAT_DCE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DCE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field DEBE[22] (W1C)
 *
 * Occurs either when detecting 0 at the end bit position of read data, which
 * uses the DAT line, or at the end bit position of the CRC.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_DEBE (22U)         /*!< Bit position for SDHC_IRQSTAT_DEBE. */
#define BM_SDHC_IRQSTAT_DEBE (0x00400000U) /*!< Bit mask for SDHC_IRQSTAT_DEBE. */
#define BS_SDHC_IRQSTAT_DEBE (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_DEBE. */

/*! @brief Read current value of the SDHC_IRQSTAT_DEBE field. */
#define BR_SDHC_IRQSTAT_DEBE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DEBE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_DEBE. */
#define BF_SDHC_IRQSTAT_DEBE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_DEBE) & BM_SDHC_IRQSTAT_DEBE)

/*! @brief Set the DEBE field to a new value. */
#define BW_SDHC_IRQSTAT_DEBE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DEBE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field AC12E[24] (W1C)
 *
 * Occurs when detecting that one of the bits in the Auto CMD12 Error Status
 * register has changed from 0 to 1. This bit is set to 1, not only when the errors
 * in Auto CMD12 occur, but also when the Auto CMD12 is not executed due to the
 * previous command error.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_AC12E (24U)        /*!< Bit position for SDHC_IRQSTAT_AC12E. */
#define BM_SDHC_IRQSTAT_AC12E (0x01000000U) /*!< Bit mask for SDHC_IRQSTAT_AC12E. */
#define BS_SDHC_IRQSTAT_AC12E (1U)         /*!< Bit field size in bits for SDHC_IRQSTAT_AC12E. */

/*! @brief Read current value of the SDHC_IRQSTAT_AC12E field. */
#define BR_SDHC_IRQSTAT_AC12E(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_AC12E))

/*! @brief Format value for bitfield SDHC_IRQSTAT_AC12E. */
#define BF_SDHC_IRQSTAT_AC12E(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_AC12E) & BM_SDHC_IRQSTAT_AC12E)

/*! @brief Set the AC12E field to a new value. */
#define BW_SDHC_IRQSTAT_AC12E(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_AC12E) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field DMAE[28] (W1C)
 *
 * Occurs when an Internal DMA transfer has failed. This bit is set to 1, when
 * some error occurs in the data transfer. This error can be caused by either
 * Simple DMA or ADMA, depending on which DMA is in use. The value in DMA System
 * Address register is the next fetch address where the error occurs. Because any
 * error corrupts the whole data block, the host driver shall restart the transfer
 * from the corrupted block boundary. The address of the block boundary can be
 * calculated either from the current DSADDR value or from the remaining number of
 * blocks and the block size.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_DMAE (28U)         /*!< Bit position for SDHC_IRQSTAT_DMAE. */
#define BM_SDHC_IRQSTAT_DMAE (0x10000000U) /*!< Bit mask for SDHC_IRQSTAT_DMAE. */
#define BS_SDHC_IRQSTAT_DMAE (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_DMAE. */

/*! @brief Read current value of the SDHC_IRQSTAT_DMAE field. */
#define BR_SDHC_IRQSTAT_DMAE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DMAE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_DMAE. */
#define BF_SDHC_IRQSTAT_DMAE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_DMAE) & BM_SDHC_IRQSTAT_DMAE)

/*! @brief Set the DMAE field to a new value. */
#define BW_SDHC_IRQSTAT_DMAE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DMAE) = (v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_IRQSTATEN - Interrupt Status Enable register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_IRQSTATEN - Interrupt Status Enable register (RW)
 *
 * Reset value: 0x117F013FU
 *
 * Setting the bits in this register to 1 enables the corresponding interrupt
 * status to be set by the specified event. If any bit is cleared, the
 * corresponding interrupt status bit is also cleared, that is, when the bit in this register
 * is cleared, the corresponding bit in interrupt status register is always 0.
 * Depending on PROCTL[IABG] bit setting, SDHC may be programmed to sample the
 * card interrupt signal during the interrupt period and hold its value in the
 * flip-flop. There will be some delays on the card interrupt, asserted from the card,
 * to the time the host system is informed. To detect a CMD line conflict, the
 * host driver must set both IRQSTATEN[CTOESEN] and IRQSTATEN[CCESEN] to 1.
 */
typedef union _hw_sdhc_irqstaten
{
    uint32_t U;
    struct _hw_sdhc_irqstaten_bitfields
    {
        uint32_t CCSEN : 1;            /*!< [0] Command Complete Status Enable */
        uint32_t TCSEN : 1;            /*!< [1] Transfer Complete Status Enable */
        uint32_t BGESEN : 1;           /*!< [2] Block Gap Event Status Enable */
        uint32_t DINTSEN : 1;          /*!< [3] DMA Interrupt Status Enable */
        uint32_t BWRSEN : 1;           /*!< [4] Buffer Write Ready Status Enable */
        uint32_t BRRSEN : 1;           /*!< [5] Buffer Read Ready Status Enable */
        uint32_t CINSEN : 1;           /*!< [6] Card Insertion Status Enable */
        uint32_t CRMSEN : 1;           /*!< [7] Card Removal Status Enable */
        uint32_t CINTSEN : 1;          /*!< [8] Card Interrupt Status Enable */
        uint32_t RESERVED0 : 7;        /*!< [15:9]  */
        uint32_t CTOESEN : 1;          /*!< [16] Command Timeout Error Status Enable */
        uint32_t CCESEN : 1;           /*!< [17] Command CRC Error Status Enable */
        uint32_t CEBESEN : 1;          /*!< [18] Command End Bit Error Status Enable */
        uint32_t CIESEN : 1;           /*!< [19] Command Index Error Status Enable */
        uint32_t DTOESEN : 1;          /*!< [20] Data Timeout Error Status Enable */
        uint32_t DCESEN : 1;           /*!< [21] Data CRC Error Status Enable */
        uint32_t DEBESEN : 1;          /*!< [22] Data End Bit Error Status Enable */
        uint32_t RESERVED1 : 1;        /*!< [23]  */
        uint32_t AC12ESEN : 1;         /*!< [24] Auto CMD12 Error Status Enable */
        uint32_t RESERVED2 : 3;        /*!< [27:25]  */
        uint32_t DMAESEN : 1;          /*!< [28] DMA Error Status Enable */
        uint32_t RESERVED3 : 3;        /*!< [31:29]  */
    } B;
} hw_sdhc_irqstaten_t;

/*!
 * @name Constants and macros for entire SDHC_IRQSTATEN register
 */
/*@{*/
#define HW_SDHC_IRQSTATEN_ADDR(x) ((x) + 0x34U)

#define HW_SDHC_IRQSTATEN(x)     (*(__IO hw_sdhc_irqstaten_t *) HW_SDHC_IRQSTATEN_ADDR(x))
#define HW_SDHC_IRQSTATEN_RD(x)  (HW_SDHC_IRQSTATEN(x).U)
#define HW_SDHC_IRQSTATEN_WR(x, v) (HW_SDHC_IRQSTATEN(x).U = (v))
#define HW_SDHC_IRQSTATEN_SET(x, v) (HW_SDHC_IRQSTATEN_WR(x, HW_SDHC_IRQSTATEN_RD(x) |  (v)))
#define HW_SDHC_IRQSTATEN_CLR(x, v) (HW_SDHC_IRQSTATEN_WR(x, HW_SDHC_IRQSTATEN_RD(x) & ~(v)))
#define HW_SDHC_IRQSTATEN_TOG(x, v) (HW_SDHC_IRQSTATEN_WR(x, HW_SDHC_IRQSTATEN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_IRQSTATEN bitfields
 */

/*!
 * @name Register SDHC_IRQSTATEN, field CCSEN[0] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CCSEN (0U)       /*!< Bit position for SDHC_IRQSTATEN_CCSEN. */
#define BM_SDHC_IRQSTATEN_CCSEN (0x00000001U) /*!< Bit mask for SDHC_IRQSTATEN_CCSEN. */
#define BS_SDHC_IRQSTATEN_CCSEN (1U)       /*!< Bit field size in bits for SDHC_IRQSTATEN_CCSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CCSEN field. */
#define BR_SDHC_IRQSTATEN_CCSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CCSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CCSEN. */
#define BF_SDHC_IRQSTATEN_CCSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CCSEN) & BM_SDHC_IRQSTATEN_CCSEN)

/*! @brief Set the CCSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CCSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CCSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field TCSEN[1] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_TCSEN (1U)       /*!< Bit position for SDHC_IRQSTATEN_TCSEN. */
#define BM_SDHC_IRQSTATEN_TCSEN (0x00000002U) /*!< Bit mask for SDHC_IRQSTATEN_TCSEN. */
#define BS_SDHC_IRQSTATEN_TCSEN (1U)       /*!< Bit field size in bits for SDHC_IRQSTATEN_TCSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_TCSEN field. */
#define BR_SDHC_IRQSTATEN_TCSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_TCSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_TCSEN. */
#define BF_SDHC_IRQSTATEN_TCSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_TCSEN) & BM_SDHC_IRQSTATEN_TCSEN)

/*! @brief Set the TCSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_TCSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_TCSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field BGESEN[2] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_BGESEN (2U)      /*!< Bit position for SDHC_IRQSTATEN_BGESEN. */
#define BM_SDHC_IRQSTATEN_BGESEN (0x00000004U) /*!< Bit mask for SDHC_IRQSTATEN_BGESEN. */
#define BS_SDHC_IRQSTATEN_BGESEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_BGESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_BGESEN field. */
#define BR_SDHC_IRQSTATEN_BGESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_BGESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_BGESEN. */
#define BF_SDHC_IRQSTATEN_BGESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_BGESEN) & BM_SDHC_IRQSTATEN_BGESEN)

/*! @brief Set the BGESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_BGESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_BGESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field DINTSEN[3] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_DINTSEN (3U)     /*!< Bit position for SDHC_IRQSTATEN_DINTSEN. */
#define BM_SDHC_IRQSTATEN_DINTSEN (0x00000008U) /*!< Bit mask for SDHC_IRQSTATEN_DINTSEN. */
#define BS_SDHC_IRQSTATEN_DINTSEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_DINTSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_DINTSEN field. */
#define BR_SDHC_IRQSTATEN_DINTSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DINTSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_DINTSEN. */
#define BF_SDHC_IRQSTATEN_DINTSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_DINTSEN) & BM_SDHC_IRQSTATEN_DINTSEN)

/*! @brief Set the DINTSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_DINTSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DINTSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field BWRSEN[4] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_BWRSEN (4U)      /*!< Bit position for SDHC_IRQSTATEN_BWRSEN. */
#define BM_SDHC_IRQSTATEN_BWRSEN (0x00000010U) /*!< Bit mask for SDHC_IRQSTATEN_BWRSEN. */
#define BS_SDHC_IRQSTATEN_BWRSEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_BWRSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_BWRSEN field. */
#define BR_SDHC_IRQSTATEN_BWRSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_BWRSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_BWRSEN. */
#define BF_SDHC_IRQSTATEN_BWRSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_BWRSEN) & BM_SDHC_IRQSTATEN_BWRSEN)

/*! @brief Set the BWRSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_BWRSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_BWRSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field BRRSEN[5] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_BRRSEN (5U)      /*!< Bit position for SDHC_IRQSTATEN_BRRSEN. */
#define BM_SDHC_IRQSTATEN_BRRSEN (0x00000020U) /*!< Bit mask for SDHC_IRQSTATEN_BRRSEN. */
#define BS_SDHC_IRQSTATEN_BRRSEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_BRRSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_BRRSEN field. */
#define BR_SDHC_IRQSTATEN_BRRSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_BRRSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_BRRSEN. */
#define BF_SDHC_IRQSTATEN_BRRSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_BRRSEN) & BM_SDHC_IRQSTATEN_BRRSEN)

/*! @brief Set the BRRSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_BRRSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_BRRSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CINSEN[6] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CINSEN (6U)      /*!< Bit position for SDHC_IRQSTATEN_CINSEN. */
#define BM_SDHC_IRQSTATEN_CINSEN (0x00000040U) /*!< Bit mask for SDHC_IRQSTATEN_CINSEN. */
#define BS_SDHC_IRQSTATEN_CINSEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_CINSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CINSEN field. */
#define BR_SDHC_IRQSTATEN_CINSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CINSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CINSEN. */
#define BF_SDHC_IRQSTATEN_CINSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CINSEN) & BM_SDHC_IRQSTATEN_CINSEN)

/*! @brief Set the CINSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CINSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CINSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CRMSEN[7] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CRMSEN (7U)      /*!< Bit position for SDHC_IRQSTATEN_CRMSEN. */
#define BM_SDHC_IRQSTATEN_CRMSEN (0x00000080U) /*!< Bit mask for SDHC_IRQSTATEN_CRMSEN. */
#define BS_SDHC_IRQSTATEN_CRMSEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_CRMSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CRMSEN field. */
#define BR_SDHC_IRQSTATEN_CRMSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CRMSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CRMSEN. */
#define BF_SDHC_IRQSTATEN_CRMSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CRMSEN) & BM_SDHC_IRQSTATEN_CRMSEN)

/*! @brief Set the CRMSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CRMSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CRMSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CINTSEN[8] (RW)
 *
 * If this bit is set to 0, the SDHC will clear the interrupt request to the
 * system. The card interrupt detection is stopped when this bit is cleared and
 * restarted when this bit is set to 1. The host driver must clear the this bit
 * before servicing the card interrupt and must set this bit again after all interrupt
 * requests from the card are cleared to prevent inadvertent interrupts.
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CINTSEN (8U)     /*!< Bit position for SDHC_IRQSTATEN_CINTSEN. */
#define BM_SDHC_IRQSTATEN_CINTSEN (0x00000100U) /*!< Bit mask for SDHC_IRQSTATEN_CINTSEN. */
#define BS_SDHC_IRQSTATEN_CINTSEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_CINTSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CINTSEN field. */
#define BR_SDHC_IRQSTATEN_CINTSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CINTSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CINTSEN. */
#define BF_SDHC_IRQSTATEN_CINTSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CINTSEN) & BM_SDHC_IRQSTATEN_CINTSEN)

/*! @brief Set the CINTSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CINTSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CINTSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CTOESEN[16] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CTOESEN (16U)    /*!< Bit position for SDHC_IRQSTATEN_CTOESEN. */
#define BM_SDHC_IRQSTATEN_CTOESEN (0x00010000U) /*!< Bit mask for SDHC_IRQSTATEN_CTOESEN. */
#define BS_SDHC_IRQSTATEN_CTOESEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_CTOESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CTOESEN field. */
#define BR_SDHC_IRQSTATEN_CTOESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CTOESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CTOESEN. */
#define BF_SDHC_IRQSTATEN_CTOESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CTOESEN) & BM_SDHC_IRQSTATEN_CTOESEN)

/*! @brief Set the CTOESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CTOESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CTOESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CCESEN[17] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CCESEN (17U)     /*!< Bit position for SDHC_IRQSTATEN_CCESEN. */
#define BM_SDHC_IRQSTATEN_CCESEN (0x00020000U) /*!< Bit mask for SDHC_IRQSTATEN_CCESEN. */
#define BS_SDHC_IRQSTATEN_CCESEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_CCESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CCESEN field. */
#define BR_SDHC_IRQSTATEN_CCESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CCESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CCESEN. */
#define BF_SDHC_IRQSTATEN_CCESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CCESEN) & BM_SDHC_IRQSTATEN_CCESEN)

/*! @brief Set the CCESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CCESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CCESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CEBESEN[18] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CEBESEN (18U)    /*!< Bit position for SDHC_IRQSTATEN_CEBESEN. */
#define BM_SDHC_IRQSTATEN_CEBESEN (0x00040000U) /*!< Bit mask for SDHC_IRQSTATEN_CEBESEN. */
#define BS_SDHC_IRQSTATEN_CEBESEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_CEBESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CEBESEN field. */
#define BR_SDHC_IRQSTATEN_CEBESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CEBESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CEBESEN. */
#define BF_SDHC_IRQSTATEN_CEBESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CEBESEN) & BM_SDHC_IRQSTATEN_CEBESEN)

/*! @brief Set the CEBESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CEBESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CEBESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CIESEN[19] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CIESEN (19U)     /*!< Bit position for SDHC_IRQSTATEN_CIESEN. */
#define BM_SDHC_IRQSTATEN_CIESEN (0x00080000U) /*!< Bit mask for SDHC_IRQSTATEN_CIESEN. */
#define BS_SDHC_IRQSTATEN_CIESEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_CIESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CIESEN field. */
#define BR_SDHC_IRQSTATEN_CIESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CIESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CIESEN. */
#define BF_SDHC_IRQSTATEN_CIESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CIESEN) & BM_SDHC_IRQSTATEN_CIESEN)

/*! @brief Set the CIESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CIESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CIESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field DTOESEN[20] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_DTOESEN (20U)    /*!< Bit position for SDHC_IRQSTATEN_DTOESEN. */
#define BM_SDHC_IRQSTATEN_DTOESEN (0x00100000U) /*!< Bit mask for SDHC_IRQSTATEN_DTOESEN. */
#define BS_SDHC_IRQSTATEN_DTOESEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_DTOESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_DTOESEN field. */
#define BR_SDHC_IRQSTATEN_DTOESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DTOESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_DTOESEN. */
#define BF_SDHC_IRQSTATEN_DTOESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_DTOESEN) & BM_SDHC_IRQSTATEN_DTOESEN)

/*! @brief Set the DTOESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_DTOESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DTOESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field DCESEN[21] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_DCESEN (21U)     /*!< Bit position for SDHC_IRQSTATEN_DCESEN. */
#define BM_SDHC_IRQSTATEN_DCESEN (0x00200000U) /*!< Bit mask for SDHC_IRQSTATEN_DCESEN. */
#define BS_SDHC_IRQSTATEN_DCESEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_DCESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_DCESEN field. */
#define BR_SDHC_IRQSTATEN_DCESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DCESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_DCESEN. */
#define BF_SDHC_IRQSTATEN_DCESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_DCESEN) & BM_SDHC_IRQSTATEN_DCESEN)

/*! @brief Set the DCESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_DCESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DCESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field DEBESEN[22] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_DEBESEN (22U)    /*!< Bit position for SDHC_IRQSTATEN_DEBESEN. */
#define BM_SDHC_IRQSTATEN_DEBESEN (0x00400000U) /*!< Bit mask for SDHC_IRQSTATEN_DEBESEN. */
#define BS_SDHC_IRQSTATEN_DEBESEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_DEBESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_DEBESEN field. */
#define BR_SDHC_IRQSTATEN_DEBESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DEBESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_DEBESEN. */
#define BF_SDHC_IRQSTATEN_DEBESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_DEBESEN) & BM_SDHC_IRQSTATEN_DEBESEN)

/*! @brief Set the DEBESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_DEBESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DEBESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field AC12ESEN[24] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_AC12ESEN (24U)   /*!< Bit position for SDHC_IRQSTATEN_AC12ESEN. */
#define BM_SDHC_IRQSTATEN_AC12ESEN (0x01000000U) /*!< Bit mask for SDHC_IRQSTATEN_AC12ESEN. */
#define BS_SDHC_IRQSTATEN_AC12ESEN (1U)    /*!< Bit field size in bits for SDHC_IRQSTATEN_AC12ESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_AC12ESEN field. */
#define BR_SDHC_IRQSTATEN_AC12ESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_AC12ESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_AC12ESEN. */
#define BF_SDHC_IRQSTATEN_AC12ESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_AC12ESEN) & BM_SDHC_IRQSTATEN_AC12ESEN)

/*! @brief Set the AC12ESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_AC12ESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_AC12ESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field DMAESEN[28] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_DMAESEN (28U)    /*!< Bit position for SDHC_IRQSTATEN_DMAESEN. */
#define BM_SDHC_IRQSTATEN_DMAESEN (0x10000000U) /*!< Bit mask for SDHC_IRQSTATEN_DMAESEN. */
#define BS_SDHC_IRQSTATEN_DMAESEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_DMAESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_DMAESEN field. */
#define BR_SDHC_IRQSTATEN_DMAESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DMAESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_DMAESEN. */
#define BF_SDHC_IRQSTATEN_DMAESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_DMAESEN) & BM_SDHC_IRQSTATEN_DMAESEN)

/*! @brief Set the DMAESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_DMAESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DMAESEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_IRQSIGEN - Interrupt Signal Enable register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_IRQSIGEN - Interrupt Signal Enable register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to select which interrupt status is indicated to the
 * host system as the interrupt. All of these status bits share the same interrupt
 * line. Setting any of these bits to 1 enables interrupt generation. The
 * corresponding status register bit will generate an interrupt when the corresponding
 * interrupt signal enable bit is set.
 */
typedef union _hw_sdhc_irqsigen
{
    uint32_t U;
    struct _hw_sdhc_irqsigen_bitfields
    {
        uint32_t CCIEN : 1;            /*!< [0] Command Complete Interrupt Enable */
        uint32_t TCIEN : 1;            /*!< [1] Transfer Complete Interrupt Enable */
        uint32_t BGEIEN : 1;           /*!< [2] Block Gap Event Interrupt Enable */
        uint32_t DINTIEN : 1;          /*!< [3] DMA Interrupt Enable */
        uint32_t BWRIEN : 1;           /*!< [4] Buffer Write Ready Interrupt Enable */
        uint32_t BRRIEN : 1;           /*!< [5] Buffer Read Ready Interrupt Enable */
        uint32_t CINSIEN : 1;          /*!< [6] Card Insertion Interrupt Enable */
        uint32_t CRMIEN : 1;           /*!< [7] Card Removal Interrupt Enable */
        uint32_t CINTIEN : 1;          /*!< [8] Card Interrupt Enable */
        uint32_t RESERVED0 : 7;        /*!< [15:9]  */
        uint32_t CTOEIEN : 1;          /*!< [16] Command Timeout Error Interrupt
                                        * Enable */
        uint32_t CCEIEN : 1;           /*!< [17] Command CRC Error Interrupt Enable */
        uint32_t CEBEIEN : 1;          /*!< [18] Command End Bit Error Interrupt
                                        * Enable */
        uint32_t CIEIEN : 1;           /*!< [19] Command Index Error Interrupt Enable */
        uint32_t DTOEIEN : 1;          /*!< [20] Data Timeout Error Interrupt Enable */
        uint32_t DCEIEN : 1;           /*!< [21] Data CRC Error Interrupt Enable */
        uint32_t DEBEIEN : 1;          /*!< [22] Data End Bit Error Interrupt Enable */
        uint32_t RESERVED1 : 1;        /*!< [23]  */
        uint32_t AC12EIEN : 1;         /*!< [24] Auto CMD12 Error Interrupt Enable */
        uint32_t RESERVED2 : 3;        /*!< [27:25]  */
        uint32_t DMAEIEN : 1;          /*!< [28] DMA Error Interrupt Enable */
        uint32_t RESERVED3 : 3;        /*!< [31:29]  */
    } B;
} hw_sdhc_irqsigen_t;

/*!
 * @name Constants and macros for entire SDHC_IRQSIGEN register
 */
/*@{*/
#define HW_SDHC_IRQSIGEN_ADDR(x) ((x) + 0x38U)

#define HW_SDHC_IRQSIGEN(x)      (*(__IO hw_sdhc_irqsigen_t *) HW_SDHC_IRQSIGEN_ADDR(x))
#define HW_SDHC_IRQSIGEN_RD(x)   (HW_SDHC_IRQSIGEN(x).U)
#define HW_SDHC_IRQSIGEN_WR(x, v) (HW_SDHC_IRQSIGEN(x).U = (v))
#define HW_SDHC_IRQSIGEN_SET(x, v) (HW_SDHC_IRQSIGEN_WR(x, HW_SDHC_IRQSIGEN_RD(x) |  (v)))
#define HW_SDHC_IRQSIGEN_CLR(x, v) (HW_SDHC_IRQSIGEN_WR(x, HW_SDHC_IRQSIGEN_RD(x) & ~(v)))
#define HW_SDHC_IRQSIGEN_TOG(x, v) (HW_SDHC_IRQSIGEN_WR(x, HW_SDHC_IRQSIGEN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_IRQSIGEN bitfields
 */

/*!
 * @name Register SDHC_IRQSIGEN, field CCIEN[0] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CCIEN (0U)        /*!< Bit position for SDHC_IRQSIGEN_CCIEN. */
#define BM_SDHC_IRQSIGEN_CCIEN (0x00000001U) /*!< Bit mask for SDHC_IRQSIGEN_CCIEN. */
#define BS_SDHC_IRQSIGEN_CCIEN (1U)        /*!< Bit field size in bits for SDHC_IRQSIGEN_CCIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CCIEN field. */
#define BR_SDHC_IRQSIGEN_CCIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CCIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CCIEN. */
#define BF_SDHC_IRQSIGEN_CCIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CCIEN) & BM_SDHC_IRQSIGEN_CCIEN)

/*! @brief Set the CCIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CCIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CCIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field TCIEN[1] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_TCIEN (1U)        /*!< Bit position for SDHC_IRQSIGEN_TCIEN. */
#define BM_SDHC_IRQSIGEN_TCIEN (0x00000002U) /*!< Bit mask for SDHC_IRQSIGEN_TCIEN. */
#define BS_SDHC_IRQSIGEN_TCIEN (1U)        /*!< Bit field size in bits for SDHC_IRQSIGEN_TCIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_TCIEN field. */
#define BR_SDHC_IRQSIGEN_TCIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_TCIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_TCIEN. */
#define BF_SDHC_IRQSIGEN_TCIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_TCIEN) & BM_SDHC_IRQSIGEN_TCIEN)

/*! @brief Set the TCIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_TCIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_TCIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field BGEIEN[2] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_BGEIEN (2U)       /*!< Bit position for SDHC_IRQSIGEN_BGEIEN. */
#define BM_SDHC_IRQSIGEN_BGEIEN (0x00000004U) /*!< Bit mask for SDHC_IRQSIGEN_BGEIEN. */
#define BS_SDHC_IRQSIGEN_BGEIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_BGEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_BGEIEN field. */
#define BR_SDHC_IRQSIGEN_BGEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_BGEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_BGEIEN. */
#define BF_SDHC_IRQSIGEN_BGEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_BGEIEN) & BM_SDHC_IRQSIGEN_BGEIEN)

/*! @brief Set the BGEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_BGEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_BGEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field DINTIEN[3] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_DINTIEN (3U)      /*!< Bit position for SDHC_IRQSIGEN_DINTIEN. */
#define BM_SDHC_IRQSIGEN_DINTIEN (0x00000008U) /*!< Bit mask for SDHC_IRQSIGEN_DINTIEN. */
#define BS_SDHC_IRQSIGEN_DINTIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_DINTIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_DINTIEN field. */
#define BR_SDHC_IRQSIGEN_DINTIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DINTIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_DINTIEN. */
#define BF_SDHC_IRQSIGEN_DINTIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_DINTIEN) & BM_SDHC_IRQSIGEN_DINTIEN)

/*! @brief Set the DINTIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_DINTIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DINTIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field BWRIEN[4] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_BWRIEN (4U)       /*!< Bit position for SDHC_IRQSIGEN_BWRIEN. */
#define BM_SDHC_IRQSIGEN_BWRIEN (0x00000010U) /*!< Bit mask for SDHC_IRQSIGEN_BWRIEN. */
#define BS_SDHC_IRQSIGEN_BWRIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_BWRIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_BWRIEN field. */
#define BR_SDHC_IRQSIGEN_BWRIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_BWRIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_BWRIEN. */
#define BF_SDHC_IRQSIGEN_BWRIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_BWRIEN) & BM_SDHC_IRQSIGEN_BWRIEN)

/*! @brief Set the BWRIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_BWRIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_BWRIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field BRRIEN[5] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_BRRIEN (5U)       /*!< Bit position for SDHC_IRQSIGEN_BRRIEN. */
#define BM_SDHC_IRQSIGEN_BRRIEN (0x00000020U) /*!< Bit mask for SDHC_IRQSIGEN_BRRIEN. */
#define BS_SDHC_IRQSIGEN_BRRIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_BRRIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_BRRIEN field. */
#define BR_SDHC_IRQSIGEN_BRRIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_BRRIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_BRRIEN. */
#define BF_SDHC_IRQSIGEN_BRRIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_BRRIEN) & BM_SDHC_IRQSIGEN_BRRIEN)

/*! @brief Set the BRRIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_BRRIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_BRRIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CINSIEN[6] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CINSIEN (6U)      /*!< Bit position for SDHC_IRQSIGEN_CINSIEN. */
#define BM_SDHC_IRQSIGEN_CINSIEN (0x00000040U) /*!< Bit mask for SDHC_IRQSIGEN_CINSIEN. */
#define BS_SDHC_IRQSIGEN_CINSIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_CINSIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CINSIEN field. */
#define BR_SDHC_IRQSIGEN_CINSIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CINSIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CINSIEN. */
#define BF_SDHC_IRQSIGEN_CINSIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CINSIEN) & BM_SDHC_IRQSIGEN_CINSIEN)

/*! @brief Set the CINSIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CINSIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CINSIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CRMIEN[7] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CRMIEN (7U)       /*!< Bit position for SDHC_IRQSIGEN_CRMIEN. */
#define BM_SDHC_IRQSIGEN_CRMIEN (0x00000080U) /*!< Bit mask for SDHC_IRQSIGEN_CRMIEN. */
#define BS_SDHC_IRQSIGEN_CRMIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_CRMIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CRMIEN field. */
#define BR_SDHC_IRQSIGEN_CRMIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CRMIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CRMIEN. */
#define BF_SDHC_IRQSIGEN_CRMIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CRMIEN) & BM_SDHC_IRQSIGEN_CRMIEN)

/*! @brief Set the CRMIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CRMIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CRMIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CINTIEN[8] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CINTIEN (8U)      /*!< Bit position for SDHC_IRQSIGEN_CINTIEN. */
#define BM_SDHC_IRQSIGEN_CINTIEN (0x00000100U) /*!< Bit mask for SDHC_IRQSIGEN_CINTIEN. */
#define BS_SDHC_IRQSIGEN_CINTIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_CINTIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CINTIEN field. */
#define BR_SDHC_IRQSIGEN_CINTIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CINTIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CINTIEN. */
#define BF_SDHC_IRQSIGEN_CINTIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CINTIEN) & BM_SDHC_IRQSIGEN_CINTIEN)

/*! @brief Set the CINTIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CINTIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CINTIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CTOEIEN[16] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CTOEIEN (16U)     /*!< Bit position for SDHC_IRQSIGEN_CTOEIEN. */
#define BM_SDHC_IRQSIGEN_CTOEIEN (0x00010000U) /*!< Bit mask for SDHC_IRQSIGEN_CTOEIEN. */
#define BS_SDHC_IRQSIGEN_CTOEIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_CTOEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CTOEIEN field. */
#define BR_SDHC_IRQSIGEN_CTOEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CTOEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CTOEIEN. */
#define BF_SDHC_IRQSIGEN_CTOEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CTOEIEN) & BM_SDHC_IRQSIGEN_CTOEIEN)

/*! @brief Set the CTOEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CTOEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CTOEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CCEIEN[17] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CCEIEN (17U)      /*!< Bit position for SDHC_IRQSIGEN_CCEIEN. */
#define BM_SDHC_IRQSIGEN_CCEIEN (0x00020000U) /*!< Bit mask for SDHC_IRQSIGEN_CCEIEN. */
#define BS_SDHC_IRQSIGEN_CCEIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_CCEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CCEIEN field. */
#define BR_SDHC_IRQSIGEN_CCEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CCEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CCEIEN. */
#define BF_SDHC_IRQSIGEN_CCEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CCEIEN) & BM_SDHC_IRQSIGEN_CCEIEN)

/*! @brief Set the CCEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CCEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CCEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CEBEIEN[18] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CEBEIEN (18U)     /*!< Bit position for SDHC_IRQSIGEN_CEBEIEN. */
#define BM_SDHC_IRQSIGEN_CEBEIEN (0x00040000U) /*!< Bit mask for SDHC_IRQSIGEN_CEBEIEN. */
#define BS_SDHC_IRQSIGEN_CEBEIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_CEBEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CEBEIEN field. */
#define BR_SDHC_IRQSIGEN_CEBEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CEBEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CEBEIEN. */
#define BF_SDHC_IRQSIGEN_CEBEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CEBEIEN) & BM_SDHC_IRQSIGEN_CEBEIEN)

/*! @brief Set the CEBEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CEBEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CEBEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CIEIEN[19] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CIEIEN (19U)      /*!< Bit position for SDHC_IRQSIGEN_CIEIEN. */
#define BM_SDHC_IRQSIGEN_CIEIEN (0x00080000U) /*!< Bit mask for SDHC_IRQSIGEN_CIEIEN. */
#define BS_SDHC_IRQSIGEN_CIEIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_CIEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CIEIEN field. */
#define BR_SDHC_IRQSIGEN_CIEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CIEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CIEIEN. */
#define BF_SDHC_IRQSIGEN_CIEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CIEIEN) & BM_SDHC_IRQSIGEN_CIEIEN)

/*! @brief Set the CIEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CIEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CIEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field DTOEIEN[20] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_DTOEIEN (20U)     /*!< Bit position for SDHC_IRQSIGEN_DTOEIEN. */
#define BM_SDHC_IRQSIGEN_DTOEIEN (0x00100000U) /*!< Bit mask for SDHC_IRQSIGEN_DTOEIEN. */
#define BS_SDHC_IRQSIGEN_DTOEIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_DTOEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_DTOEIEN field. */
#define BR_SDHC_IRQSIGEN_DTOEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DTOEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_DTOEIEN. */
#define BF_SDHC_IRQSIGEN_DTOEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_DTOEIEN) & BM_SDHC_IRQSIGEN_DTOEIEN)

/*! @brief Set the DTOEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_DTOEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DTOEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field DCEIEN[21] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_DCEIEN (21U)      /*!< Bit position for SDHC_IRQSIGEN_DCEIEN. */
#define BM_SDHC_IRQSIGEN_DCEIEN (0x00200000U) /*!< Bit mask for SDHC_IRQSIGEN_DCEIEN. */
#define BS_SDHC_IRQSIGEN_DCEIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_DCEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_DCEIEN field. */
#define BR_SDHC_IRQSIGEN_DCEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DCEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_DCEIEN. */
#define BF_SDHC_IRQSIGEN_DCEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_DCEIEN) & BM_SDHC_IRQSIGEN_DCEIEN)

/*! @brief Set the DCEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_DCEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DCEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field DEBEIEN[22] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_DEBEIEN (22U)     /*!< Bit position for SDHC_IRQSIGEN_DEBEIEN. */
#define BM_SDHC_IRQSIGEN_DEBEIEN (0x00400000U) /*!< Bit mask for SDHC_IRQSIGEN_DEBEIEN. */
#define BS_SDHC_IRQSIGEN_DEBEIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_DEBEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_DEBEIEN field. */
#define BR_SDHC_IRQSIGEN_DEBEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DEBEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_DEBEIEN. */
#define BF_SDHC_IRQSIGEN_DEBEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_DEBEIEN) & BM_SDHC_IRQSIGEN_DEBEIEN)

/*! @brief Set the DEBEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_DEBEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DEBEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field AC12EIEN[24] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_AC12EIEN (24U)    /*!< Bit position for SDHC_IRQSIGEN_AC12EIEN. */
#define BM_SDHC_IRQSIGEN_AC12EIEN (0x01000000U) /*!< Bit mask for SDHC_IRQSIGEN_AC12EIEN. */
#define BS_SDHC_IRQSIGEN_AC12EIEN (1U)     /*!< Bit field size in bits for SDHC_IRQSIGEN_AC12EIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_AC12EIEN field. */
#define BR_SDHC_IRQSIGEN_AC12EIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_AC12EIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_AC12EIEN. */
#define BF_SDHC_IRQSIGEN_AC12EIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_AC12EIEN) & BM_SDHC_IRQSIGEN_AC12EIEN)

/*! @brief Set the AC12EIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_AC12EIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_AC12EIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field DMAEIEN[28] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_DMAEIEN (28U)     /*!< Bit position for SDHC_IRQSIGEN_DMAEIEN. */
#define BM_SDHC_IRQSIGEN_DMAEIEN (0x10000000U) /*!< Bit mask for SDHC_IRQSIGEN_DMAEIEN. */
#define BS_SDHC_IRQSIGEN_DMAEIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_DMAEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_DMAEIEN field. */
#define BR_SDHC_IRQSIGEN_DMAEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DMAEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_DMAEIEN. */
#define BF_SDHC_IRQSIGEN_DMAEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_DMAEIEN) & BM_SDHC_IRQSIGEN_DMAEIEN)

/*! @brief Set the DMAEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_DMAEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DMAEIEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_AC12ERR - Auto CMD12 Error Status Register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_AC12ERR - Auto CMD12 Error Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the AC12ESEN bit in the Status register is set, the host driver shall
 * check this register to identify what kind of error the Auto CMD12 indicated.
 * This register is valid only when the Auto CMD12 Error status bit is set. The
 * following table shows the relationship between the Auto CMGD12 CRC error and the
 * Auto CMD12 command timeout error. Relationship between Command CRC Error and
 * Command Timeout Error For Auto CMD12 Auto CMD12 CRC error Auto CMD12 timeout
 * error Type of error 0 0 No error 0 1 Response timeout error 1 0 Response CRC
 * error 1 1 CMD line conflict Changes in Auto CMD12 Error Status register can be
 * classified in three scenarios: When the SDHC is going to issue an Auto CMD12: Set
 * bit 0 to 1 if the Auto CMD12 can't be issued due to an error in the previous
 * command. Set bit 0 to 0 if the auto CMD12 is issued. At the end bit of an auto
 * CMD12 response: Check errors corresponding to bits 1-4. Set bits 1-4
 * corresponding to detected errors. Clear bits 1-4 corresponding to detected errors.
 * Before reading the Auto CMD12 error status bit 7: Set bit 7 to 1 if there is a
 * command that can't be issued. Clear bit 7 if there is no command to issue. The
 * timing for generating the auto CMD12 error and writing to the command register
 * are asynchronous. After that, bit 7 shall be sampled when the driver is not
 * writing to the command register. So it is suggested to read this register only
 * when IRQSTAT[AC12E] is set. An Auto CMD12 error interrupt is generated when one
 * of the error bits (0-4) is set to 1. The command not issued by auto CMD12
 * error does not generate an interrupt.
 */
typedef union _hw_sdhc_ac12err
{
    uint32_t U;
    struct _hw_sdhc_ac12err_bitfields
    {
        uint32_t AC12NE : 1;           /*!< [0] Auto CMD12 Not Executed */
        uint32_t AC12TOE : 1;          /*!< [1] Auto CMD12 Timeout Error */
        uint32_t AC12EBE : 1;          /*!< [2] Auto CMD12 End Bit Error */
        uint32_t AC12CE : 1;           /*!< [3] Auto CMD12 CRC Error */
        uint32_t AC12IE : 1;           /*!< [4] Auto CMD12 Index Error */
        uint32_t RESERVED0 : 2;        /*!< [6:5]  */
        uint32_t CNIBAC12E : 1;        /*!< [7] Command Not Issued By Auto CMD12
                                        * Error */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_sdhc_ac12err_t;

/*!
 * @name Constants and macros for entire SDHC_AC12ERR register
 */
/*@{*/
#define HW_SDHC_AC12ERR_ADDR(x)  ((x) + 0x3CU)

#define HW_SDHC_AC12ERR(x)       (*(__I hw_sdhc_ac12err_t *) HW_SDHC_AC12ERR_ADDR(x))
#define HW_SDHC_AC12ERR_RD(x)    (HW_SDHC_AC12ERR(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_AC12ERR bitfields
 */

/*!
 * @name Register SDHC_AC12ERR, field AC12NE[0] (RO)
 *
 * If memory multiple block data transfer is not started, due to a command
 * error, this bit is not set because it is not necessary to issue an auto CMD12.
 * Setting this bit to 1 means the SDHC cannot issue the auto CMD12 to stop a memory
 * multiple block data transfer due to some error. If this bit is set to 1, other
 * error status bits (1-4) have no meaning.
 *
 * Values:
 * - 0 - Executed.
 * - 1 - Not executed.
 */
/*@{*/
#define BP_SDHC_AC12ERR_AC12NE (0U)        /*!< Bit position for SDHC_AC12ERR_AC12NE. */
#define BM_SDHC_AC12ERR_AC12NE (0x00000001U) /*!< Bit mask for SDHC_AC12ERR_AC12NE. */
#define BS_SDHC_AC12ERR_AC12NE (1U)        /*!< Bit field size in bits for SDHC_AC12ERR_AC12NE. */

/*! @brief Read current value of the SDHC_AC12ERR_AC12NE field. */
#define BR_SDHC_AC12ERR_AC12NE(x) (BITBAND_ACCESS32(HW_SDHC_AC12ERR_ADDR(x), BP_SDHC_AC12ERR_AC12NE))
/*@}*/

/*!
 * @name Register SDHC_AC12ERR, field AC12TOE[1] (RO)
 *
 * Occurs if no response is returned within 64 SDCLK cycles from the end bit of
 * the command. If this bit is set to 1, the other error status bits (2-4) have
 * no meaning.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Time out.
 */
/*@{*/
#define BP_SDHC_AC12ERR_AC12TOE (1U)       /*!< Bit position for SDHC_AC12ERR_AC12TOE. */
#define BM_SDHC_AC12ERR_AC12TOE (0x00000002U) /*!< Bit mask for SDHC_AC12ERR_AC12TOE. */
#define BS_SDHC_AC12ERR_AC12TOE (1U)       /*!< Bit field size in bits for SDHC_AC12ERR_AC12TOE. */

/*! @brief Read current value of the SDHC_AC12ERR_AC12TOE field. */
#define BR_SDHC_AC12ERR_AC12TOE(x) (BITBAND_ACCESS32(HW_SDHC_AC12ERR_ADDR(x), BP_SDHC_AC12ERR_AC12TOE))
/*@}*/

/*!
 * @name Register SDHC_AC12ERR, field AC12EBE[2] (RO)
 *
 * Occurs when detecting that the end bit of command response is 0 which must be
 * 1.
 *
 * Values:
 * - 0 - No error.
 * - 1 - End bit error generated.
 */
/*@{*/
#define BP_SDHC_AC12ERR_AC12EBE (2U)       /*!< Bit position for SDHC_AC12ERR_AC12EBE. */
#define BM_SDHC_AC12ERR_AC12EBE (0x00000004U) /*!< Bit mask for SDHC_AC12ERR_AC12EBE. */
#define BS_SDHC_AC12ERR_AC12EBE (1U)       /*!< Bit field size in bits for SDHC_AC12ERR_AC12EBE. */

/*! @brief Read current value of the SDHC_AC12ERR_AC12EBE field. */
#define BR_SDHC_AC12ERR_AC12EBE(x) (BITBAND_ACCESS32(HW_SDHC_AC12ERR_ADDR(x), BP_SDHC_AC12ERR_AC12EBE))
/*@}*/

/*!
 * @name Register SDHC_AC12ERR, field AC12CE[3] (RO)
 *
 * Occurs when detecting a CRC error in the command response.
 *
 * Values:
 * - 0 - No CRC error.
 * - 1 - CRC error met in Auto CMD12 response.
 */
/*@{*/
#define BP_SDHC_AC12ERR_AC12CE (3U)        /*!< Bit position for SDHC_AC12ERR_AC12CE. */
#define BM_SDHC_AC12ERR_AC12CE (0x00000008U) /*!< Bit mask for SDHC_AC12ERR_AC12CE. */
#define BS_SDHC_AC12ERR_AC12CE (1U)        /*!< Bit field size in bits for SDHC_AC12ERR_AC12CE. */

/*! @brief Read current value of the SDHC_AC12ERR_AC12CE field. */
#define BR_SDHC_AC12ERR_AC12CE(x) (BITBAND_ACCESS32(HW_SDHC_AC12ERR_ADDR(x), BP_SDHC_AC12ERR_AC12CE))
/*@}*/

/*!
 * @name Register SDHC_AC12ERR, field AC12IE[4] (RO)
 *
 * Occurs if the command index error occurs in response to a command.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error, the CMD index in response is not CMD12.
 */
/*@{*/
#define BP_SDHC_AC12ERR_AC12IE (4U)        /*!< Bit position for SDHC_AC12ERR_AC12IE. */
#define BM_SDHC_AC12ERR_AC12IE (0x00000010U) /*!< Bit mask for SDHC_AC12ERR_AC12IE. */
#define BS_SDHC_AC12ERR_AC12IE (1U)        /*!< Bit field size in bits for SDHC_AC12ERR_AC12IE. */

/*! @brief Read current value of the SDHC_AC12ERR_AC12IE field. */
#define BR_SDHC_AC12ERR_AC12IE(x) (BITBAND_ACCESS32(HW_SDHC_AC12ERR_ADDR(x), BP_SDHC_AC12ERR_AC12IE))
/*@}*/

/*!
 * @name Register SDHC_AC12ERR, field CNIBAC12E[7] (RO)
 *
 * Setting this bit to 1 means CMD_wo_DAT is not executed due to an auto CMD12
 * error (D04-D01) in this register.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Not issued.
 */
/*@{*/
#define BP_SDHC_AC12ERR_CNIBAC12E (7U)     /*!< Bit position for SDHC_AC12ERR_CNIBAC12E. */
#define BM_SDHC_AC12ERR_CNIBAC12E (0x00000080U) /*!< Bit mask for SDHC_AC12ERR_CNIBAC12E. */
#define BS_SDHC_AC12ERR_CNIBAC12E (1U)     /*!< Bit field size in bits for SDHC_AC12ERR_CNIBAC12E. */

/*! @brief Read current value of the SDHC_AC12ERR_CNIBAC12E field. */
#define BR_SDHC_AC12ERR_CNIBAC12E(x) (BITBAND_ACCESS32(HW_SDHC_AC12ERR_ADDR(x), BP_SDHC_AC12ERR_CNIBAC12E))
/*@}*/

/*******************************************************************************
 * HW_SDHC_HTCAPBLT - Host Controller Capabilities
 ******************************************************************************/

/*!
 * @brief HW_SDHC_HTCAPBLT - Host Controller Capabilities (RO)
 *
 * Reset value: 0x07F30000U
 *
 * This register provides the host driver with information specific to the SDHC
 * implementation. The value in this register is the power-on-reset value, and
 * does not change with a software reset. Any write to this register is ignored.
 */
typedef union _hw_sdhc_htcapblt
{
    uint32_t U;
    struct _hw_sdhc_htcapblt_bitfields
    {
        uint32_t RESERVED0 : 16;       /*!< [15:0]  */
        uint32_t MBL : 3;              /*!< [18:16] Max Block Length */
        uint32_t RESERVED1 : 1;        /*!< [19]  */
        uint32_t ADMAS : 1;            /*!< [20] ADMA Support */
        uint32_t HSS : 1;              /*!< [21] High Speed Support */
        uint32_t DMAS : 1;             /*!< [22] DMA Support */
        uint32_t SRS : 1;              /*!< [23] Suspend/Resume Support */
        uint32_t VS33 : 1;             /*!< [24] Voltage Support 3.3 V */
        uint32_t RESERVED2 : 7;        /*!< [31:25]  */
    } B;
} hw_sdhc_htcapblt_t;

/*!
 * @name Constants and macros for entire SDHC_HTCAPBLT register
 */
/*@{*/
#define HW_SDHC_HTCAPBLT_ADDR(x) ((x) + 0x40U)

#define HW_SDHC_HTCAPBLT(x)      (*(__I hw_sdhc_htcapblt_t *) HW_SDHC_HTCAPBLT_ADDR(x))
#define HW_SDHC_HTCAPBLT_RD(x)   (HW_SDHC_HTCAPBLT(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_HTCAPBLT bitfields
 */

/*!
 * @name Register SDHC_HTCAPBLT, field MBL[18:16] (RO)
 *
 * This value indicates the maximum block size that the host driver can read and
 * write to the buffer in the SDHC. The buffer shall transfer block size without
 * wait cycles.
 *
 * Values:
 * - 000 - 512 bytes
 * - 001 - 1024 bytes
 * - 010 - 2048 bytes
 * - 011 - 4096 bytes
 */
/*@{*/
#define BP_SDHC_HTCAPBLT_MBL (16U)         /*!< Bit position for SDHC_HTCAPBLT_MBL. */
#define BM_SDHC_HTCAPBLT_MBL (0x00070000U) /*!< Bit mask for SDHC_HTCAPBLT_MBL. */
#define BS_SDHC_HTCAPBLT_MBL (3U)          /*!< Bit field size in bits for SDHC_HTCAPBLT_MBL. */

/*! @brief Read current value of the SDHC_HTCAPBLT_MBL field. */
#define BR_SDHC_HTCAPBLT_MBL(x) (HW_SDHC_HTCAPBLT(x).B.MBL)
/*@}*/

/*!
 * @name Register SDHC_HTCAPBLT, field ADMAS[20] (RO)
 *
 * This bit indicates whether the SDHC supports the ADMA feature.
 *
 * Values:
 * - 0 - Advanced DMA not supported.
 * - 1 - Advanced DMA supported.
 */
/*@{*/
#define BP_SDHC_HTCAPBLT_ADMAS (20U)       /*!< Bit position for SDHC_HTCAPBLT_ADMAS. */
#define BM_SDHC_HTCAPBLT_ADMAS (0x00100000U) /*!< Bit mask for SDHC_HTCAPBLT_ADMAS. */
#define BS_SDHC_HTCAPBLT_ADMAS (1U)        /*!< Bit field size in bits for SDHC_HTCAPBLT_ADMAS. */

/*! @brief Read current value of the SDHC_HTCAPBLT_ADMAS field. */
#define BR_SDHC_HTCAPBLT_ADMAS(x) (BITBAND_ACCESS32(HW_SDHC_HTCAPBLT_ADDR(x), BP_SDHC_HTCAPBLT_ADMAS))
/*@}*/

/*!
 * @name Register SDHC_HTCAPBLT, field HSS[21] (RO)
 *
 * This bit indicates whether the SDHC supports high speed mode and the host
 * system can supply a SD Clock frequency from 25 MHz to 50 MHz.
 *
 * Values:
 * - 0 - High speed not supported.
 * - 1 - High speed supported.
 */
/*@{*/
#define BP_SDHC_HTCAPBLT_HSS (21U)         /*!< Bit position for SDHC_HTCAPBLT_HSS. */
#define BM_SDHC_HTCAPBLT_HSS (0x00200000U) /*!< Bit mask for SDHC_HTCAPBLT_HSS. */
#define BS_SDHC_HTCAPBLT_HSS (1U)          /*!< Bit field size in bits for SDHC_HTCAPBLT_HSS. */

/*! @brief Read current value of the SDHC_HTCAPBLT_HSS field. */
#define BR_SDHC_HTCAPBLT_HSS(x) (BITBAND_ACCESS32(HW_SDHC_HTCAPBLT_ADDR(x), BP_SDHC_HTCAPBLT_HSS))
/*@}*/

/*!
 * @name Register SDHC_HTCAPBLT, field DMAS[22] (RO)
 *
 * This bit indicates whether the SDHC is capable of using the internal DMA to
 * transfer data between system memory and the data buffer directly.
 *
 * Values:
 * - 0 - DMA not supported.
 * - 1 - DMA supported.
 */
/*@{*/
#define BP_SDHC_HTCAPBLT_DMAS (22U)        /*!< Bit position for SDHC_HTCAPBLT_DMAS. */
#define BM_SDHC_HTCAPBLT_DMAS (0x00400000U) /*!< Bit mask for SDHC_HTCAPBLT_DMAS. */
#define BS_SDHC_HTCAPBLT_DMAS (1U)         /*!< Bit field size in bits for SDHC_HTCAPBLT_DMAS. */

/*! @brief Read current value of the SDHC_HTCAPBLT_DMAS field. */
#define BR_SDHC_HTCAPBLT_DMAS(x) (BITBAND_ACCESS32(HW_SDHC_HTCAPBLT_ADDR(x), BP_SDHC_HTCAPBLT_DMAS))
/*@}*/

/*!
 * @name Register SDHC_HTCAPBLT, field SRS[23] (RO)
 *
 * This bit indicates whether the SDHC supports suspend / resume functionality.
 * If this bit is 0, the suspend and resume mechanism, as well as the read Wwait,
 * are not supported, and the host driver shall not issue either suspend or
 * resume commands.
 *
 * Values:
 * - 0 - Not supported.
 * - 1 - Supported.
 */
/*@{*/
#define BP_SDHC_HTCAPBLT_SRS (23U)         /*!< Bit position for SDHC_HTCAPBLT_SRS. */
#define BM_SDHC_HTCAPBLT_SRS (0x00800000U) /*!< Bit mask for SDHC_HTCAPBLT_SRS. */
#define BS_SDHC_HTCAPBLT_SRS (1U)          /*!< Bit field size in bits for SDHC_HTCAPBLT_SRS. */

/*! @brief Read current value of the SDHC_HTCAPBLT_SRS field. */
#define BR_SDHC_HTCAPBLT_SRS(x) (BITBAND_ACCESS32(HW_SDHC_HTCAPBLT_ADDR(x), BP_SDHC_HTCAPBLT_SRS))
/*@}*/

/*!
 * @name Register SDHC_HTCAPBLT, field VS33[24] (RO)
 *
 * This bit shall depend on the host system ability.
 *
 * Values:
 * - 0 - 3.3 V not supported.
 * - 1 - 3.3 V supported.
 */
/*@{*/
#define BP_SDHC_HTCAPBLT_VS33 (24U)        /*!< Bit position for SDHC_HTCAPBLT_VS33. */
#define BM_SDHC_HTCAPBLT_VS33 (0x01000000U) /*!< Bit mask for SDHC_HTCAPBLT_VS33. */
#define BS_SDHC_HTCAPBLT_VS33 (1U)         /*!< Bit field size in bits for SDHC_HTCAPBLT_VS33. */

/*! @brief Read current value of the SDHC_HTCAPBLT_VS33 field. */
#define BR_SDHC_HTCAPBLT_VS33(x) (BITBAND_ACCESS32(HW_SDHC_HTCAPBLT_ADDR(x), BP_SDHC_HTCAPBLT_VS33))
/*@}*/

/*******************************************************************************
 * HW_SDHC_WML - Watermark Level Register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_WML - Watermark Level Register (RW)
 *
 * Reset value: 0x00100010U
 *
 * Both write and read watermark levels (FIFO threshold) are configurable. There
 * value can range from 1 to 128 words. Both write and read burst lengths are
 * also configurable. There value can range from 1 to 31 words.
 */
typedef union _hw_sdhc_wml
{
    uint32_t U;
    struct _hw_sdhc_wml_bitfields
    {
        uint32_t RDWML : 8;            /*!< [7:0] Read Watermark Level */
        uint32_t RESERVED0 : 8;        /*!< [15:8]  */
        uint32_t WRWML : 8;            /*!< [23:16] Write Watermark Level */
        uint32_t RESERVED1 : 8;        /*!< [31:24]  */
    } B;
} hw_sdhc_wml_t;

/*!
 * @name Constants and macros for entire SDHC_WML register
 */
/*@{*/
#define HW_SDHC_WML_ADDR(x)      ((x) + 0x44U)

#define HW_SDHC_WML(x)           (*(__IO hw_sdhc_wml_t *) HW_SDHC_WML_ADDR(x))
#define HW_SDHC_WML_RD(x)        (HW_SDHC_WML(x).U)
#define HW_SDHC_WML_WR(x, v)     (HW_SDHC_WML(x).U = (v))
#define HW_SDHC_WML_SET(x, v)    (HW_SDHC_WML_WR(x, HW_SDHC_WML_RD(x) |  (v)))
#define HW_SDHC_WML_CLR(x, v)    (HW_SDHC_WML_WR(x, HW_SDHC_WML_RD(x) & ~(v)))
#define HW_SDHC_WML_TOG(x, v)    (HW_SDHC_WML_WR(x, HW_SDHC_WML_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_WML bitfields
 */

/*!
 * @name Register SDHC_WML, field RDWML[7:0] (RW)
 *
 * The number of words used as the watermark level (FIFO threshold) in a DMA
 * read operation. Also the number of words as a sequence of read bursts in
 * back-to-back mode. The maximum legal value for the read water mark level is 128.
 */
/*@{*/
#define BP_SDHC_WML_RDWML    (0U)          /*!< Bit position for SDHC_WML_RDWML. */
#define BM_SDHC_WML_RDWML    (0x000000FFU) /*!< Bit mask for SDHC_WML_RDWML. */
#define BS_SDHC_WML_RDWML    (8U)          /*!< Bit field size in bits for SDHC_WML_RDWML. */

/*! @brief Read current value of the SDHC_WML_RDWML field. */
#define BR_SDHC_WML_RDWML(x) (HW_SDHC_WML(x).B.RDWML)

/*! @brief Format value for bitfield SDHC_WML_RDWML. */
#define BF_SDHC_WML_RDWML(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_WML_RDWML) & BM_SDHC_WML_RDWML)

/*! @brief Set the RDWML field to a new value. */
#define BW_SDHC_WML_RDWML(x, v) (HW_SDHC_WML_WR(x, (HW_SDHC_WML_RD(x) & ~BM_SDHC_WML_RDWML) | BF_SDHC_WML_RDWML(v)))
/*@}*/

/*!
 * @name Register SDHC_WML, field WRWML[23:16] (RW)
 *
 * The number of words used as the watermark level (FIFO threshold) in a DMA
 * write operation. Also the number of words as a sequence of write bursts in
 * back-to-back mode. The maximum legal value for the write watermark level is 128.
 */
/*@{*/
#define BP_SDHC_WML_WRWML    (16U)         /*!< Bit position for SDHC_WML_WRWML. */
#define BM_SDHC_WML_WRWML    (0x00FF0000U) /*!< Bit mask for SDHC_WML_WRWML. */
#define BS_SDHC_WML_WRWML    (8U)          /*!< Bit field size in bits for SDHC_WML_WRWML. */

/*! @brief Read current value of the SDHC_WML_WRWML field. */
#define BR_SDHC_WML_WRWML(x) (HW_SDHC_WML(x).B.WRWML)

/*! @brief Format value for bitfield SDHC_WML_WRWML. */
#define BF_SDHC_WML_WRWML(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_WML_WRWML) & BM_SDHC_WML_WRWML)

/*! @brief Set the WRWML field to a new value. */
#define BW_SDHC_WML_WRWML(x, v) (HW_SDHC_WML_WR(x, (HW_SDHC_WML_RD(x) & ~BM_SDHC_WML_WRWML) | BF_SDHC_WML_WRWML(v)))
/*@}*/

/*******************************************************************************
 * HW_SDHC_FEVT - Force Event register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_FEVT - Force Event register (WO)
 *
 * Reset value: 0x00000000U
 *
 * The Force Event (FEVT) register is not a physically implemented register.
 * Rather, it is an address at which the Interrupt Status register can be written if
 * the corresponding bit of the Interrupt Status Enable register is set. This
 * register is a write only register and writing 0 to it has no effect. Writing 1
 * to this register actually sets the corresponding bit of Interrupt Status
 * register. A read from this register always results in 0's. To change the
 * corresponding status bits in the interrupt status register, make sure to set
 * SYSCTL[IPGEN] so that bus clock is always active. Forcing a card interrupt will generate a
 * short pulse on the DAT[1] line, and the driver may treat this interrupt as a
 * normal interrupt. The interrupt service routine may skip polling the card
 * interrupt factor as the interrupt is selfcleared.
 */
typedef union _hw_sdhc_fevt
{
    uint32_t U;
    struct _hw_sdhc_fevt_bitfields
    {
        uint32_t AC12NE : 1;           /*!< [0] Force Event Auto Command 12 Not
                                        * Executed */
        uint32_t AC12TOE : 1;          /*!< [1] Force Event Auto Command 12 Time Out
                                        * Error */
        uint32_t AC12CE : 1;           /*!< [2] Force Event Auto Command 12 CRC Error */
        uint32_t AC12EBE : 1;          /*!< [3] Force Event Auto Command 12 End Bit
                                        * Error */
        uint32_t AC12IE : 1;           /*!< [4] Force Event Auto Command 12 Index Error
                                        * */
        uint32_t RESERVED0 : 2;        /*!< [6:5]  */
        uint32_t CNIBAC12E : 1;        /*!< [7] Force Event Command Not Executed By
                                        * Auto Command 12 Error */
        uint32_t RESERVED1 : 8;        /*!< [15:8]  */
        uint32_t CTOE : 1;             /*!< [16] Force Event Command Time Out Error */
        uint32_t CCE : 1;              /*!< [17] Force Event Command CRC Error */
        uint32_t CEBE : 1;             /*!< [18] Force Event Command End Bit Error */
        uint32_t CIE : 1;              /*!< [19] Force Event Command Index Error */
        uint32_t DTOE : 1;             /*!< [20] Force Event Data Time Out Error */
        uint32_t DCE : 1;              /*!< [21] Force Event Data CRC Error */
        uint32_t DEBE : 1;             /*!< [22] Force Event Data End Bit Error */
        uint32_t RESERVED2 : 1;        /*!< [23]  */
        uint32_t AC12E : 1;            /*!< [24] Force Event Auto Command 12 Error */
        uint32_t RESERVED3 : 3;        /*!< [27:25]  */
        uint32_t DMAE : 1;             /*!< [28] Force Event DMA Error */
        uint32_t RESERVED4 : 2;        /*!< [30:29]  */
        uint32_t CINT : 1;             /*!< [31] Force Event Card Interrupt */
    } B;
} hw_sdhc_fevt_t;

/*!
 * @name Constants and macros for entire SDHC_FEVT register
 */
/*@{*/
#define HW_SDHC_FEVT_ADDR(x)     ((x) + 0x50U)

#define HW_SDHC_FEVT(x)          (*(__O hw_sdhc_fevt_t *) HW_SDHC_FEVT_ADDR(x))
#define HW_SDHC_FEVT_RD(x)       (HW_SDHC_FEVT(x).U)
#define HW_SDHC_FEVT_WR(x, v)    (HW_SDHC_FEVT(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual SDHC_FEVT bitfields
 */

/*!
 * @name Register SDHC_FEVT, field AC12NE[0] (WORZ)
 *
 * Forces AC12ERR[AC12NE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_AC12NE  (0U)          /*!< Bit position for SDHC_FEVT_AC12NE. */
#define BM_SDHC_FEVT_AC12NE  (0x00000001U) /*!< Bit mask for SDHC_FEVT_AC12NE. */
#define BS_SDHC_FEVT_AC12NE  (1U)          /*!< Bit field size in bits for SDHC_FEVT_AC12NE. */

/*! @brief Format value for bitfield SDHC_FEVT_AC12NE. */
#define BF_SDHC_FEVT_AC12NE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_AC12NE) & BM_SDHC_FEVT_AC12NE)

/*! @brief Set the AC12NE field to a new value. */
#define BW_SDHC_FEVT_AC12NE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_AC12NE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field AC12TOE[1] (WORZ)
 *
 * Forces AC12ERR[AC12TOE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_AC12TOE (1U)          /*!< Bit position for SDHC_FEVT_AC12TOE. */
#define BM_SDHC_FEVT_AC12TOE (0x00000002U) /*!< Bit mask for SDHC_FEVT_AC12TOE. */
#define BS_SDHC_FEVT_AC12TOE (1U)          /*!< Bit field size in bits for SDHC_FEVT_AC12TOE. */

/*! @brief Format value for bitfield SDHC_FEVT_AC12TOE. */
#define BF_SDHC_FEVT_AC12TOE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_AC12TOE) & BM_SDHC_FEVT_AC12TOE)

/*! @brief Set the AC12TOE field to a new value. */
#define BW_SDHC_FEVT_AC12TOE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_AC12TOE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field AC12CE[2] (WORZ)
 *
 * Forces AC12ERR[AC12CE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_AC12CE  (2U)          /*!< Bit position for SDHC_FEVT_AC12CE. */
#define BM_SDHC_FEVT_AC12CE  (0x00000004U) /*!< Bit mask for SDHC_FEVT_AC12CE. */
#define BS_SDHC_FEVT_AC12CE  (1U)          /*!< Bit field size in bits for SDHC_FEVT_AC12CE. */

/*! @brief Format value for bitfield SDHC_FEVT_AC12CE. */
#define BF_SDHC_FEVT_AC12CE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_AC12CE) & BM_SDHC_FEVT_AC12CE)

/*! @brief Set the AC12CE field to a new value. */
#define BW_SDHC_FEVT_AC12CE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_AC12CE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field AC12EBE[3] (WORZ)
 *
 * Forces AC12ERR[AC12EBE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_AC12EBE (3U)          /*!< Bit position for SDHC_FEVT_AC12EBE. */
#define BM_SDHC_FEVT_AC12EBE (0x00000008U) /*!< Bit mask for SDHC_FEVT_AC12EBE. */
#define BS_SDHC_FEVT_AC12EBE (1U)          /*!< Bit field size in bits for SDHC_FEVT_AC12EBE. */

/*! @brief Format value for bitfield SDHC_FEVT_AC12EBE. */
#define BF_SDHC_FEVT_AC12EBE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_AC12EBE) & BM_SDHC_FEVT_AC12EBE)

/*! @brief Set the AC12EBE field to a new value. */
#define BW_SDHC_FEVT_AC12EBE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_AC12EBE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field AC12IE[4] (WORZ)
 *
 * Forces AC12ERR[AC12IE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_AC12IE  (4U)          /*!< Bit position for SDHC_FEVT_AC12IE. */
#define BM_SDHC_FEVT_AC12IE  (0x00000010U) /*!< Bit mask for SDHC_FEVT_AC12IE. */
#define BS_SDHC_FEVT_AC12IE  (1U)          /*!< Bit field size in bits for SDHC_FEVT_AC12IE. */

/*! @brief Format value for bitfield SDHC_FEVT_AC12IE. */
#define BF_SDHC_FEVT_AC12IE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_AC12IE) & BM_SDHC_FEVT_AC12IE)

/*! @brief Set the AC12IE field to a new value. */
#define BW_SDHC_FEVT_AC12IE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_AC12IE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field CNIBAC12E[7] (WORZ)
 *
 * Forces AC12ERR[CNIBAC12E] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_CNIBAC12E (7U)        /*!< Bit position for SDHC_FEVT_CNIBAC12E. */
#define BM_SDHC_FEVT_CNIBAC12E (0x00000080U) /*!< Bit mask for SDHC_FEVT_CNIBAC12E. */
#define BS_SDHC_FEVT_CNIBAC12E (1U)        /*!< Bit field size in bits for SDHC_FEVT_CNIBAC12E. */

/*! @brief Format value for bitfield SDHC_FEVT_CNIBAC12E. */
#define BF_SDHC_FEVT_CNIBAC12E(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_CNIBAC12E) & BM_SDHC_FEVT_CNIBAC12E)

/*! @brief Set the CNIBAC12E field to a new value. */
#define BW_SDHC_FEVT_CNIBAC12E(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_CNIBAC12E) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field CTOE[16] (WORZ)
 *
 * Forces IRQSTAT[CTOE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_CTOE    (16U)         /*!< Bit position for SDHC_FEVT_CTOE. */
#define BM_SDHC_FEVT_CTOE    (0x00010000U) /*!< Bit mask for SDHC_FEVT_CTOE. */
#define BS_SDHC_FEVT_CTOE    (1U)          /*!< Bit field size in bits for SDHC_FEVT_CTOE. */

/*! @brief Format value for bitfield SDHC_FEVT_CTOE. */
#define BF_SDHC_FEVT_CTOE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_CTOE) & BM_SDHC_FEVT_CTOE)

/*! @brief Set the CTOE field to a new value. */
#define BW_SDHC_FEVT_CTOE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_CTOE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field CCE[17] (WORZ)
 *
 * Forces IRQSTAT[CCE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_CCE     (17U)         /*!< Bit position for SDHC_FEVT_CCE. */
#define BM_SDHC_FEVT_CCE     (0x00020000U) /*!< Bit mask for SDHC_FEVT_CCE. */
#define BS_SDHC_FEVT_CCE     (1U)          /*!< Bit field size in bits for SDHC_FEVT_CCE. */

/*! @brief Format value for bitfield SDHC_FEVT_CCE. */
#define BF_SDHC_FEVT_CCE(v)  ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_CCE) & BM_SDHC_FEVT_CCE)

/*! @brief Set the CCE field to a new value. */
#define BW_SDHC_FEVT_CCE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_CCE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field CEBE[18] (WORZ)
 *
 * Forces IRQSTAT[CEBE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_CEBE    (18U)         /*!< Bit position for SDHC_FEVT_CEBE. */
#define BM_SDHC_FEVT_CEBE    (0x00040000U) /*!< Bit mask for SDHC_FEVT_CEBE. */
#define BS_SDHC_FEVT_CEBE    (1U)          /*!< Bit field size in bits for SDHC_FEVT_CEBE. */

/*! @brief Format value for bitfield SDHC_FEVT_CEBE. */
#define BF_SDHC_FEVT_CEBE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_CEBE) & BM_SDHC_FEVT_CEBE)

/*! @brief Set the CEBE field to a new value. */
#define BW_SDHC_FEVT_CEBE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_CEBE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field CIE[19] (WORZ)
 *
 * Forces IRQSTAT[CCE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_CIE     (19U)         /*!< Bit position for SDHC_FEVT_CIE. */
#define BM_SDHC_FEVT_CIE     (0x00080000U) /*!< Bit mask for SDHC_FEVT_CIE. */
#define BS_SDHC_FEVT_CIE     (1U)          /*!< Bit field size in bits for SDHC_FEVT_CIE. */

/*! @brief Format value for bitfield SDHC_FEVT_CIE. */
#define BF_SDHC_FEVT_CIE(v)  ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_CIE) & BM_SDHC_FEVT_CIE)

/*! @brief Set the CIE field to a new value. */
#define BW_SDHC_FEVT_CIE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_CIE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field DTOE[20] (WORZ)
 *
 * Forces IRQSTAT[DTOE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_DTOE    (20U)         /*!< Bit position for SDHC_FEVT_DTOE. */
#define BM_SDHC_FEVT_DTOE    (0x00100000U) /*!< Bit mask for SDHC_FEVT_DTOE. */
#define BS_SDHC_FEVT_DTOE    (1U)          /*!< Bit field size in bits for SDHC_FEVT_DTOE. */

/*! @brief Format value for bitfield SDHC_FEVT_DTOE. */
#define BF_SDHC_FEVT_DTOE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_DTOE) & BM_SDHC_FEVT_DTOE)

/*! @brief Set the DTOE field to a new value. */
#define BW_SDHC_FEVT_DTOE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_DTOE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field DCE[21] (WORZ)
 *
 * Forces IRQSTAT[DCE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_DCE     (21U)         /*!< Bit position for SDHC_FEVT_DCE. */
#define BM_SDHC_FEVT_DCE     (0x00200000U) /*!< Bit mask for SDHC_FEVT_DCE. */
#define BS_SDHC_FEVT_DCE     (1U)          /*!< Bit field size in bits for SDHC_FEVT_DCE. */

/*! @brief Format value for bitfield SDHC_FEVT_DCE. */
#define BF_SDHC_FEVT_DCE(v)  ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_DCE) & BM_SDHC_FEVT_DCE)

/*! @brief Set the DCE field to a new value. */
#define BW_SDHC_FEVT_DCE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_DCE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field DEBE[22] (WORZ)
 *
 * Forces IRQSTAT[DEBE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_DEBE    (22U)         /*!< Bit position for SDHC_FEVT_DEBE. */
#define BM_SDHC_FEVT_DEBE    (0x00400000U) /*!< Bit mask for SDHC_FEVT_DEBE. */
#define BS_SDHC_FEVT_DEBE    (1U)          /*!< Bit field size in bits for SDHC_FEVT_DEBE. */

/*! @brief Format value for bitfield SDHC_FEVT_DEBE. */
#define BF_SDHC_FEVT_DEBE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_DEBE) & BM_SDHC_FEVT_DEBE)

/*! @brief Set the DEBE field to a new value. */
#define BW_SDHC_FEVT_DEBE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_DEBE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field AC12E[24] (WORZ)
 *
 * Forces IRQSTAT[AC12E] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_AC12E   (24U)         /*!< Bit position for SDHC_FEVT_AC12E. */
#define BM_SDHC_FEVT_AC12E   (0x01000000U) /*!< Bit mask for SDHC_FEVT_AC12E. */
#define BS_SDHC_FEVT_AC12E   (1U)          /*!< Bit field size in bits for SDHC_FEVT_AC12E. */

/*! @brief Format value for bitfield SDHC_FEVT_AC12E. */
#define BF_SDHC_FEVT_AC12E(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_AC12E) & BM_SDHC_FEVT_AC12E)

/*! @brief Set the AC12E field to a new value. */
#define BW_SDHC_FEVT_AC12E(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_AC12E) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field DMAE[28] (WORZ)
 *
 * Forces the DMAE bit of Interrupt Status Register to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_DMAE    (28U)         /*!< Bit position for SDHC_FEVT_DMAE. */
#define BM_SDHC_FEVT_DMAE    (0x10000000U) /*!< Bit mask for SDHC_FEVT_DMAE. */
#define BS_SDHC_FEVT_DMAE    (1U)          /*!< Bit field size in bits for SDHC_FEVT_DMAE. */

/*! @brief Format value for bitfield SDHC_FEVT_DMAE. */
#define BF_SDHC_FEVT_DMAE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_DMAE) & BM_SDHC_FEVT_DMAE)

/*! @brief Set the DMAE field to a new value. */
#define BW_SDHC_FEVT_DMAE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_DMAE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field CINT[31] (WORZ)
 *
 * Writing 1 to this bit generates a short low-level pulse on the internal
 * DAT[1] line, as if a self-clearing interrupt was received from the external card.
 * If enabled, the CINT bit will be set and the interrupt service routine may
 * treat this interrupt as a normal interrupt from the external card.
 */
/*@{*/
#define BP_SDHC_FEVT_CINT    (31U)         /*!< Bit position for SDHC_FEVT_CINT. */
#define BM_SDHC_FEVT_CINT    (0x80000000U) /*!< Bit mask for SDHC_FEVT_CINT. */
#define BS_SDHC_FEVT_CINT    (1U)          /*!< Bit field size in bits for SDHC_FEVT_CINT. */

/*! @brief Format value for bitfield SDHC_FEVT_CINT. */
#define BF_SDHC_FEVT_CINT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_CINT) & BM_SDHC_FEVT_CINT)

/*! @brief Set the CINT field to a new value. */
#define BW_SDHC_FEVT_CINT(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_CINT) = (v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_ADMAES - ADMA Error Status register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_ADMAES - ADMA Error Status register (RO)
 *
 * Reset value: 0x00000000U
 *
 * When an ADMA error interrupt has occurred, the ADMA Error States field in
 * this register holds the ADMA state and the ADMA System Address register holds the
 * address around the error descriptor. For recovering from this error, the host
 * driver requires the ADMA state to identify the error descriptor address as
 * follows: ST_STOP: Previous location set in the ADMA System Address register is
 * the error descriptor address. ST_FDS: Current location set in the ADMA System
 * Address register is the error descriptor address. ST_CADR: This state is never
 * set because it only increments the descriptor pointer and doesn't generate an
 * ADMA error. ST_TFR: Previous location set in the ADMA System Address register
 * is the error descriptor address. In case of a write operation, the host driver
 * must use the ACMD22 to get the number of the written block, rather than using
 * this information, because unwritten data may exist in the host controller.
 * The host controller generates the ADMA error interrupt when it detects invalid
 * descriptor data (valid = 0) in the ST_FDS state. The host driver can
 * distinguish this error by reading the valid bit of the error descriptor. ADMA Error
 * State coding D01-D00 ADMA Error State when error has occurred Contents of ADMA
 * System Address register 00 ST_STOP (Stop DMA) Holds the address of the next
 * executable descriptor command 01 ST_FDS (fetch descriptor) Holds the valid
 * descriptor address 10 ST_CADR (change address) No ADMA error is generated 11 ST_TFR
 * (Transfer Data) Holds the address of the next executable descriptor command
 */
typedef union _hw_sdhc_admaes
{
    uint32_t U;
    struct _hw_sdhc_admaes_bitfields
    {
        uint32_t ADMAES : 2;           /*!< [1:0] ADMA Error State (When ADMA Error Is
                                        * Occurred.) */
        uint32_t ADMALME : 1;          /*!< [2] ADMA Length Mismatch Error */
        uint32_t ADMADCE : 1;          /*!< [3] ADMA Descriptor Error */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_sdhc_admaes_t;

/*!
 * @name Constants and macros for entire SDHC_ADMAES register
 */
/*@{*/
#define HW_SDHC_ADMAES_ADDR(x)   ((x) + 0x54U)

#define HW_SDHC_ADMAES(x)        (*(__I hw_sdhc_admaes_t *) HW_SDHC_ADMAES_ADDR(x))
#define HW_SDHC_ADMAES_RD(x)     (HW_SDHC_ADMAES(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_ADMAES bitfields
 */

/*!
 * @name Register SDHC_ADMAES, field ADMAES[1:0] (RO)
 *
 * Indicates the state of the ADMA when an error has occurred during an ADMA
 * data transfer.
 */
/*@{*/
#define BP_SDHC_ADMAES_ADMAES (0U)         /*!< Bit position for SDHC_ADMAES_ADMAES. */
#define BM_SDHC_ADMAES_ADMAES (0x00000003U) /*!< Bit mask for SDHC_ADMAES_ADMAES. */
#define BS_SDHC_ADMAES_ADMAES (2U)         /*!< Bit field size in bits for SDHC_ADMAES_ADMAES. */

/*! @brief Read current value of the SDHC_ADMAES_ADMAES field. */
#define BR_SDHC_ADMAES_ADMAES(x) (HW_SDHC_ADMAES(x).B.ADMAES)
/*@}*/

/*!
 * @name Register SDHC_ADMAES, field ADMALME[2] (RO)
 *
 * This error occurs in the following 2 cases: While the block count enable is
 * being set, the total data length specified by the descriptor table is different
 * from that specified by the block count and block length. Total data length
 * can not be divided by the block length.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_ADMAES_ADMALME (2U)        /*!< Bit position for SDHC_ADMAES_ADMALME. */
#define BM_SDHC_ADMAES_ADMALME (0x00000004U) /*!< Bit mask for SDHC_ADMAES_ADMALME. */
#define BS_SDHC_ADMAES_ADMALME (1U)        /*!< Bit field size in bits for SDHC_ADMAES_ADMALME. */

/*! @brief Read current value of the SDHC_ADMAES_ADMALME field. */
#define BR_SDHC_ADMAES_ADMALME(x) (BITBAND_ACCESS32(HW_SDHC_ADMAES_ADDR(x), BP_SDHC_ADMAES_ADMALME))
/*@}*/

/*!
 * @name Register SDHC_ADMAES, field ADMADCE[3] (RO)
 *
 * This error occurs when an invalid descriptor is fetched by ADMA.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_ADMAES_ADMADCE (3U)        /*!< Bit position for SDHC_ADMAES_ADMADCE. */
#define BM_SDHC_ADMAES_ADMADCE (0x00000008U) /*!< Bit mask for SDHC_ADMAES_ADMADCE. */
#define BS_SDHC_ADMAES_ADMADCE (1U)        /*!< Bit field size in bits for SDHC_ADMAES_ADMADCE. */

/*! @brief Read current value of the SDHC_ADMAES_ADMADCE field. */
#define BR_SDHC_ADMAES_ADMADCE(x) (BITBAND_ACCESS32(HW_SDHC_ADMAES_ADDR(x), BP_SDHC_ADMAES_ADMADCE))
/*@}*/

/*******************************************************************************
 * HW_SDHC_ADSADDR - ADMA System Addressregister
 ******************************************************************************/

/*!
 * @brief HW_SDHC_ADSADDR - ADMA System Addressregister (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the physical system memory address used for ADMA
 * transfers.
 */
typedef union _hw_sdhc_adsaddr
{
    uint32_t U;
    struct _hw_sdhc_adsaddr_bitfields
    {
        uint32_t RESERVED0 : 2;        /*!< [1:0]  */
        uint32_t ADSADDR : 30;         /*!< [31:2] ADMA System Address */
    } B;
} hw_sdhc_adsaddr_t;

/*!
 * @name Constants and macros for entire SDHC_ADSADDR register
 */
/*@{*/
#define HW_SDHC_ADSADDR_ADDR(x)  ((x) + 0x58U)

#define HW_SDHC_ADSADDR(x)       (*(__IO hw_sdhc_adsaddr_t *) HW_SDHC_ADSADDR_ADDR(x))
#define HW_SDHC_ADSADDR_RD(x)    (HW_SDHC_ADSADDR(x).U)
#define HW_SDHC_ADSADDR_WR(x, v) (HW_SDHC_ADSADDR(x).U = (v))
#define HW_SDHC_ADSADDR_SET(x, v) (HW_SDHC_ADSADDR_WR(x, HW_SDHC_ADSADDR_RD(x) |  (v)))
#define HW_SDHC_ADSADDR_CLR(x, v) (HW_SDHC_ADSADDR_WR(x, HW_SDHC_ADSADDR_RD(x) & ~(v)))
#define HW_SDHC_ADSADDR_TOG(x, v) (HW_SDHC_ADSADDR_WR(x, HW_SDHC_ADSADDR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_ADSADDR bitfields
 */

/*!
 * @name Register SDHC_ADSADDR, field ADSADDR[31:2] (RW)
 *
 * Holds the word address of the executing command in the descriptor table. At
 * the start of ADMA, the host driver shall set the start address of the
 * Descriptor table. The ADMA engine increments this register address whenever fetching a
 * descriptor command. When the ADMA is stopped at the block gap, this register
 * indicates the address of the next executable descriptor command. When the ADMA
 * error interrupt is generated, this register shall hold the valid descriptor
 * address depending on the ADMA state. The lower 2 bits of this register is tied
 * to '0' so the ADMA address is always word-aligned. Because this register
 * supports dynamic address reflecting, when TC bit is set, it automatically alters the
 * value of internal address counter, so SW cannot change this register when TC
 * bit is set.
 */
/*@{*/
#define BP_SDHC_ADSADDR_ADSADDR (2U)       /*!< Bit position for SDHC_ADSADDR_ADSADDR. */
#define BM_SDHC_ADSADDR_ADSADDR (0xFFFFFFFCU) /*!< Bit mask for SDHC_ADSADDR_ADSADDR. */
#define BS_SDHC_ADSADDR_ADSADDR (30U)      /*!< Bit field size in bits for SDHC_ADSADDR_ADSADDR. */

/*! @brief Read current value of the SDHC_ADSADDR_ADSADDR field. */
#define BR_SDHC_ADSADDR_ADSADDR(x) (HW_SDHC_ADSADDR(x).B.ADSADDR)

/*! @brief Format value for bitfield SDHC_ADSADDR_ADSADDR. */
#define BF_SDHC_ADSADDR_ADSADDR(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_ADSADDR_ADSADDR) & BM_SDHC_ADSADDR_ADSADDR)

/*! @brief Set the ADSADDR field to a new value. */
#define BW_SDHC_ADSADDR_ADSADDR(x, v) (HW_SDHC_ADSADDR_WR(x, (HW_SDHC_ADSADDR_RD(x) & ~BM_SDHC_ADSADDR_ADSADDR) | BF_SDHC_ADSADDR_ADSADDR(v)))
/*@}*/

/*******************************************************************************
 * HW_SDHC_VENDOR - Vendor Specific register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_VENDOR - Vendor Specific register (RW)
 *
 * Reset value: 0x00000001U
 *
 * This register contains the vendor-specific control/status register.
 */
typedef union _hw_sdhc_vendor
{
    uint32_t U;
    struct _hw_sdhc_vendor_bitfields
    {
        uint32_t EXTDMAEN : 1;         /*!< [0] External DMA Request Enable */
        uint32_t EXBLKNU : 1;          /*!< [1] Exact Block Number Block Read Enable
                                        * For SDIO CMD53 */
        uint32_t RESERVED0 : 14;       /*!< [15:2]  */
        uint32_t INTSTVAL : 8;         /*!< [23:16] Internal State Value */
        uint32_t RESERVED1 : 8;        /*!< [31:24]  */
    } B;
} hw_sdhc_vendor_t;

/*!
 * @name Constants and macros for entire SDHC_VENDOR register
 */
/*@{*/
#define HW_SDHC_VENDOR_ADDR(x)   ((x) + 0xC0U)

#define HW_SDHC_VENDOR(x)        (*(__IO hw_sdhc_vendor_t *) HW_SDHC_VENDOR_ADDR(x))
#define HW_SDHC_VENDOR_RD(x)     (HW_SDHC_VENDOR(x).U)
#define HW_SDHC_VENDOR_WR(x, v)  (HW_SDHC_VENDOR(x).U = (v))
#define HW_SDHC_VENDOR_SET(x, v) (HW_SDHC_VENDOR_WR(x, HW_SDHC_VENDOR_RD(x) |  (v)))
#define HW_SDHC_VENDOR_CLR(x, v) (HW_SDHC_VENDOR_WR(x, HW_SDHC_VENDOR_RD(x) & ~(v)))
#define HW_SDHC_VENDOR_TOG(x, v) (HW_SDHC_VENDOR_WR(x, HW_SDHC_VENDOR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_VENDOR bitfields
 */

/*!
 * @name Register SDHC_VENDOR, field EXTDMAEN[0] (RW)
 *
 * Enables the request to external DMA. When the internal DMA (either simple DMA
 * or advanced DMA) is not in use, and this bit is set, SDHC will send out DMA
 * request when the internal buffer is ready. This bit is particularly useful when
 * transferring data by CPU polling mode, and it is not allowed to send out the
 * external DMA request. By default, this bit is set.
 *
 * Values:
 * - 0 - In any scenario, SDHC does not send out the external DMA request.
 * - 1 - When internal DMA is not active, the external DMA request will be sent
 *     out.
 */
/*@{*/
#define BP_SDHC_VENDOR_EXTDMAEN (0U)       /*!< Bit position for SDHC_VENDOR_EXTDMAEN. */
#define BM_SDHC_VENDOR_EXTDMAEN (0x00000001U) /*!< Bit mask for SDHC_VENDOR_EXTDMAEN. */
#define BS_SDHC_VENDOR_EXTDMAEN (1U)       /*!< Bit field size in bits for SDHC_VENDOR_EXTDMAEN. */

/*! @brief Read current value of the SDHC_VENDOR_EXTDMAEN field. */
#define BR_SDHC_VENDOR_EXTDMAEN(x) (BITBAND_ACCESS32(HW_SDHC_VENDOR_ADDR(x), BP_SDHC_VENDOR_EXTDMAEN))

/*! @brief Format value for bitfield SDHC_VENDOR_EXTDMAEN. */
#define BF_SDHC_VENDOR_EXTDMAEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_VENDOR_EXTDMAEN) & BM_SDHC_VENDOR_EXTDMAEN)

/*! @brief Set the EXTDMAEN field to a new value. */
#define BW_SDHC_VENDOR_EXTDMAEN(x, v) (BITBAND_ACCESS32(HW_SDHC_VENDOR_ADDR(x), BP_SDHC_VENDOR_EXTDMAEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_VENDOR, field EXBLKNU[1] (RW)
 *
 * This bit must be set before S/W issues CMD53 multi-block read with exact
 * block number. This bit must not be set if the CMD53 multi-block read is not exact
 * block number.
 *
 * Values:
 * - 0 - None exact block read.
 * - 1 - Exact block read for SDIO CMD53.
 */
/*@{*/
#define BP_SDHC_VENDOR_EXBLKNU (1U)        /*!< Bit position for SDHC_VENDOR_EXBLKNU. */
#define BM_SDHC_VENDOR_EXBLKNU (0x00000002U) /*!< Bit mask for SDHC_VENDOR_EXBLKNU. */
#define BS_SDHC_VENDOR_EXBLKNU (1U)        /*!< Bit field size in bits for SDHC_VENDOR_EXBLKNU. */

/*! @brief Read current value of the SDHC_VENDOR_EXBLKNU field. */
#define BR_SDHC_VENDOR_EXBLKNU(x) (BITBAND_ACCESS32(HW_SDHC_VENDOR_ADDR(x), BP_SDHC_VENDOR_EXBLKNU))

/*! @brief Format value for bitfield SDHC_VENDOR_EXBLKNU. */
#define BF_SDHC_VENDOR_EXBLKNU(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_VENDOR_EXBLKNU) & BM_SDHC_VENDOR_EXBLKNU)

/*! @brief Set the EXBLKNU field to a new value. */
#define BW_SDHC_VENDOR_EXBLKNU(x, v) (BITBAND_ACCESS32(HW_SDHC_VENDOR_ADDR(x), BP_SDHC_VENDOR_EXBLKNU) = (v))
/*@}*/

/*!
 * @name Register SDHC_VENDOR, field INTSTVAL[23:16] (RO)
 *
 * Internal state value, reflecting the corresponding state value selected by
 * Debug Select field. This field is read-only and write to this field does not
 * have effect.
 */
/*@{*/
#define BP_SDHC_VENDOR_INTSTVAL (16U)      /*!< Bit position for SDHC_VENDOR_INTSTVAL. */
#define BM_SDHC_VENDOR_INTSTVAL (0x00FF0000U) /*!< Bit mask for SDHC_VENDOR_INTSTVAL. */
#define BS_SDHC_VENDOR_INTSTVAL (8U)       /*!< Bit field size in bits for SDHC_VENDOR_INTSTVAL. */

/*! @brief Read current value of the SDHC_VENDOR_INTSTVAL field. */
#define BR_SDHC_VENDOR_INTSTVAL(x) (HW_SDHC_VENDOR(x).B.INTSTVAL)
/*@}*/

/*******************************************************************************
 * HW_SDHC_MMCBOOT - MMC Boot register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_MMCBOOT - MMC Boot register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the MMC fast boot control register.
 */
typedef union _hw_sdhc_mmcboot
{
    uint32_t U;
    struct _hw_sdhc_mmcboot_bitfields
    {
        uint32_t DTOCVACK : 4;         /*!< [3:0] Boot ACK Time Out Counter Value */
        uint32_t BOOTACK : 1;          /*!< [4] Boot Ack Mode Select */
        uint32_t BOOTMODE : 1;         /*!< [5] Boot Mode Select */
        uint32_t BOOTEN : 1;           /*!< [6] Boot Mode Enable */
        uint32_t AUTOSABGEN : 1;       /*!< [7]  */
        uint32_t RESERVED0 : 8;        /*!< [15:8]  */
        uint32_t BOOTBLKCNT : 16;      /*!< [31:16]  */
    } B;
} hw_sdhc_mmcboot_t;

/*!
 * @name Constants and macros for entire SDHC_MMCBOOT register
 */
/*@{*/
#define HW_SDHC_MMCBOOT_ADDR(x)  ((x) + 0xC4U)

#define HW_SDHC_MMCBOOT(x)       (*(__IO hw_sdhc_mmcboot_t *) HW_SDHC_MMCBOOT_ADDR(x))
#define HW_SDHC_MMCBOOT_RD(x)    (HW_SDHC_MMCBOOT(x).U)
#define HW_SDHC_MMCBOOT_WR(x, v) (HW_SDHC_MMCBOOT(x).U = (v))
#define HW_SDHC_MMCBOOT_SET(x, v) (HW_SDHC_MMCBOOT_WR(x, HW_SDHC_MMCBOOT_RD(x) |  (v)))
#define HW_SDHC_MMCBOOT_CLR(x, v) (HW_SDHC_MMCBOOT_WR(x, HW_SDHC_MMCBOOT_RD(x) & ~(v)))
#define HW_SDHC_MMCBOOT_TOG(x, v) (HW_SDHC_MMCBOOT_WR(x, HW_SDHC_MMCBOOT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_MMCBOOT bitfields
 */

/*!
 * @name Register SDHC_MMCBOOT, field DTOCVACK[3:0] (RW)
 *
 * Values:
 * - 0000 - SDCLK x 2^8
 * - 0001 - SDCLK x 2^9
 * - 0010 - SDCLK x 2^10
 * - 0011 - SDCLK x 2^11
 * - 0100 - SDCLK x 2^12
 * - 0101 - SDCLK x 2^13
 * - 0110 - SDCLK x 2^14
 * - 0111 - SDCLK x 2^15
 * - 1110 - SDCLK x 2^22
 * - 1111 - Reserved
 */
/*@{*/
#define BP_SDHC_MMCBOOT_DTOCVACK (0U)      /*!< Bit position for SDHC_MMCBOOT_DTOCVACK. */
#define BM_SDHC_MMCBOOT_DTOCVACK (0x0000000FU) /*!< Bit mask for SDHC_MMCBOOT_DTOCVACK. */
#define BS_SDHC_MMCBOOT_DTOCVACK (4U)      /*!< Bit field size in bits for SDHC_MMCBOOT_DTOCVACK. */

/*! @brief Read current value of the SDHC_MMCBOOT_DTOCVACK field. */
#define BR_SDHC_MMCBOOT_DTOCVACK(x) (HW_SDHC_MMCBOOT(x).B.DTOCVACK)

/*! @brief Format value for bitfield SDHC_MMCBOOT_DTOCVACK. */
#define BF_SDHC_MMCBOOT_DTOCVACK(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_MMCBOOT_DTOCVACK) & BM_SDHC_MMCBOOT_DTOCVACK)

/*! @brief Set the DTOCVACK field to a new value. */
#define BW_SDHC_MMCBOOT_DTOCVACK(x, v) (HW_SDHC_MMCBOOT_WR(x, (HW_SDHC_MMCBOOT_RD(x) & ~BM_SDHC_MMCBOOT_DTOCVACK) | BF_SDHC_MMCBOOT_DTOCVACK(v)))
/*@}*/

/*!
 * @name Register SDHC_MMCBOOT, field BOOTACK[4] (RW)
 *
 * Values:
 * - 0 - No ack.
 * - 1 - Ack.
 */
/*@{*/
#define BP_SDHC_MMCBOOT_BOOTACK (4U)       /*!< Bit position for SDHC_MMCBOOT_BOOTACK. */
#define BM_SDHC_MMCBOOT_BOOTACK (0x00000010U) /*!< Bit mask for SDHC_MMCBOOT_BOOTACK. */
#define BS_SDHC_MMCBOOT_BOOTACK (1U)       /*!< Bit field size in bits for SDHC_MMCBOOT_BOOTACK. */

/*! @brief Read current value of the SDHC_MMCBOOT_BOOTACK field. */
#define BR_SDHC_MMCBOOT_BOOTACK(x) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_BOOTACK))

/*! @brief Format value for bitfield SDHC_MMCBOOT_BOOTACK. */
#define BF_SDHC_MMCBOOT_BOOTACK(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_MMCBOOT_BOOTACK) & BM_SDHC_MMCBOOT_BOOTACK)

/*! @brief Set the BOOTACK field to a new value. */
#define BW_SDHC_MMCBOOT_BOOTACK(x, v) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_BOOTACK) = (v))
/*@}*/

/*!
 * @name Register SDHC_MMCBOOT, field BOOTMODE[5] (RW)
 *
 * Values:
 * - 0 - Normal boot.
 * - 1 - Alternative boot.
 */
/*@{*/
#define BP_SDHC_MMCBOOT_BOOTMODE (5U)      /*!< Bit position for SDHC_MMCBOOT_BOOTMODE. */
#define BM_SDHC_MMCBOOT_BOOTMODE (0x00000020U) /*!< Bit mask for SDHC_MMCBOOT_BOOTMODE. */
#define BS_SDHC_MMCBOOT_BOOTMODE (1U)      /*!< Bit field size in bits for SDHC_MMCBOOT_BOOTMODE. */

/*! @brief Read current value of the SDHC_MMCBOOT_BOOTMODE field. */
#define BR_SDHC_MMCBOOT_BOOTMODE(x) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_BOOTMODE))

/*! @brief Format value for bitfield SDHC_MMCBOOT_BOOTMODE. */
#define BF_SDHC_MMCBOOT_BOOTMODE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_MMCBOOT_BOOTMODE) & BM_SDHC_MMCBOOT_BOOTMODE)

/*! @brief Set the BOOTMODE field to a new value. */
#define BW_SDHC_MMCBOOT_BOOTMODE(x, v) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_BOOTMODE) = (v))
/*@}*/

/*!
 * @name Register SDHC_MMCBOOT, field BOOTEN[6] (RW)
 *
 * Values:
 * - 0 - Fast boot disable.
 * - 1 - Fast boot enable.
 */
/*@{*/
#define BP_SDHC_MMCBOOT_BOOTEN (6U)        /*!< Bit position for SDHC_MMCBOOT_BOOTEN. */
#define BM_SDHC_MMCBOOT_BOOTEN (0x00000040U) /*!< Bit mask for SDHC_MMCBOOT_BOOTEN. */
#define BS_SDHC_MMCBOOT_BOOTEN (1U)        /*!< Bit field size in bits for SDHC_MMCBOOT_BOOTEN. */

/*! @brief Read current value of the SDHC_MMCBOOT_BOOTEN field. */
#define BR_SDHC_MMCBOOT_BOOTEN(x) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_BOOTEN))

/*! @brief Format value for bitfield SDHC_MMCBOOT_BOOTEN. */
#define BF_SDHC_MMCBOOT_BOOTEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_MMCBOOT_BOOTEN) & BM_SDHC_MMCBOOT_BOOTEN)

/*! @brief Set the BOOTEN field to a new value. */
#define BW_SDHC_MMCBOOT_BOOTEN(x, v) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_BOOTEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_MMCBOOT, field AUTOSABGEN[7] (RW)
 *
 * When boot, enable auto stop at block gap function. This function will be
 * triggered, and host will stop at block gap when received card block cnt is equal
 * to BOOTBLKCNT.
 */
/*@{*/
#define BP_SDHC_MMCBOOT_AUTOSABGEN (7U)    /*!< Bit position for SDHC_MMCBOOT_AUTOSABGEN. */
#define BM_SDHC_MMCBOOT_AUTOSABGEN (0x00000080U) /*!< Bit mask for SDHC_MMCBOOT_AUTOSABGEN. */
#define BS_SDHC_MMCBOOT_AUTOSABGEN (1U)    /*!< Bit field size in bits for SDHC_MMCBOOT_AUTOSABGEN. */

/*! @brief Read current value of the SDHC_MMCBOOT_AUTOSABGEN field. */
#define BR_SDHC_MMCBOOT_AUTOSABGEN(x) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_AUTOSABGEN))

/*! @brief Format value for bitfield SDHC_MMCBOOT_AUTOSABGEN. */
#define BF_SDHC_MMCBOOT_AUTOSABGEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_MMCBOOT_AUTOSABGEN) & BM_SDHC_MMCBOOT_AUTOSABGEN)

/*! @brief Set the AUTOSABGEN field to a new value. */
#define BW_SDHC_MMCBOOT_AUTOSABGEN(x, v) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_AUTOSABGEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_MMCBOOT, field BOOTBLKCNT[31:16] (RW)
 *
 * Defines the stop at block gap value of automatic mode. When received card
 * block cnt is equal to BOOTBLKCNT and AUTOSABGEN is 1, then stop at block gap.
 */
/*@{*/
#define BP_SDHC_MMCBOOT_BOOTBLKCNT (16U)   /*!< Bit position for SDHC_MMCBOOT_BOOTBLKCNT. */
#define BM_SDHC_MMCBOOT_BOOTBLKCNT (0xFFFF0000U) /*!< Bit mask for SDHC_MMCBOOT_BOOTBLKCNT. */
#define BS_SDHC_MMCBOOT_BOOTBLKCNT (16U)   /*!< Bit field size in bits for SDHC_MMCBOOT_BOOTBLKCNT. */

/*! @brief Read current value of the SDHC_MMCBOOT_BOOTBLKCNT field. */
#define BR_SDHC_MMCBOOT_BOOTBLKCNT(x) (HW_SDHC_MMCBOOT(x).B.BOOTBLKCNT)

/*! @brief Format value for bitfield SDHC_MMCBOOT_BOOTBLKCNT. */
#define BF_SDHC_MMCBOOT_BOOTBLKCNT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_MMCBOOT_BOOTBLKCNT) & BM_SDHC_MMCBOOT_BOOTBLKCNT)

/*! @brief Set the BOOTBLKCNT field to a new value. */
#define BW_SDHC_MMCBOOT_BOOTBLKCNT(x, v) (HW_SDHC_MMCBOOT_WR(x, (HW_SDHC_MMCBOOT_RD(x) & ~BM_SDHC_MMCBOOT_BOOTBLKCNT) | BF_SDHC_MMCBOOT_BOOTBLKCNT(v)))
/*@}*/

/*******************************************************************************
 * HW_SDHC_HOSTVER - Host Controller Version
 ******************************************************************************/

/*!
 * @brief HW_SDHC_HOSTVER - Host Controller Version (RO)
 *
 * Reset value: 0x00001201U
 *
 * This register contains the vendor host controller version information. All
 * bits are read only and will read the same as the power-reset value.
 */
typedef union _hw_sdhc_hostver
{
    uint32_t U;
    struct _hw_sdhc_hostver_bitfields
    {
        uint32_t SVN : 8;              /*!< [7:0] Specification Version Number */
        uint32_t VVN : 8;              /*!< [15:8] Vendor Version Number */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_sdhc_hostver_t;

/*!
 * @name Constants and macros for entire SDHC_HOSTVER register
 */
/*@{*/
#define HW_SDHC_HOSTVER_ADDR(x)  ((x) + 0xFCU)

#define HW_SDHC_HOSTVER(x)       (*(__I hw_sdhc_hostver_t *) HW_SDHC_HOSTVER_ADDR(x))
#define HW_SDHC_HOSTVER_RD(x)    (HW_SDHC_HOSTVER(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_HOSTVER bitfields
 */

/*!
 * @name Register SDHC_HOSTVER, field SVN[7:0] (RO)
 *
 * These status bits indicate the host controller specification version.
 *
 * Values:
 * - 1 - SD host specification version 2.0, supports test event register and
 *     ADMA.
 */
/*@{*/
#define BP_SDHC_HOSTVER_SVN  (0U)          /*!< Bit position for SDHC_HOSTVER_SVN. */
#define BM_SDHC_HOSTVER_SVN  (0x000000FFU) /*!< Bit mask for SDHC_HOSTVER_SVN. */
#define BS_SDHC_HOSTVER_SVN  (8U)          /*!< Bit field size in bits for SDHC_HOSTVER_SVN. */

/*! @brief Read current value of the SDHC_HOSTVER_SVN field. */
#define BR_SDHC_HOSTVER_SVN(x) (HW_SDHC_HOSTVER(x).B.SVN)
/*@}*/

/*!
 * @name Register SDHC_HOSTVER, field VVN[15:8] (RO)
 *
 * These status bits are reserved for the vendor version number. The host driver
 * shall not use this status.
 *
 * Values:
 * - 0 - Freescale SDHC version 1.0
 * - 10000 - Freescale SDHC version 2.0
 * - 10001 - Freescale SDHC version 2.1
 * - 10010 - Freescale SDHC version 2.2
 */
/*@{*/
#define BP_SDHC_HOSTVER_VVN  (8U)          /*!< Bit position for SDHC_HOSTVER_VVN. */
#define BM_SDHC_HOSTVER_VVN  (0x0000FF00U) /*!< Bit mask for SDHC_HOSTVER_VVN. */
#define BS_SDHC_HOSTVER_VVN  (8U)          /*!< Bit field size in bits for SDHC_HOSTVER_VVN. */

/*! @brief Read current value of the SDHC_HOSTVER_VVN field. */
#define BR_SDHC_HOSTVER_VVN(x) (HW_SDHC_HOSTVER(x).B.VVN)
/*@}*/

/*******************************************************************************
 * hw_sdhc_t - module struct
 ******************************************************************************/
/*!
 * @brief All SDHC module registers.
 */
#pragma pack(1)
typedef struct _hw_sdhc
{
    __IO hw_sdhc_dsaddr_t DSADDR;          /*!< [0x0] DMA System Address register */
    __IO hw_sdhc_blkattr_t BLKATTR;        /*!< [0x4] Block Attributes register */
    __IO hw_sdhc_cmdarg_t CMDARG;          /*!< [0x8] Command Argument register */
    __IO hw_sdhc_xfertyp_t XFERTYP;        /*!< [0xC] Transfer Type register */
    __I hw_sdhc_cmdrsp0_t CMDRSP0;         /*!< [0x10] Command Response 0 */
    __I hw_sdhc_cmdrsp1_t CMDRSP1;         /*!< [0x14] Command Response 1 */
    __I hw_sdhc_cmdrsp2_t CMDRSP2;         /*!< [0x18] Command Response 2 */
    __I hw_sdhc_cmdrsp3_t CMDRSP3;         /*!< [0x1C] Command Response 3 */
    __IO hw_sdhc_datport_t DATPORT;        /*!< [0x20] Buffer Data Port register */
    __I hw_sdhc_prsstat_t PRSSTAT;         /*!< [0x24] Present State register */
    __IO hw_sdhc_proctl_t PROCTL;          /*!< [0x28] Protocol Control register */
    __IO hw_sdhc_sysctl_t SYSCTL;          /*!< [0x2C] System Control register */
    __IO hw_sdhc_irqstat_t IRQSTAT;        /*!< [0x30] Interrupt Status register */
    __IO hw_sdhc_irqstaten_t IRQSTATEN;    /*!< [0x34] Interrupt Status Enable register */
    __IO hw_sdhc_irqsigen_t IRQSIGEN;      /*!< [0x38] Interrupt Signal Enable register */
    __I hw_sdhc_ac12err_t AC12ERR;         /*!< [0x3C] Auto CMD12 Error Status Register */
    __I hw_sdhc_htcapblt_t HTCAPBLT;       /*!< [0x40] Host Controller Capabilities */
    __IO hw_sdhc_wml_t WML;                /*!< [0x44] Watermark Level Register */
    uint8_t _reserved0[8];
    __O hw_sdhc_fevt_t FEVT;               /*!< [0x50] Force Event register */
    __I hw_sdhc_admaes_t ADMAES;           /*!< [0x54] ADMA Error Status register */
    __IO hw_sdhc_adsaddr_t ADSADDR;        /*!< [0x58] ADMA System Addressregister */
    uint8_t _reserved1[100];
    __IO hw_sdhc_vendor_t VENDOR;          /*!< [0xC0] Vendor Specific register */
    __IO hw_sdhc_mmcboot_t MMCBOOT;        /*!< [0xC4] MMC Boot register */
    uint8_t _reserved2[52];
    __I hw_sdhc_hostver_t HOSTVER;         /*!< [0xFC] Host Controller Version */
} hw_sdhc_t;
#pragma pack()

/*! @brief Macro to access all SDHC registers. */
/*! @param x SDHC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_SDHC(SDHC_BASE)</code>. */
#define HW_SDHC(x)     (*(hw_sdhc_t *)(x))

#endif /* __HW_SDHC_REGISTERS_H__ */
/* EOF */
