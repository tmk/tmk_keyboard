/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    K22P121M120SF7RM, Rev. 1, March 24, 2014
**     Version:             rev. 2.5, 2014-05-06
**     Build:               b140604
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2014 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2013-07-23)
**         Initial version.
**     - rev. 1.1 (2013-09-17)
**         RM rev. 0.4 update.
**     - rev. 2.0 (2013-10-29)
**         Register accessor macros added to the memory map.
**         Symbols for Processor Expert memory map compatibility added to the memory map.
**         Startup file for gcc has been updated according to CMSIS 3.2.
**         System initialization updated.
**     - rev. 2.1 (2013-10-30)
**         Definition of BITBAND macros updated to support peripherals with 32-bit acces disabled.
**     - rev. 2.2 (2013-12-20)
**         Update according to reference manual rev. 0.6,
**     - rev. 2.3 (2014-01-13)
**         Update according to reference manual rev. 0.61,
**     - rev. 2.4 (2014-02-10)
**         The declaration of clock configurations has been moved to separate header file system_MK22F51212.h
**     - rev. 2.5 (2014-05-06)
**         Update according to reference manual rev. 1.0,
**         Update of system and startup files.
**         Module access macro module_BASES replaced by module_BASE_PTRS.
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_USB_REGISTERS_H__
#define __HW_USB_REGISTERS_H__

#include "MK22F51212.h"
#include "fsl_bitaccess.h"

/*
 * MK22F51212 USB
 *
 * Universal Serial Bus, OTG Capable Controller
 *
 * Registers defined in this header file:
 * - HW_USB_PERID - Peripheral ID register
 * - HW_USB_IDCOMP - Peripheral ID Complement register
 * - HW_USB_REV - Peripheral Revision register
 * - HW_USB_ADDINFO - Peripheral Additional Info register
 * - HW_USB_OTGISTAT - OTG Interrupt Status register
 * - HW_USB_OTGICR - OTG Interrupt Control register
 * - HW_USB_OTGSTAT - OTG Status register
 * - HW_USB_OTGCTL - OTG Control register
 * - HW_USB_ISTAT - Interrupt Status register
 * - HW_USB_INTEN - Interrupt Enable register
 * - HW_USB_ERRSTAT - Error Interrupt Status register
 * - HW_USB_ERREN - Error Interrupt Enable register
 * - HW_USB_STAT - Status register
 * - HW_USB_CTL - Control register
 * - HW_USB_ADDR - Address register
 * - HW_USB_BDTPAGE1 - BDT Page register 1
 * - HW_USB_FRMNUML - Frame Number register Low
 * - HW_USB_FRMNUMH - Frame Number register High
 * - HW_USB_TOKEN - Token register
 * - HW_USB_SOFTHLD - SOF Threshold register
 * - HW_USB_BDTPAGE2 - BDT Page Register 2
 * - HW_USB_BDTPAGE3 - BDT Page Register 3
 * - HW_USB_ENDPTn - Endpoint Control register
 * - HW_USB_USBCTRL - USB Control register
 * - HW_USB_OBSERVE - USB OTG Observe register
 * - HW_USB_CONTROL - USB OTG Control register
 * - HW_USB_USBTRC0 - USB Transceiver Control register 0
 * - HW_USB_USBFRMADJUST - Frame Adjust Register
 * - HW_USB_CLK_RECOVER_CTRL - USB Clock recovery control
 * - HW_USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register
 * - HW_USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status
 *
 * - hw_usb_t - Struct containing all module registers.
 */

#define HW_USB_INSTANCE_COUNT (1U) /*!< Number of instances of the USB module. */

/*******************************************************************************
 * HW_USB_PERID - Peripheral ID register
 ******************************************************************************/

/*!
 * @brief HW_USB_PERID - Peripheral ID register (RO)
 *
 * Reset value: 0x04U
 *
 * Reads back the value of 0x04. This value is defined for the USB peripheral.
 */
typedef union _hw_usb_perid
{
    uint8_t U;
    struct _hw_usb_perid_bitfields
    {
        uint8_t ID : 6;                /*!< [5:0] Peripheral Identification */
        uint8_t RESERVED0 : 2;         /*!< [7:6]  */
    } B;
} hw_usb_perid_t;

/*!
 * @name Constants and macros for entire USB_PERID register
 */
/*@{*/
#define HW_USB_PERID_ADDR(x)     ((x) + 0x0U)

#define HW_USB_PERID(x)          (*(__I hw_usb_perid_t *) HW_USB_PERID_ADDR(x))
#define HW_USB_PERID_RD(x)       (HW_USB_PERID(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_PERID bitfields
 */

/*!
 * @name Register USB_PERID, field ID[5:0] (RO)
 *
 * This field always reads 0x4h.
 */
/*@{*/
#define BP_USB_PERID_ID      (0U)          /*!< Bit position for USB_PERID_ID. */
#define BM_USB_PERID_ID      (0x3FU)       /*!< Bit mask for USB_PERID_ID. */
#define BS_USB_PERID_ID      (6U)          /*!< Bit field size in bits for USB_PERID_ID. */

/*! @brief Read current value of the USB_PERID_ID field. */
#define BR_USB_PERID_ID(x)   (HW_USB_PERID(x).B.ID)
/*@}*/

/*******************************************************************************
 * HW_USB_IDCOMP - Peripheral ID Complement register
 ******************************************************************************/

/*!
 * @brief HW_USB_IDCOMP - Peripheral ID Complement register (RO)
 *
 * Reset value: 0xFBU
 *
 * Reads back the complement of the Peripheral ID register. For the USB
 * peripheral, the value is 0xFB.
 */
typedef union _hw_usb_idcomp
{
    uint8_t U;
    struct _hw_usb_idcomp_bitfields
    {
        uint8_t NID : 6;               /*!< [5:0]  */
        uint8_t RESERVED0 : 2;         /*!< [7:6]  */
    } B;
} hw_usb_idcomp_t;

/*!
 * @name Constants and macros for entire USB_IDCOMP register
 */
/*@{*/
#define HW_USB_IDCOMP_ADDR(x)    ((x) + 0x4U)

#define HW_USB_IDCOMP(x)         (*(__I hw_usb_idcomp_t *) HW_USB_IDCOMP_ADDR(x))
#define HW_USB_IDCOMP_RD(x)      (HW_USB_IDCOMP(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_IDCOMP bitfields
 */

/*!
 * @name Register USB_IDCOMP, field NID[5:0] (RO)
 *
 * Ones' complement of PERID[ID]. bits.
 */
/*@{*/
#define BP_USB_IDCOMP_NID    (0U)          /*!< Bit position for USB_IDCOMP_NID. */
#define BM_USB_IDCOMP_NID    (0x3FU)       /*!< Bit mask for USB_IDCOMP_NID. */
#define BS_USB_IDCOMP_NID    (6U)          /*!< Bit field size in bits for USB_IDCOMP_NID. */

/*! @brief Read current value of the USB_IDCOMP_NID field. */
#define BR_USB_IDCOMP_NID(x) (HW_USB_IDCOMP(x).B.NID)
/*@}*/

/*******************************************************************************
 * HW_USB_REV - Peripheral Revision register
 ******************************************************************************/

/*!
 * @brief HW_USB_REV - Peripheral Revision register (RO)
 *
 * Reset value: 0x33U
 *
 * Contains the revision number of the USB module.
 */
typedef union _hw_usb_rev
{
    uint8_t U;
    struct _hw_usb_rev_bitfields
    {
        uint8_t REV : 8;               /*!< [7:0] Revision */
    } B;
} hw_usb_rev_t;

/*!
 * @name Constants and macros for entire USB_REV register
 */
/*@{*/
#define HW_USB_REV_ADDR(x)       ((x) + 0x8U)

#define HW_USB_REV(x)            (*(__I hw_usb_rev_t *) HW_USB_REV_ADDR(x))
#define HW_USB_REV_RD(x)         (HW_USB_REV(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_REV bitfields
 */

/*!
 * @name Register USB_REV, field REV[7:0] (RO)
 *
 * Indicates the revision number of the USB Core.
 */
/*@{*/
#define BP_USB_REV_REV       (0U)          /*!< Bit position for USB_REV_REV. */
#define BM_USB_REV_REV       (0xFFU)       /*!< Bit mask for USB_REV_REV. */
#define BS_USB_REV_REV       (8U)          /*!< Bit field size in bits for USB_REV_REV. */

/*! @brief Read current value of the USB_REV_REV field. */
#define BR_USB_REV_REV(x)    (HW_USB_REV(x).U)
/*@}*/

/*******************************************************************************
 * HW_USB_ADDINFO - Peripheral Additional Info register
 ******************************************************************************/

/*!
 * @brief HW_USB_ADDINFO - Peripheral Additional Info register (RO)
 *
 * Reset value: 0x01U
 *
 * Reads back the value of the Host Enable bit.
 */
typedef union _hw_usb_addinfo
{
    uint8_t U;
    struct _hw_usb_addinfo_bitfields
    {
        uint8_t IEHOST : 1;            /*!< [0]  */
        uint8_t RESERVED0 : 7;         /*!< [7:1]  */
    } B;
} hw_usb_addinfo_t;

/*!
 * @name Constants and macros for entire USB_ADDINFO register
 */
/*@{*/
#define HW_USB_ADDINFO_ADDR(x)   ((x) + 0xCU)

#define HW_USB_ADDINFO(x)        (*(__I hw_usb_addinfo_t *) HW_USB_ADDINFO_ADDR(x))
#define HW_USB_ADDINFO_RD(x)     (HW_USB_ADDINFO(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_ADDINFO bitfields
 */

/*!
 * @name Register USB_ADDINFO, field IEHOST[0] (RO)
 *
 * This bit is set if host mode is enabled.
 */
/*@{*/
#define BP_USB_ADDINFO_IEHOST (0U)         /*!< Bit position for USB_ADDINFO_IEHOST. */
#define BM_USB_ADDINFO_IEHOST (0x01U)      /*!< Bit mask for USB_ADDINFO_IEHOST. */
#define BS_USB_ADDINFO_IEHOST (1U)         /*!< Bit field size in bits for USB_ADDINFO_IEHOST. */

/*! @brief Read current value of the USB_ADDINFO_IEHOST field. */
#define BR_USB_ADDINFO_IEHOST(x) (BITBAND_ACCESS8(HW_USB_ADDINFO_ADDR(x), BP_USB_ADDINFO_IEHOST))
/*@}*/

/*******************************************************************************
 * HW_USB_OTGISTAT - OTG Interrupt Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_OTGISTAT - OTG Interrupt Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Records changes of the ID sense and VBUS signals. Software can read this
 * register to determine the event that triggers interrupt. Only bits that have
 * changed since the last software read are set. Writing a one to a bit clears the
 * associated interrupt.
 */
typedef union _hw_usb_otgistat
{
    uint8_t U;
    struct _hw_usb_otgistat_bitfields
    {
        uint8_t AVBUSCHG : 1;          /*!< [0]  */
        uint8_t RESERVED0 : 1;         /*!< [1]  */
        uint8_t B_SESS_CHG : 1;        /*!< [2]  */
        uint8_t SESSVLDCHG : 1;        /*!< [3]  */
        uint8_t RESERVED1 : 1;         /*!< [4]  */
        uint8_t LINE_STATE_CHG : 1;    /*!< [5]  */
        uint8_t ONEMSEC : 1;           /*!< [6]  */
        uint8_t IDCHG : 1;             /*!< [7]  */
    } B;
} hw_usb_otgistat_t;

/*!
 * @name Constants and macros for entire USB_OTGISTAT register
 */
/*@{*/
#define HW_USB_OTGISTAT_ADDR(x)  ((x) + 0x10U)

#define HW_USB_OTGISTAT(x)       (*(__IO hw_usb_otgistat_t *) HW_USB_OTGISTAT_ADDR(x))
#define HW_USB_OTGISTAT_RD(x)    (HW_USB_OTGISTAT(x).U)
#define HW_USB_OTGISTAT_WR(x, v) (HW_USB_OTGISTAT(x).U = (v))
#define HW_USB_OTGISTAT_SET(x, v) (HW_USB_OTGISTAT_WR(x, HW_USB_OTGISTAT_RD(x) |  (v)))
#define HW_USB_OTGISTAT_CLR(x, v) (HW_USB_OTGISTAT_WR(x, HW_USB_OTGISTAT_RD(x) & ~(v)))
#define HW_USB_OTGISTAT_TOG(x, v) (HW_USB_OTGISTAT_WR(x, HW_USB_OTGISTAT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGISTAT bitfields
 */

/*!
 * @name Register USB_OTGISTAT, field AVBUSCHG[0] (RW)
 *
 * This bit is set when a change in VBUS is detected on an A device.
 */
/*@{*/
#define BP_USB_OTGISTAT_AVBUSCHG (0U)      /*!< Bit position for USB_OTGISTAT_AVBUSCHG. */
#define BM_USB_OTGISTAT_AVBUSCHG (0x01U)   /*!< Bit mask for USB_OTGISTAT_AVBUSCHG. */
#define BS_USB_OTGISTAT_AVBUSCHG (1U)      /*!< Bit field size in bits for USB_OTGISTAT_AVBUSCHG. */

/*! @brief Read current value of the USB_OTGISTAT_AVBUSCHG field. */
#define BR_USB_OTGISTAT_AVBUSCHG(x) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_AVBUSCHG))

/*! @brief Format value for bitfield USB_OTGISTAT_AVBUSCHG. */
#define BF_USB_OTGISTAT_AVBUSCHG(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGISTAT_AVBUSCHG) & BM_USB_OTGISTAT_AVBUSCHG)

/*! @brief Set the AVBUSCHG field to a new value. */
#define BW_USB_OTGISTAT_AVBUSCHG(x, v) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_AVBUSCHG) = (v))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field B_SESS_CHG[2] (RW)
 *
 * This bit is set when a change in VBUS is detected on a B device.
 */
/*@{*/
#define BP_USB_OTGISTAT_B_SESS_CHG (2U)    /*!< Bit position for USB_OTGISTAT_B_SESS_CHG. */
#define BM_USB_OTGISTAT_B_SESS_CHG (0x04U) /*!< Bit mask for USB_OTGISTAT_B_SESS_CHG. */
#define BS_USB_OTGISTAT_B_SESS_CHG (1U)    /*!< Bit field size in bits for USB_OTGISTAT_B_SESS_CHG. */

/*! @brief Read current value of the USB_OTGISTAT_B_SESS_CHG field. */
#define BR_USB_OTGISTAT_B_SESS_CHG(x) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_B_SESS_CHG))

/*! @brief Format value for bitfield USB_OTGISTAT_B_SESS_CHG. */
#define BF_USB_OTGISTAT_B_SESS_CHG(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGISTAT_B_SESS_CHG) & BM_USB_OTGISTAT_B_SESS_CHG)

/*! @brief Set the B_SESS_CHG field to a new value. */
#define BW_USB_OTGISTAT_B_SESS_CHG(x, v) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_B_SESS_CHG) = (v))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field SESSVLDCHG[3] (RW)
 *
 * This bit is set when a change in VBUS is detected indicating a session valid
 * or a session no longer valid.
 */
/*@{*/
#define BP_USB_OTGISTAT_SESSVLDCHG (3U)    /*!< Bit position for USB_OTGISTAT_SESSVLDCHG. */
#define BM_USB_OTGISTAT_SESSVLDCHG (0x08U) /*!< Bit mask for USB_OTGISTAT_SESSVLDCHG. */
#define BS_USB_OTGISTAT_SESSVLDCHG (1U)    /*!< Bit field size in bits for USB_OTGISTAT_SESSVLDCHG. */

/*! @brief Read current value of the USB_OTGISTAT_SESSVLDCHG field. */
#define BR_USB_OTGISTAT_SESSVLDCHG(x) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_SESSVLDCHG))

/*! @brief Format value for bitfield USB_OTGISTAT_SESSVLDCHG. */
#define BF_USB_OTGISTAT_SESSVLDCHG(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGISTAT_SESSVLDCHG) & BM_USB_OTGISTAT_SESSVLDCHG)

/*! @brief Set the SESSVLDCHG field to a new value. */
#define BW_USB_OTGISTAT_SESSVLDCHG(x, v) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_SESSVLDCHG) = (v))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field LINE_STATE_CHG[5] (RW)
 *
 * This interrupt is set when the USB line state (CTL[SE0] and CTL[JSTATE] bits)
 * are stable without change for 1 millisecond, and the value of the line state
 * is different from the last time when the line state was stable. It is set on
 * transitions between SE0 and J-state, SE0 and K-state, and J-state and K-state.
 * Changes in J-state while SE0 is true do not cause an interrupt. This interrupt
 * can be used in detecting Reset, Resume, Connect, and Data Line Pulse
 * signaling.
 */
/*@{*/
#define BP_USB_OTGISTAT_LINE_STATE_CHG (5U) /*!< Bit position for USB_OTGISTAT_LINE_STATE_CHG. */
#define BM_USB_OTGISTAT_LINE_STATE_CHG (0x20U) /*!< Bit mask for USB_OTGISTAT_LINE_STATE_CHG. */
#define BS_USB_OTGISTAT_LINE_STATE_CHG (1U) /*!< Bit field size in bits for USB_OTGISTAT_LINE_STATE_CHG. */

/*! @brief Read current value of the USB_OTGISTAT_LINE_STATE_CHG field. */
#define BR_USB_OTGISTAT_LINE_STATE_CHG(x) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_LINE_STATE_CHG))

/*! @brief Format value for bitfield USB_OTGISTAT_LINE_STATE_CHG. */
#define BF_USB_OTGISTAT_LINE_STATE_CHG(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGISTAT_LINE_STATE_CHG) & BM_USB_OTGISTAT_LINE_STATE_CHG)

/*! @brief Set the LINE_STATE_CHG field to a new value. */
#define BW_USB_OTGISTAT_LINE_STATE_CHG(x, v) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_LINE_STATE_CHG) = (v))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field ONEMSEC[6] (RW)
 *
 * This bit is set when the 1 millisecond timer expires. This bit stays asserted
 * until cleared by software. The interrupt must be serviced every millisecond
 * to avoid losing 1msec counts.
 */
/*@{*/
#define BP_USB_OTGISTAT_ONEMSEC (6U)       /*!< Bit position for USB_OTGISTAT_ONEMSEC. */
#define BM_USB_OTGISTAT_ONEMSEC (0x40U)    /*!< Bit mask for USB_OTGISTAT_ONEMSEC. */
#define BS_USB_OTGISTAT_ONEMSEC (1U)       /*!< Bit field size in bits for USB_OTGISTAT_ONEMSEC. */

/*! @brief Read current value of the USB_OTGISTAT_ONEMSEC field. */
#define BR_USB_OTGISTAT_ONEMSEC(x) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_ONEMSEC))

/*! @brief Format value for bitfield USB_OTGISTAT_ONEMSEC. */
#define BF_USB_OTGISTAT_ONEMSEC(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGISTAT_ONEMSEC) & BM_USB_OTGISTAT_ONEMSEC)

/*! @brief Set the ONEMSEC field to a new value. */
#define BW_USB_OTGISTAT_ONEMSEC(x, v) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_ONEMSEC) = (v))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field IDCHG[7] (RW)
 *
 * This bit is set when a change in the ID Signal from the USB connector is
 * sensed.
 */
/*@{*/
#define BP_USB_OTGISTAT_IDCHG (7U)         /*!< Bit position for USB_OTGISTAT_IDCHG. */
#define BM_USB_OTGISTAT_IDCHG (0x80U)      /*!< Bit mask for USB_OTGISTAT_IDCHG. */
#define BS_USB_OTGISTAT_IDCHG (1U)         /*!< Bit field size in bits for USB_OTGISTAT_IDCHG. */

/*! @brief Read current value of the USB_OTGISTAT_IDCHG field. */
#define BR_USB_OTGISTAT_IDCHG(x) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_IDCHG))

/*! @brief Format value for bitfield USB_OTGISTAT_IDCHG. */
#define BF_USB_OTGISTAT_IDCHG(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGISTAT_IDCHG) & BM_USB_OTGISTAT_IDCHG)

/*! @brief Set the IDCHG field to a new value. */
#define BW_USB_OTGISTAT_IDCHG(x, v) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_IDCHG) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_OTGICR - OTG Interrupt Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_OTGICR - OTG Interrupt Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Enables the corresponding interrupt status bits defined in the OTG Interrupt
 * Status Register.
 */
typedef union _hw_usb_otgicr
{
    uint8_t U;
    struct _hw_usb_otgicr_bitfields
    {
        uint8_t AVBUSEN : 1;           /*!< [0] A VBUS Valid Interrupt Enable */
        uint8_t RESERVED0 : 1;         /*!< [1]  */
        uint8_t BSESSEN : 1;           /*!< [2] B Session END Interrupt Enable */
        uint8_t SESSVLDEN : 1;         /*!< [3] Session Valid Interrupt Enable */
        uint8_t RESERVED1 : 1;         /*!< [4]  */
        uint8_t LINESTATEEN : 1;       /*!< [5] Line State Change Interrupt Enable
                                        * */
        uint8_t ONEMSECEN : 1;         /*!< [6] One Millisecond Interrupt Enable */
        uint8_t IDEN : 1;              /*!< [7] ID Interrupt Enable */
    } B;
} hw_usb_otgicr_t;

/*!
 * @name Constants and macros for entire USB_OTGICR register
 */
/*@{*/
#define HW_USB_OTGICR_ADDR(x)    ((x) + 0x14U)

#define HW_USB_OTGICR(x)         (*(__IO hw_usb_otgicr_t *) HW_USB_OTGICR_ADDR(x))
#define HW_USB_OTGICR_RD(x)      (HW_USB_OTGICR(x).U)
#define HW_USB_OTGICR_WR(x, v)   (HW_USB_OTGICR(x).U = (v))
#define HW_USB_OTGICR_SET(x, v)  (HW_USB_OTGICR_WR(x, HW_USB_OTGICR_RD(x) |  (v)))
#define HW_USB_OTGICR_CLR(x, v)  (HW_USB_OTGICR_WR(x, HW_USB_OTGICR_RD(x) & ~(v)))
#define HW_USB_OTGICR_TOG(x, v)  (HW_USB_OTGICR_WR(x, HW_USB_OTGICR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGICR bitfields
 */

/*!
 * @name Register USB_OTGICR, field AVBUSEN[0] (RW)
 *
 * Values:
 * - 0 - Disables the AVBUSCHG interrupt.
 * - 1 - Enables the AVBUSCHG interrupt.
 */
/*@{*/
#define BP_USB_OTGICR_AVBUSEN (0U)         /*!< Bit position for USB_OTGICR_AVBUSEN. */
#define BM_USB_OTGICR_AVBUSEN (0x01U)      /*!< Bit mask for USB_OTGICR_AVBUSEN. */
#define BS_USB_OTGICR_AVBUSEN (1U)         /*!< Bit field size in bits for USB_OTGICR_AVBUSEN. */

/*! @brief Read current value of the USB_OTGICR_AVBUSEN field. */
#define BR_USB_OTGICR_AVBUSEN(x) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_AVBUSEN))

/*! @brief Format value for bitfield USB_OTGICR_AVBUSEN. */
#define BF_USB_OTGICR_AVBUSEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGICR_AVBUSEN) & BM_USB_OTGICR_AVBUSEN)

/*! @brief Set the AVBUSEN field to a new value. */
#define BW_USB_OTGICR_AVBUSEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_AVBUSEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGICR, field BSESSEN[2] (RW)
 *
 * Values:
 * - 0 - Disables the B_SESS_CHG interrupt.
 * - 1 - Enables the B_SESS_CHG interrupt.
 */
/*@{*/
#define BP_USB_OTGICR_BSESSEN (2U)         /*!< Bit position for USB_OTGICR_BSESSEN. */
#define BM_USB_OTGICR_BSESSEN (0x04U)      /*!< Bit mask for USB_OTGICR_BSESSEN. */
#define BS_USB_OTGICR_BSESSEN (1U)         /*!< Bit field size in bits for USB_OTGICR_BSESSEN. */

/*! @brief Read current value of the USB_OTGICR_BSESSEN field. */
#define BR_USB_OTGICR_BSESSEN(x) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_BSESSEN))

/*! @brief Format value for bitfield USB_OTGICR_BSESSEN. */
#define BF_USB_OTGICR_BSESSEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGICR_BSESSEN) & BM_USB_OTGICR_BSESSEN)

/*! @brief Set the BSESSEN field to a new value. */
#define BW_USB_OTGICR_BSESSEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_BSESSEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGICR, field SESSVLDEN[3] (RW)
 *
 * Values:
 * - 0 - Disables the SESSVLDCHG interrupt.
 * - 1 - Enables the SESSVLDCHG interrupt.
 */
/*@{*/
#define BP_USB_OTGICR_SESSVLDEN (3U)       /*!< Bit position for USB_OTGICR_SESSVLDEN. */
#define BM_USB_OTGICR_SESSVLDEN (0x08U)    /*!< Bit mask for USB_OTGICR_SESSVLDEN. */
#define BS_USB_OTGICR_SESSVLDEN (1U)       /*!< Bit field size in bits for USB_OTGICR_SESSVLDEN. */

/*! @brief Read current value of the USB_OTGICR_SESSVLDEN field. */
#define BR_USB_OTGICR_SESSVLDEN(x) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_SESSVLDEN))

/*! @brief Format value for bitfield USB_OTGICR_SESSVLDEN. */
#define BF_USB_OTGICR_SESSVLDEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGICR_SESSVLDEN) & BM_USB_OTGICR_SESSVLDEN)

/*! @brief Set the SESSVLDEN field to a new value. */
#define BW_USB_OTGICR_SESSVLDEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_SESSVLDEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGICR, field LINESTATEEN[5] (RW)
 *
 * Values:
 * - 0 - Disables the LINE_STAT_CHG interrupt.
 * - 1 - Enables the LINE_STAT_CHG interrupt.
 */
/*@{*/
#define BP_USB_OTGICR_LINESTATEEN (5U)     /*!< Bit position for USB_OTGICR_LINESTATEEN. */
#define BM_USB_OTGICR_LINESTATEEN (0x20U)  /*!< Bit mask for USB_OTGICR_LINESTATEEN. */
#define BS_USB_OTGICR_LINESTATEEN (1U)     /*!< Bit field size in bits for USB_OTGICR_LINESTATEEN. */

/*! @brief Read current value of the USB_OTGICR_LINESTATEEN field. */
#define BR_USB_OTGICR_LINESTATEEN(x) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_LINESTATEEN))

/*! @brief Format value for bitfield USB_OTGICR_LINESTATEEN. */
#define BF_USB_OTGICR_LINESTATEEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGICR_LINESTATEEN) & BM_USB_OTGICR_LINESTATEEN)

/*! @brief Set the LINESTATEEN field to a new value. */
#define BW_USB_OTGICR_LINESTATEEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_LINESTATEEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGICR, field ONEMSECEN[6] (RW)
 *
 * Values:
 * - 0 - Diables the 1ms timer interrupt.
 * - 1 - Enables the 1ms timer interrupt.
 */
/*@{*/
#define BP_USB_OTGICR_ONEMSECEN (6U)       /*!< Bit position for USB_OTGICR_ONEMSECEN. */
#define BM_USB_OTGICR_ONEMSECEN (0x40U)    /*!< Bit mask for USB_OTGICR_ONEMSECEN. */
#define BS_USB_OTGICR_ONEMSECEN (1U)       /*!< Bit field size in bits for USB_OTGICR_ONEMSECEN. */

/*! @brief Read current value of the USB_OTGICR_ONEMSECEN field. */
#define BR_USB_OTGICR_ONEMSECEN(x) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_ONEMSECEN))

/*! @brief Format value for bitfield USB_OTGICR_ONEMSECEN. */
#define BF_USB_OTGICR_ONEMSECEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGICR_ONEMSECEN) & BM_USB_OTGICR_ONEMSECEN)

/*! @brief Set the ONEMSECEN field to a new value. */
#define BW_USB_OTGICR_ONEMSECEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_ONEMSECEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGICR, field IDEN[7] (RW)
 *
 * Values:
 * - 0 - The ID interrupt is disabled
 * - 1 - The ID interrupt is enabled
 */
/*@{*/
#define BP_USB_OTGICR_IDEN   (7U)          /*!< Bit position for USB_OTGICR_IDEN. */
#define BM_USB_OTGICR_IDEN   (0x80U)       /*!< Bit mask for USB_OTGICR_IDEN. */
#define BS_USB_OTGICR_IDEN   (1U)          /*!< Bit field size in bits for USB_OTGICR_IDEN. */

/*! @brief Read current value of the USB_OTGICR_IDEN field. */
#define BR_USB_OTGICR_IDEN(x) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_IDEN))

/*! @brief Format value for bitfield USB_OTGICR_IDEN. */
#define BF_USB_OTGICR_IDEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGICR_IDEN) & BM_USB_OTGICR_IDEN)

/*! @brief Set the IDEN field to a new value. */
#define BW_USB_OTGICR_IDEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_IDEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_OTGSTAT - OTG Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_OTGSTAT - OTG Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Displays the actual value from the external comparator outputs of the ID pin
 * and VBUS.
 */
typedef union _hw_usb_otgstat
{
    uint8_t U;
    struct _hw_usb_otgstat_bitfields
    {
        uint8_t AVBUSVLD : 1;          /*!< [0] A VBUS Valid */
        uint8_t RESERVED0 : 1;         /*!< [1]  */
        uint8_t BSESSEND : 1;          /*!< [2] B Session End */
        uint8_t SESS_VLD : 1;          /*!< [3] Session Valid */
        uint8_t RESERVED1 : 1;         /*!< [4]  */
        uint8_t LINESTATESTABLE : 1;   /*!< [5]  */
        uint8_t ONEMSECEN : 1;         /*!< [6]  */
        uint8_t ID : 1;                /*!< [7]  */
    } B;
} hw_usb_otgstat_t;

/*!
 * @name Constants and macros for entire USB_OTGSTAT register
 */
/*@{*/
#define HW_USB_OTGSTAT_ADDR(x)   ((x) + 0x18U)

#define HW_USB_OTGSTAT(x)        (*(__IO hw_usb_otgstat_t *) HW_USB_OTGSTAT_ADDR(x))
#define HW_USB_OTGSTAT_RD(x)     (HW_USB_OTGSTAT(x).U)
#define HW_USB_OTGSTAT_WR(x, v)  (HW_USB_OTGSTAT(x).U = (v))
#define HW_USB_OTGSTAT_SET(x, v) (HW_USB_OTGSTAT_WR(x, HW_USB_OTGSTAT_RD(x) |  (v)))
#define HW_USB_OTGSTAT_CLR(x, v) (HW_USB_OTGSTAT_WR(x, HW_USB_OTGSTAT_RD(x) & ~(v)))
#define HW_USB_OTGSTAT_TOG(x, v) (HW_USB_OTGSTAT_WR(x, HW_USB_OTGSTAT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGSTAT bitfields
 */

/*!
 * @name Register USB_OTGSTAT, field AVBUSVLD[0] (RW)
 *
 * Values:
 * - 0 - The VBUS voltage is below the A VBUS Valid threshold.
 * - 1 - The VBUS voltage is above the A VBUS Valid threshold.
 */
/*@{*/
#define BP_USB_OTGSTAT_AVBUSVLD (0U)       /*!< Bit position for USB_OTGSTAT_AVBUSVLD. */
#define BM_USB_OTGSTAT_AVBUSVLD (0x01U)    /*!< Bit mask for USB_OTGSTAT_AVBUSVLD. */
#define BS_USB_OTGSTAT_AVBUSVLD (1U)       /*!< Bit field size in bits for USB_OTGSTAT_AVBUSVLD. */

/*! @brief Read current value of the USB_OTGSTAT_AVBUSVLD field. */
#define BR_USB_OTGSTAT_AVBUSVLD(x) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_AVBUSVLD))

/*! @brief Format value for bitfield USB_OTGSTAT_AVBUSVLD. */
#define BF_USB_OTGSTAT_AVBUSVLD(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGSTAT_AVBUSVLD) & BM_USB_OTGSTAT_AVBUSVLD)

/*! @brief Set the AVBUSVLD field to a new value. */
#define BW_USB_OTGSTAT_AVBUSVLD(x, v) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_AVBUSVLD) = (v))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field BSESSEND[2] (RW)
 *
 * Values:
 * - 0 - The VBUS voltage is above the B session end threshold.
 * - 1 - The VBUS voltage is below the B session end threshold.
 */
/*@{*/
#define BP_USB_OTGSTAT_BSESSEND (2U)       /*!< Bit position for USB_OTGSTAT_BSESSEND. */
#define BM_USB_OTGSTAT_BSESSEND (0x04U)    /*!< Bit mask for USB_OTGSTAT_BSESSEND. */
#define BS_USB_OTGSTAT_BSESSEND (1U)       /*!< Bit field size in bits for USB_OTGSTAT_BSESSEND. */

/*! @brief Read current value of the USB_OTGSTAT_BSESSEND field. */
#define BR_USB_OTGSTAT_BSESSEND(x) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_BSESSEND))

/*! @brief Format value for bitfield USB_OTGSTAT_BSESSEND. */
#define BF_USB_OTGSTAT_BSESSEND(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGSTAT_BSESSEND) & BM_USB_OTGSTAT_BSESSEND)

/*! @brief Set the BSESSEND field to a new value. */
#define BW_USB_OTGSTAT_BSESSEND(x, v) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_BSESSEND) = (v))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field SESS_VLD[3] (RW)
 *
 * Values:
 * - 0 - The VBUS voltage is below the B session valid threshold
 * - 1 - The VBUS voltage is above the B session valid threshold.
 */
/*@{*/
#define BP_USB_OTGSTAT_SESS_VLD (3U)       /*!< Bit position for USB_OTGSTAT_SESS_VLD. */
#define BM_USB_OTGSTAT_SESS_VLD (0x08U)    /*!< Bit mask for USB_OTGSTAT_SESS_VLD. */
#define BS_USB_OTGSTAT_SESS_VLD (1U)       /*!< Bit field size in bits for USB_OTGSTAT_SESS_VLD. */

/*! @brief Read current value of the USB_OTGSTAT_SESS_VLD field. */
#define BR_USB_OTGSTAT_SESS_VLD(x) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_SESS_VLD))

/*! @brief Format value for bitfield USB_OTGSTAT_SESS_VLD. */
#define BF_USB_OTGSTAT_SESS_VLD(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGSTAT_SESS_VLD) & BM_USB_OTGSTAT_SESS_VLD)

/*! @brief Set the SESS_VLD field to a new value. */
#define BW_USB_OTGSTAT_SESS_VLD(x, v) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_SESS_VLD) = (v))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field LINESTATESTABLE[5] (RW)
 *
 * Indicates that the internal signals that control the LINE_STATE_CHG field of
 * OTGISTAT are stable for at least 1 millisecond. First read LINE_STATE_CHG
 * field and then read this field. If this field reads as 1, then the value of
 * LINE_STATE_CHG can be considered stable.
 *
 * Values:
 * - 0 - The LINE_STAT_CHG bit is not yet stable.
 * - 1 - The LINE_STAT_CHG bit has been debounced and is stable.
 */
/*@{*/
#define BP_USB_OTGSTAT_LINESTATESTABLE (5U) /*!< Bit position for USB_OTGSTAT_LINESTATESTABLE. */
#define BM_USB_OTGSTAT_LINESTATESTABLE (0x20U) /*!< Bit mask for USB_OTGSTAT_LINESTATESTABLE. */
#define BS_USB_OTGSTAT_LINESTATESTABLE (1U) /*!< Bit field size in bits for USB_OTGSTAT_LINESTATESTABLE. */

/*! @brief Read current value of the USB_OTGSTAT_LINESTATESTABLE field. */
#define BR_USB_OTGSTAT_LINESTATESTABLE(x) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_LINESTATESTABLE))

/*! @brief Format value for bitfield USB_OTGSTAT_LINESTATESTABLE. */
#define BF_USB_OTGSTAT_LINESTATESTABLE(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGSTAT_LINESTATESTABLE) & BM_USB_OTGSTAT_LINESTATESTABLE)

/*! @brief Set the LINESTATESTABLE field to a new value. */
#define BW_USB_OTGSTAT_LINESTATESTABLE(x, v) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_LINESTATESTABLE) = (v))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field ONEMSECEN[6] (RW)
 *
 * This bit is reserved for the 1ms count, but it is not useful to software.
 */
/*@{*/
#define BP_USB_OTGSTAT_ONEMSECEN (6U)      /*!< Bit position for USB_OTGSTAT_ONEMSECEN. */
#define BM_USB_OTGSTAT_ONEMSECEN (0x40U)   /*!< Bit mask for USB_OTGSTAT_ONEMSECEN. */
#define BS_USB_OTGSTAT_ONEMSECEN (1U)      /*!< Bit field size in bits for USB_OTGSTAT_ONEMSECEN. */

/*! @brief Read current value of the USB_OTGSTAT_ONEMSECEN field. */
#define BR_USB_OTGSTAT_ONEMSECEN(x) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_ONEMSECEN))

/*! @brief Format value for bitfield USB_OTGSTAT_ONEMSECEN. */
#define BF_USB_OTGSTAT_ONEMSECEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGSTAT_ONEMSECEN) & BM_USB_OTGSTAT_ONEMSECEN)

/*! @brief Set the ONEMSECEN field to a new value. */
#define BW_USB_OTGSTAT_ONEMSECEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_ONEMSECEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field ID[7] (RW)
 *
 * Indicates the current state of the ID pin on the USB connector
 *
 * Values:
 * - 0 - Indicates a Type A cable is plugged into the USB connector.
 * - 1 - Indicates no cable is attached or a Type B cable is plugged into the
 *     USB connector.
 */
/*@{*/
#define BP_USB_OTGSTAT_ID    (7U)          /*!< Bit position for USB_OTGSTAT_ID. */
#define BM_USB_OTGSTAT_ID    (0x80U)       /*!< Bit mask for USB_OTGSTAT_ID. */
#define BS_USB_OTGSTAT_ID    (1U)          /*!< Bit field size in bits for USB_OTGSTAT_ID. */

/*! @brief Read current value of the USB_OTGSTAT_ID field. */
#define BR_USB_OTGSTAT_ID(x) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_ID))

/*! @brief Format value for bitfield USB_OTGSTAT_ID. */
#define BF_USB_OTGSTAT_ID(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGSTAT_ID) & BM_USB_OTGSTAT_ID)

/*! @brief Set the ID field to a new value. */
#define BW_USB_OTGSTAT_ID(x, v) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_ID) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_OTGCTL - OTG Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_OTGCTL - OTG Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Controls the operation of VBUS and Data Line termination resistors.
 */
typedef union _hw_usb_otgctl
{
    uint8_t U;
    struct _hw_usb_otgctl_bitfields
    {
        uint8_t RESERVED0 : 2;         /*!< [1:0]  */
        uint8_t OTGEN : 1;             /*!< [2] On-The-Go pullup/pulldown resistor enable
                                        * */
        uint8_t RESERVED1 : 1;         /*!< [3]  */
        uint8_t DMLOW : 1;             /*!< [4] D- Data Line pull-down resistor enable */
        uint8_t DPLOW : 1;             /*!< [5] D+ Data Line pull-down resistor enable */
        uint8_t RESERVED2 : 1;         /*!< [6]  */
        uint8_t DPHIGH : 1;            /*!< [7] D+ Data Line pullup resistor enable */
    } B;
} hw_usb_otgctl_t;

/*!
 * @name Constants and macros for entire USB_OTGCTL register
 */
/*@{*/
#define HW_USB_OTGCTL_ADDR(x)    ((x) + 0x1CU)

#define HW_USB_OTGCTL(x)         (*(__IO hw_usb_otgctl_t *) HW_USB_OTGCTL_ADDR(x))
#define HW_USB_OTGCTL_RD(x)      (HW_USB_OTGCTL(x).U)
#define HW_USB_OTGCTL_WR(x, v)   (HW_USB_OTGCTL(x).U = (v))
#define HW_USB_OTGCTL_SET(x, v)  (HW_USB_OTGCTL_WR(x, HW_USB_OTGCTL_RD(x) |  (v)))
#define HW_USB_OTGCTL_CLR(x, v)  (HW_USB_OTGCTL_WR(x, HW_USB_OTGCTL_RD(x) & ~(v)))
#define HW_USB_OTGCTL_TOG(x, v)  (HW_USB_OTGCTL_WR(x, HW_USB_OTGCTL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGCTL bitfields
 */

/*!
 * @name Register USB_OTGCTL, field OTGEN[2] (RW)
 *
 * Values:
 * - 0 - If USB_EN is 1 and HOST_MODE is 0 in the Control Register (CTL), then
 *     the D+ Data Line pull-up resistors are enabled. If HOST_MODE is 1 the D+
 *     and D- Data Line pull-down resistors are engaged.
 * - 1 - The pull-up and pull-down controls in this register are used.
 */
/*@{*/
#define BP_USB_OTGCTL_OTGEN  (2U)          /*!< Bit position for USB_OTGCTL_OTGEN. */
#define BM_USB_OTGCTL_OTGEN  (0x04U)       /*!< Bit mask for USB_OTGCTL_OTGEN. */
#define BS_USB_OTGCTL_OTGEN  (1U)          /*!< Bit field size in bits for USB_OTGCTL_OTGEN. */

/*! @brief Read current value of the USB_OTGCTL_OTGEN field. */
#define BR_USB_OTGCTL_OTGEN(x) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_OTGEN))

/*! @brief Format value for bitfield USB_OTGCTL_OTGEN. */
#define BF_USB_OTGCTL_OTGEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGCTL_OTGEN) & BM_USB_OTGCTL_OTGEN)

/*! @brief Set the OTGEN field to a new value. */
#define BW_USB_OTGCTL_OTGEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_OTGEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DMLOW[4] (RW)
 *
 * Values:
 * - 0 - D- pulldown resistor is not enabled.
 * - 1 - D- pulldown resistor is enabled.
 */
/*@{*/
#define BP_USB_OTGCTL_DMLOW  (4U)          /*!< Bit position for USB_OTGCTL_DMLOW. */
#define BM_USB_OTGCTL_DMLOW  (0x10U)       /*!< Bit mask for USB_OTGCTL_DMLOW. */
#define BS_USB_OTGCTL_DMLOW  (1U)          /*!< Bit field size in bits for USB_OTGCTL_DMLOW. */

/*! @brief Read current value of the USB_OTGCTL_DMLOW field. */
#define BR_USB_OTGCTL_DMLOW(x) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DMLOW))

/*! @brief Format value for bitfield USB_OTGCTL_DMLOW. */
#define BF_USB_OTGCTL_DMLOW(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGCTL_DMLOW) & BM_USB_OTGCTL_DMLOW)

/*! @brief Set the DMLOW field to a new value. */
#define BW_USB_OTGCTL_DMLOW(x, v) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DMLOW) = (v))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DPLOW[5] (RW)
 *
 * This bit should always be enabled together with bit 4 (DMLOW)
 *
 * Values:
 * - 0 - D+ pulldown resistor is not enabled.
 * - 1 - D+ pulldown resistor is enabled.
 */
/*@{*/
#define BP_USB_OTGCTL_DPLOW  (5U)          /*!< Bit position for USB_OTGCTL_DPLOW. */
#define BM_USB_OTGCTL_DPLOW  (0x20U)       /*!< Bit mask for USB_OTGCTL_DPLOW. */
#define BS_USB_OTGCTL_DPLOW  (1U)          /*!< Bit field size in bits for USB_OTGCTL_DPLOW. */

/*! @brief Read current value of the USB_OTGCTL_DPLOW field. */
#define BR_USB_OTGCTL_DPLOW(x) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DPLOW))

/*! @brief Format value for bitfield USB_OTGCTL_DPLOW. */
#define BF_USB_OTGCTL_DPLOW(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGCTL_DPLOW) & BM_USB_OTGCTL_DPLOW)

/*! @brief Set the DPLOW field to a new value. */
#define BW_USB_OTGCTL_DPLOW(x, v) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DPLOW) = (v))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DPHIGH[7] (RW)
 *
 * Values:
 * - 0 - D+ pullup resistor is not enabled
 * - 1 - D+ pullup resistor is enabled
 */
/*@{*/
#define BP_USB_OTGCTL_DPHIGH (7U)          /*!< Bit position for USB_OTGCTL_DPHIGH. */
#define BM_USB_OTGCTL_DPHIGH (0x80U)       /*!< Bit mask for USB_OTGCTL_DPHIGH. */
#define BS_USB_OTGCTL_DPHIGH (1U)          /*!< Bit field size in bits for USB_OTGCTL_DPHIGH. */

/*! @brief Read current value of the USB_OTGCTL_DPHIGH field. */
#define BR_USB_OTGCTL_DPHIGH(x) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DPHIGH))

/*! @brief Format value for bitfield USB_OTGCTL_DPHIGH. */
#define BF_USB_OTGCTL_DPHIGH(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGCTL_DPHIGH) & BM_USB_OTGCTL_DPHIGH)

/*! @brief Set the DPHIGH field to a new value. */
#define BW_USB_OTGCTL_DPHIGH(x, v) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DPHIGH) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_ISTAT - Interrupt Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_ISTAT - Interrupt Status register (W1C)
 *
 * Reset value: 0x00U
 *
 * Contains fields for each of the interrupt sources within the USB Module. Each
 * of these fields are qualified with their respective interrupt enable bits.
 * All fields of this register are logically OR'd together along with the OTG
 * Interrupt Status Register (OTGSTAT) to form a single interrupt source for the
 * processor's interrupt controller. After an interrupt bit has been set it may only
 * be cleared by writing a one to the respective interrupt bit. This register
 * contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_istat
{
    uint8_t U;
    struct _hw_usb_istat_bitfields
    {
        uint8_t USBRST : 1;            /*!< [0]  */
        uint8_t ERROR : 1;             /*!< [1]  */
        uint8_t SOFTOK : 1;            /*!< [2]  */
        uint8_t TOKDNE : 1;            /*!< [3]  */
        uint8_t SLEEP : 1;             /*!< [4]  */
        uint8_t RESUME : 1;            /*!< [5]  */
        uint8_t ATTACH : 1;            /*!< [6] Attach Interrupt */
        uint8_t STALL : 1;             /*!< [7] Stall Interrupt */
    } B;
} hw_usb_istat_t;

/*!
 * @name Constants and macros for entire USB_ISTAT register
 */
/*@{*/
#define HW_USB_ISTAT_ADDR(x)     ((x) + 0x80U)

#define HW_USB_ISTAT(x)          (*(__IO hw_usb_istat_t *) HW_USB_ISTAT_ADDR(x))
#define HW_USB_ISTAT_RD(x)       (HW_USB_ISTAT(x).U)
#define HW_USB_ISTAT_WR(x, v)    (HW_USB_ISTAT(x).U = (v))
#define HW_USB_ISTAT_SET(x, v)   (HW_USB_ISTAT_WR(x, HW_USB_ISTAT_RD(x) |  (v)))
#define HW_USB_ISTAT_CLR(x, v)   (HW_USB_ISTAT_WR(x, HW_USB_ISTAT_RD(x) & ~(v)))
#define HW_USB_ISTAT_TOG(x, v)   (HW_USB_ISTAT_WR(x, HW_USB_ISTAT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_ISTAT bitfields
 */

/*!
 * @name Register USB_ISTAT, field USBRST[0] (W1C)
 *
 * This bit is set when the USB Module has decoded a valid USB reset. This
 * informs the processor that it should write 0x00 into the address register and
 * enable endpoint 0. USBRST is set after a USB reset has been detected for 2.5
 * microseconds. It is not asserted again until the USB reset condition has been
 * removed and then reasserted.
 */
/*@{*/
#define BP_USB_ISTAT_USBRST  (0U)          /*!< Bit position for USB_ISTAT_USBRST. */
#define BM_USB_ISTAT_USBRST  (0x01U)       /*!< Bit mask for USB_ISTAT_USBRST. */
#define BS_USB_ISTAT_USBRST  (1U)          /*!< Bit field size in bits for USB_ISTAT_USBRST. */

/*! @brief Read current value of the USB_ISTAT_USBRST field. */
#define BR_USB_ISTAT_USBRST(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_USBRST))

/*! @brief Format value for bitfield USB_ISTAT_USBRST. */
#define BF_USB_ISTAT_USBRST(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_USBRST) & BM_USB_ISTAT_USBRST)

/*! @brief Set the USBRST field to a new value. */
#define BW_USB_ISTAT_USBRST(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_USBRST) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field ERROR[1] (W1C)
 *
 * This bit is set when any of the error conditions within Error Interrupt
 * Status (ERRSTAT) register occur. The processor must then read the ERRSTAT register
 * to determine the source of the error.
 */
/*@{*/
#define BP_USB_ISTAT_ERROR   (1U)          /*!< Bit position for USB_ISTAT_ERROR. */
#define BM_USB_ISTAT_ERROR   (0x02U)       /*!< Bit mask for USB_ISTAT_ERROR. */
#define BS_USB_ISTAT_ERROR   (1U)          /*!< Bit field size in bits for USB_ISTAT_ERROR. */

/*! @brief Read current value of the USB_ISTAT_ERROR field. */
#define BR_USB_ISTAT_ERROR(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_ERROR))

/*! @brief Format value for bitfield USB_ISTAT_ERROR. */
#define BF_USB_ISTAT_ERROR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_ERROR) & BM_USB_ISTAT_ERROR)

/*! @brief Set the ERROR field to a new value. */
#define BW_USB_ISTAT_ERROR(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_ERROR) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SOFTOK[2] (W1C)
 *
 * This bit is set when the USB Module receives a Start Of Frame (SOF) token. In
 * Host mode this field is set when the SOF threshold is reached, so that
 * software can prepare for the next SOF.
 */
/*@{*/
#define BP_USB_ISTAT_SOFTOK  (2U)          /*!< Bit position for USB_ISTAT_SOFTOK. */
#define BM_USB_ISTAT_SOFTOK  (0x04U)       /*!< Bit mask for USB_ISTAT_SOFTOK. */
#define BS_USB_ISTAT_SOFTOK  (1U)          /*!< Bit field size in bits for USB_ISTAT_SOFTOK. */

/*! @brief Read current value of the USB_ISTAT_SOFTOK field. */
#define BR_USB_ISTAT_SOFTOK(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_SOFTOK))

/*! @brief Format value for bitfield USB_ISTAT_SOFTOK. */
#define BF_USB_ISTAT_SOFTOK(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_SOFTOK) & BM_USB_ISTAT_SOFTOK)

/*! @brief Set the SOFTOK field to a new value. */
#define BW_USB_ISTAT_SOFTOK(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_SOFTOK) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field TOKDNE[3] (W1C)
 *
 * This bit is set when the current token being processed has completed. The
 * processor must immediately read the STATUS (STAT) register to determine the
 * EndPoint and BD used for this token. Clearing this bit (by writing a one) causes
 * STAT to be cleared or the STAT holding register to be loaded into the STAT
 * register.
 */
/*@{*/
#define BP_USB_ISTAT_TOKDNE  (3U)          /*!< Bit position for USB_ISTAT_TOKDNE. */
#define BM_USB_ISTAT_TOKDNE  (0x08U)       /*!< Bit mask for USB_ISTAT_TOKDNE. */
#define BS_USB_ISTAT_TOKDNE  (1U)          /*!< Bit field size in bits for USB_ISTAT_TOKDNE. */

/*! @brief Read current value of the USB_ISTAT_TOKDNE field. */
#define BR_USB_ISTAT_TOKDNE(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_TOKDNE))

/*! @brief Format value for bitfield USB_ISTAT_TOKDNE. */
#define BF_USB_ISTAT_TOKDNE(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_TOKDNE) & BM_USB_ISTAT_TOKDNE)

/*! @brief Set the TOKDNE field to a new value. */
#define BW_USB_ISTAT_TOKDNE(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_TOKDNE) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SLEEP[4] (W1C)
 *
 * This bit is set when the USB Module detects a constant idle on the USB bus
 * for 3 ms. The sleep timer is reset by activity on the USB bus.
 */
/*@{*/
#define BP_USB_ISTAT_SLEEP   (4U)          /*!< Bit position for USB_ISTAT_SLEEP. */
#define BM_USB_ISTAT_SLEEP   (0x10U)       /*!< Bit mask for USB_ISTAT_SLEEP. */
#define BS_USB_ISTAT_SLEEP   (1U)          /*!< Bit field size in bits for USB_ISTAT_SLEEP. */

/*! @brief Read current value of the USB_ISTAT_SLEEP field. */
#define BR_USB_ISTAT_SLEEP(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_SLEEP))

/*! @brief Format value for bitfield USB_ISTAT_SLEEP. */
#define BF_USB_ISTAT_SLEEP(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_SLEEP) & BM_USB_ISTAT_SLEEP)

/*! @brief Set the SLEEP field to a new value. */
#define BW_USB_ISTAT_SLEEP(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_SLEEP) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field RESUME[5] (W1C)
 *
 * This bit is set when a K-state is observed on the DP/DM signals for 2.5 us.
 * When not in suspend mode this interrupt must be disabled.
 */
/*@{*/
#define BP_USB_ISTAT_RESUME  (5U)          /*!< Bit position for USB_ISTAT_RESUME. */
#define BM_USB_ISTAT_RESUME  (0x20U)       /*!< Bit mask for USB_ISTAT_RESUME. */
#define BS_USB_ISTAT_RESUME  (1U)          /*!< Bit field size in bits for USB_ISTAT_RESUME. */

/*! @brief Read current value of the USB_ISTAT_RESUME field. */
#define BR_USB_ISTAT_RESUME(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_RESUME))

/*! @brief Format value for bitfield USB_ISTAT_RESUME. */
#define BF_USB_ISTAT_RESUME(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_RESUME) & BM_USB_ISTAT_RESUME)

/*! @brief Set the RESUME field to a new value. */
#define BW_USB_ISTAT_RESUME(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_RESUME) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field ATTACH[6] (W1C)
 *
 * This bit is set when the USB Module detects an attach of a USB device. This
 * signal is only valid if HOSTMODEEN is true. This interrupt signifies that a
 * peripheral is now present and must be configured; it is asserted if there have
 * been no transitions on the USB for 2.5 us and the current bus state is not SE0."
 */
/*@{*/
#define BP_USB_ISTAT_ATTACH  (6U)          /*!< Bit position for USB_ISTAT_ATTACH. */
#define BM_USB_ISTAT_ATTACH  (0x40U)       /*!< Bit mask for USB_ISTAT_ATTACH. */
#define BS_USB_ISTAT_ATTACH  (1U)          /*!< Bit field size in bits for USB_ISTAT_ATTACH. */

/*! @brief Read current value of the USB_ISTAT_ATTACH field. */
#define BR_USB_ISTAT_ATTACH(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_ATTACH))

/*! @brief Format value for bitfield USB_ISTAT_ATTACH. */
#define BF_USB_ISTAT_ATTACH(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_ATTACH) & BM_USB_ISTAT_ATTACH)

/*! @brief Set the ATTACH field to a new value. */
#define BW_USB_ISTAT_ATTACH(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_ATTACH) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field STALL[7] (W1C)
 *
 * In Target mode this bit is asserted when a STALL handshake is sent by the
 * SIE. In Host mode this bit is set when the USB Module detects a STALL acknowledge
 * during the handshake phase of a USB transaction.This interrupt can be used to
 * determine whether the last USB transaction was completed successfully or
 * stalled.
 */
/*@{*/
#define BP_USB_ISTAT_STALL   (7U)          /*!< Bit position for USB_ISTAT_STALL. */
#define BM_USB_ISTAT_STALL   (0x80U)       /*!< Bit mask for USB_ISTAT_STALL. */
#define BS_USB_ISTAT_STALL   (1U)          /*!< Bit field size in bits for USB_ISTAT_STALL. */

/*! @brief Read current value of the USB_ISTAT_STALL field. */
#define BR_USB_ISTAT_STALL(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_STALL))

/*! @brief Format value for bitfield USB_ISTAT_STALL. */
#define BF_USB_ISTAT_STALL(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_STALL) & BM_USB_ISTAT_STALL)

/*! @brief Set the STALL field to a new value. */
#define BW_USB_ISTAT_STALL(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_STALL) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_INTEN - Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief HW_USB_INTEN - Interrupt Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable fields for each of the interrupt sources within the USB
 * Module. Setting any of these bits enables the respective interrupt source in the
 * ISTAT register. This register contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_inten
{
    uint8_t U;
    struct _hw_usb_inten_bitfields
    {
        uint8_t USBRSTEN : 1;          /*!< [0] USBRST Interrupt Enable */
        uint8_t ERROREN : 1;           /*!< [1] ERROR Interrupt Enable */
        uint8_t SOFTOKEN : 1;          /*!< [2] SOFTOK Interrupt Enable */
        uint8_t TOKDNEEN : 1;          /*!< [3] TOKDNE Interrupt Enable */
        uint8_t SLEEPEN : 1;           /*!< [4] SLEEP Interrupt Enable */
        uint8_t RESUMEEN : 1;          /*!< [5] RESUME Interrupt Enable */
        uint8_t ATTACHEN : 1;          /*!< [6] ATTACH Interrupt Enable */
        uint8_t STALLEN : 1;           /*!< [7] STALL Interrupt Enable */
    } B;
} hw_usb_inten_t;

/*!
 * @name Constants and macros for entire USB_INTEN register
 */
/*@{*/
#define HW_USB_INTEN_ADDR(x)     ((x) + 0x84U)

#define HW_USB_INTEN(x)          (*(__IO hw_usb_inten_t *) HW_USB_INTEN_ADDR(x))
#define HW_USB_INTEN_RD(x)       (HW_USB_INTEN(x).U)
#define HW_USB_INTEN_WR(x, v)    (HW_USB_INTEN(x).U = (v))
#define HW_USB_INTEN_SET(x, v)   (HW_USB_INTEN_WR(x, HW_USB_INTEN_RD(x) |  (v)))
#define HW_USB_INTEN_CLR(x, v)   (HW_USB_INTEN_WR(x, HW_USB_INTEN_RD(x) & ~(v)))
#define HW_USB_INTEN_TOG(x, v)   (HW_USB_INTEN_WR(x, HW_USB_INTEN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_INTEN bitfields
 */

/*!
 * @name Register USB_INTEN, field USBRSTEN[0] (RW)
 *
 * Values:
 * - 0 - Disables the USBRST interrupt.
 * - 1 - Enables the USBRST interrupt.
 */
/*@{*/
#define BP_USB_INTEN_USBRSTEN (0U)         /*!< Bit position for USB_INTEN_USBRSTEN. */
#define BM_USB_INTEN_USBRSTEN (0x01U)      /*!< Bit mask for USB_INTEN_USBRSTEN. */
#define BS_USB_INTEN_USBRSTEN (1U)         /*!< Bit field size in bits for USB_INTEN_USBRSTEN. */

/*! @brief Read current value of the USB_INTEN_USBRSTEN field. */
#define BR_USB_INTEN_USBRSTEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_USBRSTEN))

/*! @brief Format value for bitfield USB_INTEN_USBRSTEN. */
#define BF_USB_INTEN_USBRSTEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_USBRSTEN) & BM_USB_INTEN_USBRSTEN)

/*! @brief Set the USBRSTEN field to a new value. */
#define BW_USB_INTEN_USBRSTEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_USBRSTEN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field ERROREN[1] (RW)
 *
 * Values:
 * - 0 - Disables the ERROR interrupt.
 * - 1 - Enables the ERROR interrupt.
 */
/*@{*/
#define BP_USB_INTEN_ERROREN (1U)          /*!< Bit position for USB_INTEN_ERROREN. */
#define BM_USB_INTEN_ERROREN (0x02U)       /*!< Bit mask for USB_INTEN_ERROREN. */
#define BS_USB_INTEN_ERROREN (1U)          /*!< Bit field size in bits for USB_INTEN_ERROREN. */

/*! @brief Read current value of the USB_INTEN_ERROREN field. */
#define BR_USB_INTEN_ERROREN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_ERROREN))

/*! @brief Format value for bitfield USB_INTEN_ERROREN. */
#define BF_USB_INTEN_ERROREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_ERROREN) & BM_USB_INTEN_ERROREN)

/*! @brief Set the ERROREN field to a new value. */
#define BW_USB_INTEN_ERROREN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_ERROREN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field SOFTOKEN[2] (RW)
 *
 * Values:
 * - 0 - Disbles the SOFTOK interrupt.
 * - 1 - Enables the SOFTOK interrupt.
 */
/*@{*/
#define BP_USB_INTEN_SOFTOKEN (2U)         /*!< Bit position for USB_INTEN_SOFTOKEN. */
#define BM_USB_INTEN_SOFTOKEN (0x04U)      /*!< Bit mask for USB_INTEN_SOFTOKEN. */
#define BS_USB_INTEN_SOFTOKEN (1U)         /*!< Bit field size in bits for USB_INTEN_SOFTOKEN. */

/*! @brief Read current value of the USB_INTEN_SOFTOKEN field. */
#define BR_USB_INTEN_SOFTOKEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_SOFTOKEN))

/*! @brief Format value for bitfield USB_INTEN_SOFTOKEN. */
#define BF_USB_INTEN_SOFTOKEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_SOFTOKEN) & BM_USB_INTEN_SOFTOKEN)

/*! @brief Set the SOFTOKEN field to a new value. */
#define BW_USB_INTEN_SOFTOKEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_SOFTOKEN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field TOKDNEEN[3] (RW)
 *
 * Values:
 * - 0 - Disables the TOKDNE interrupt.
 * - 1 - Enables the TOKDNE interrupt.
 */
/*@{*/
#define BP_USB_INTEN_TOKDNEEN (3U)         /*!< Bit position for USB_INTEN_TOKDNEEN. */
#define BM_USB_INTEN_TOKDNEEN (0x08U)      /*!< Bit mask for USB_INTEN_TOKDNEEN. */
#define BS_USB_INTEN_TOKDNEEN (1U)         /*!< Bit field size in bits for USB_INTEN_TOKDNEEN. */

/*! @brief Read current value of the USB_INTEN_TOKDNEEN field. */
#define BR_USB_INTEN_TOKDNEEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_TOKDNEEN))

/*! @brief Format value for bitfield USB_INTEN_TOKDNEEN. */
#define BF_USB_INTEN_TOKDNEEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_TOKDNEEN) & BM_USB_INTEN_TOKDNEEN)

/*! @brief Set the TOKDNEEN field to a new value. */
#define BW_USB_INTEN_TOKDNEEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_TOKDNEEN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field SLEEPEN[4] (RW)
 *
 * Values:
 * - 0 - Disables the SLEEP interrupt.
 * - 1 - Enables the SLEEP interrupt.
 */
/*@{*/
#define BP_USB_INTEN_SLEEPEN (4U)          /*!< Bit position for USB_INTEN_SLEEPEN. */
#define BM_USB_INTEN_SLEEPEN (0x10U)       /*!< Bit mask for USB_INTEN_SLEEPEN. */
#define BS_USB_INTEN_SLEEPEN (1U)          /*!< Bit field size in bits for USB_INTEN_SLEEPEN. */

/*! @brief Read current value of the USB_INTEN_SLEEPEN field. */
#define BR_USB_INTEN_SLEEPEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_SLEEPEN))

/*! @brief Format value for bitfield USB_INTEN_SLEEPEN. */
#define BF_USB_INTEN_SLEEPEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_SLEEPEN) & BM_USB_INTEN_SLEEPEN)

/*! @brief Set the SLEEPEN field to a new value. */
#define BW_USB_INTEN_SLEEPEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_SLEEPEN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field RESUMEEN[5] (RW)
 *
 * Values:
 * - 0 - Disables the RESUME interrupt.
 * - 1 - Enables the RESUME interrupt.
 */
/*@{*/
#define BP_USB_INTEN_RESUMEEN (5U)         /*!< Bit position for USB_INTEN_RESUMEEN. */
#define BM_USB_INTEN_RESUMEEN (0x20U)      /*!< Bit mask for USB_INTEN_RESUMEEN. */
#define BS_USB_INTEN_RESUMEEN (1U)         /*!< Bit field size in bits for USB_INTEN_RESUMEEN. */

/*! @brief Read current value of the USB_INTEN_RESUMEEN field. */
#define BR_USB_INTEN_RESUMEEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_RESUMEEN))

/*! @brief Format value for bitfield USB_INTEN_RESUMEEN. */
#define BF_USB_INTEN_RESUMEEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_RESUMEEN) & BM_USB_INTEN_RESUMEEN)

/*! @brief Set the RESUMEEN field to a new value. */
#define BW_USB_INTEN_RESUMEEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_RESUMEEN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field ATTACHEN[6] (RW)
 *
 * Values:
 * - 0 - Disables the ATTACH interrupt.
 * - 1 - Enables the ATTACH interrupt.
 */
/*@{*/
#define BP_USB_INTEN_ATTACHEN (6U)         /*!< Bit position for USB_INTEN_ATTACHEN. */
#define BM_USB_INTEN_ATTACHEN (0x40U)      /*!< Bit mask for USB_INTEN_ATTACHEN. */
#define BS_USB_INTEN_ATTACHEN (1U)         /*!< Bit field size in bits for USB_INTEN_ATTACHEN. */

/*! @brief Read current value of the USB_INTEN_ATTACHEN field. */
#define BR_USB_INTEN_ATTACHEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_ATTACHEN))

/*! @brief Format value for bitfield USB_INTEN_ATTACHEN. */
#define BF_USB_INTEN_ATTACHEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_ATTACHEN) & BM_USB_INTEN_ATTACHEN)

/*! @brief Set the ATTACHEN field to a new value. */
#define BW_USB_INTEN_ATTACHEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_ATTACHEN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field STALLEN[7] (RW)
 *
 * Values:
 * - 0 - Diasbles the STALL interrupt.
 * - 1 - Enables the STALL interrupt.
 */
/*@{*/
#define BP_USB_INTEN_STALLEN (7U)          /*!< Bit position for USB_INTEN_STALLEN. */
#define BM_USB_INTEN_STALLEN (0x80U)       /*!< Bit mask for USB_INTEN_STALLEN. */
#define BS_USB_INTEN_STALLEN (1U)          /*!< Bit field size in bits for USB_INTEN_STALLEN. */

/*! @brief Read current value of the USB_INTEN_STALLEN field. */
#define BR_USB_INTEN_STALLEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_STALLEN))

/*! @brief Format value for bitfield USB_INTEN_STALLEN. */
#define BF_USB_INTEN_STALLEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_STALLEN) & BM_USB_INTEN_STALLEN)

/*! @brief Set the STALLEN field to a new value. */
#define BW_USB_INTEN_STALLEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_STALLEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_ERRSTAT - Error Interrupt Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_ERRSTAT - Error Interrupt Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable bits for each of the error sources within the USB Module.
 * Each of these bits are qualified with their respective error enable bits. All
 * bits of this register are logically OR'd together and the result placed in the
 * ERROR bit of the ISTAT register. After an interrupt bit has been set it may only
 * be cleared by writing a one to the respective interrupt bit. Each bit is set
 * as soon as the error condition is detected. Therefore, the interrupt does not
 * typically correspond with the end of a token being processed. This register
 * contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_errstat
{
    uint8_t U;
    struct _hw_usb_errstat_bitfields
    {
        uint8_t PIDERR : 1;            /*!< [0]  */
        uint8_t CRC5EOF : 1;           /*!< [1]  */
        uint8_t CRC16 : 1;             /*!< [2]  */
        uint8_t DFN8 : 1;              /*!< [3]  */
        uint8_t BTOERR : 1;            /*!< [4]  */
        uint8_t DMAERR : 1;            /*!< [5]  */
        uint8_t RESERVED0 : 1;         /*!< [6]  */
        uint8_t BTSERR : 1;            /*!< [7]  */
    } B;
} hw_usb_errstat_t;

/*!
 * @name Constants and macros for entire USB_ERRSTAT register
 */
/*@{*/
#define HW_USB_ERRSTAT_ADDR(x)   ((x) + 0x88U)

#define HW_USB_ERRSTAT(x)        (*(__IO hw_usb_errstat_t *) HW_USB_ERRSTAT_ADDR(x))
#define HW_USB_ERRSTAT_RD(x)     (HW_USB_ERRSTAT(x).U)
#define HW_USB_ERRSTAT_WR(x, v)  (HW_USB_ERRSTAT(x).U = (v))
#define HW_USB_ERRSTAT_SET(x, v) (HW_USB_ERRSTAT_WR(x, HW_USB_ERRSTAT_RD(x) |  (v)))
#define HW_USB_ERRSTAT_CLR(x, v) (HW_USB_ERRSTAT_WR(x, HW_USB_ERRSTAT_RD(x) & ~(v)))
#define HW_USB_ERRSTAT_TOG(x, v) (HW_USB_ERRSTAT_WR(x, HW_USB_ERRSTAT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_ERRSTAT bitfields
 */

/*!
 * @name Register USB_ERRSTAT, field PIDERR[0] (W1C)
 *
 * This bit is set when the PID check field fails.
 */
/*@{*/
#define BP_USB_ERRSTAT_PIDERR (0U)         /*!< Bit position for USB_ERRSTAT_PIDERR. */
#define BM_USB_ERRSTAT_PIDERR (0x01U)      /*!< Bit mask for USB_ERRSTAT_PIDERR. */
#define BS_USB_ERRSTAT_PIDERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_PIDERR. */

/*! @brief Read current value of the USB_ERRSTAT_PIDERR field. */
#define BR_USB_ERRSTAT_PIDERR(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_PIDERR))

/*! @brief Format value for bitfield USB_ERRSTAT_PIDERR. */
#define BF_USB_ERRSTAT_PIDERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_PIDERR) & BM_USB_ERRSTAT_PIDERR)

/*! @brief Set the PIDERR field to a new value. */
#define BW_USB_ERRSTAT_PIDERR(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_PIDERR) = (v))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC5EOF[1] (W1C)
 *
 * This error interrupt has two functions. When the USB Module is operating in
 * peripheral mode (HOSTMODEEN=0), this interrupt detects CRC5 errors in the token
 * packets generated by the host. If set the token packet was rejected due to a
 * CRC5 error. When the USB Module is operating in host mode (HOSTMODEEN=1), this
 * interrupt detects End Of Frame (EOF) error conditions. This occurs when the
 * USB Module is transmitting or receiving data and the SOF counter reaches zero.
 * This interrupt is useful when developing USB packet scheduling software to
 * ensure that no USB transactions cross the start of the next frame.
 */
/*@{*/
#define BP_USB_ERRSTAT_CRC5EOF (1U)        /*!< Bit position for USB_ERRSTAT_CRC5EOF. */
#define BM_USB_ERRSTAT_CRC5EOF (0x02U)     /*!< Bit mask for USB_ERRSTAT_CRC5EOF. */
#define BS_USB_ERRSTAT_CRC5EOF (1U)        /*!< Bit field size in bits for USB_ERRSTAT_CRC5EOF. */

/*! @brief Read current value of the USB_ERRSTAT_CRC5EOF field. */
#define BR_USB_ERRSTAT_CRC5EOF(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_CRC5EOF))

/*! @brief Format value for bitfield USB_ERRSTAT_CRC5EOF. */
#define BF_USB_ERRSTAT_CRC5EOF(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_CRC5EOF) & BM_USB_ERRSTAT_CRC5EOF)

/*! @brief Set the CRC5EOF field to a new value. */
#define BW_USB_ERRSTAT_CRC5EOF(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_CRC5EOF) = (v))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC16[2] (W1C)
 *
 * This bit is set when a data packet is rejected due to a CRC16 error.
 */
/*@{*/
#define BP_USB_ERRSTAT_CRC16 (2U)          /*!< Bit position for USB_ERRSTAT_CRC16. */
#define BM_USB_ERRSTAT_CRC16 (0x04U)       /*!< Bit mask for USB_ERRSTAT_CRC16. */
#define BS_USB_ERRSTAT_CRC16 (1U)          /*!< Bit field size in bits for USB_ERRSTAT_CRC16. */

/*! @brief Read current value of the USB_ERRSTAT_CRC16 field. */
#define BR_USB_ERRSTAT_CRC16(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_CRC16))

/*! @brief Format value for bitfield USB_ERRSTAT_CRC16. */
#define BF_USB_ERRSTAT_CRC16(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_CRC16) & BM_USB_ERRSTAT_CRC16)

/*! @brief Set the CRC16 field to a new value. */
#define BW_USB_ERRSTAT_CRC16(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_CRC16) = (v))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DFN8[3] (W1C)
 *
 * This bit is set if the data field received was not 8 bits in length. USB
 * Specification 1.0 requires that data fields be an integral number of bytes. If the
 * data field was not an integral number of bytes, this bit is set.
 */
/*@{*/
#define BP_USB_ERRSTAT_DFN8  (3U)          /*!< Bit position for USB_ERRSTAT_DFN8. */
#define BM_USB_ERRSTAT_DFN8  (0x08U)       /*!< Bit mask for USB_ERRSTAT_DFN8. */
#define BS_USB_ERRSTAT_DFN8  (1U)          /*!< Bit field size in bits for USB_ERRSTAT_DFN8. */

/*! @brief Read current value of the USB_ERRSTAT_DFN8 field. */
#define BR_USB_ERRSTAT_DFN8(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_DFN8))

/*! @brief Format value for bitfield USB_ERRSTAT_DFN8. */
#define BF_USB_ERRSTAT_DFN8(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_DFN8) & BM_USB_ERRSTAT_DFN8)

/*! @brief Set the DFN8 field to a new value. */
#define BW_USB_ERRSTAT_DFN8(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_DFN8) = (v))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTOERR[4] (W1C)
 *
 * This bit is set when a bus turnaround timeout error occurs. The USB module
 * contains a bus turnaround timer that keeps track of the amount of time elapsed
 * between the token and data phases of a SETUP or OUT TOKEN or the data and
 * handshake phases of a IN TOKEN. If more than 16 bit times are counted from the
 * previous EOP before a transition from IDLE, a bus turnaround timeout error occurs.
 */
/*@{*/
#define BP_USB_ERRSTAT_BTOERR (4U)         /*!< Bit position for USB_ERRSTAT_BTOERR. */
#define BM_USB_ERRSTAT_BTOERR (0x10U)      /*!< Bit mask for USB_ERRSTAT_BTOERR. */
#define BS_USB_ERRSTAT_BTOERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_BTOERR. */

/*! @brief Read current value of the USB_ERRSTAT_BTOERR field. */
#define BR_USB_ERRSTAT_BTOERR(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_BTOERR))

/*! @brief Format value for bitfield USB_ERRSTAT_BTOERR. */
#define BF_USB_ERRSTAT_BTOERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_BTOERR) & BM_USB_ERRSTAT_BTOERR)

/*! @brief Set the BTOERR field to a new value. */
#define BW_USB_ERRSTAT_BTOERR(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_BTOERR) = (v))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DMAERR[5] (W1C)
 *
 * This bit is set if the USB Module has requested a DMA access to read a new
 * BDT but has not been given the bus before it needs to receive or transmit data.
 * If processing a TX transfer this would cause a transmit data underflow
 * condition. If processing a RX transfer this would cause a receive data overflow
 * condition. This interrupt is useful when developing device arbitration hardware for
 * the microprocessor and the USB module to minimize bus request and bus grant
 * latency. This bit is also set if a data packet to or from the host is larger
 * than the buffer size allocated in the BDT. In this case the data packet is
 * truncated as it is put in buffer memory.
 */
/*@{*/
#define BP_USB_ERRSTAT_DMAERR (5U)         /*!< Bit position for USB_ERRSTAT_DMAERR. */
#define BM_USB_ERRSTAT_DMAERR (0x20U)      /*!< Bit mask for USB_ERRSTAT_DMAERR. */
#define BS_USB_ERRSTAT_DMAERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_DMAERR. */

/*! @brief Read current value of the USB_ERRSTAT_DMAERR field. */
#define BR_USB_ERRSTAT_DMAERR(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_DMAERR))

/*! @brief Format value for bitfield USB_ERRSTAT_DMAERR. */
#define BF_USB_ERRSTAT_DMAERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_DMAERR) & BM_USB_ERRSTAT_DMAERR)

/*! @brief Set the DMAERR field to a new value. */
#define BW_USB_ERRSTAT_DMAERR(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_DMAERR) = (v))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTSERR[7] (W1C)
 *
 * This bit is set when a bit stuff error is detected. If set, the corresponding
 * packet is rejected due to the error.
 */
/*@{*/
#define BP_USB_ERRSTAT_BTSERR (7U)         /*!< Bit position for USB_ERRSTAT_BTSERR. */
#define BM_USB_ERRSTAT_BTSERR (0x80U)      /*!< Bit mask for USB_ERRSTAT_BTSERR. */
#define BS_USB_ERRSTAT_BTSERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_BTSERR. */

/*! @brief Read current value of the USB_ERRSTAT_BTSERR field. */
#define BR_USB_ERRSTAT_BTSERR(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_BTSERR))

/*! @brief Format value for bitfield USB_ERRSTAT_BTSERR. */
#define BF_USB_ERRSTAT_BTSERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_BTSERR) & BM_USB_ERRSTAT_BTSERR)

/*! @brief Set the BTSERR field to a new value. */
#define BW_USB_ERRSTAT_BTSERR(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_BTSERR) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_ERREN - Error Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief HW_USB_ERREN - Error Interrupt Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable bits for each of the error interrupt sources within the USB
 * module. Setting any of these bits enables the respective interrupt source in
 * ERRSTAT. Each bit is set as soon as the error condition is detected. Therefore,
 * the interrupt does not typically correspond with the end of a token being
 * processed. This register contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_erren
{
    uint8_t U;
    struct _hw_usb_erren_bitfields
    {
        uint8_t PIDERREN : 1;          /*!< [0] PIDERR Interrupt Enable */
        uint8_t CRC5EOFEN : 1;         /*!< [1] CRC5/EOF Interrupt Enable */
        uint8_t CRC16EN : 1;           /*!< [2] CRC16 Interrupt Enable */
        uint8_t DFN8EN : 1;            /*!< [3] DFN8 Interrupt Enable */
        uint8_t BTOERREN : 1;          /*!< [4] BTOERR Interrupt Enable */
        uint8_t DMAERREN : 1;          /*!< [5] DMAERR Interrupt Enable */
        uint8_t RESERVED0 : 1;         /*!< [6]  */
        uint8_t BTSERREN : 1;          /*!< [7] BTSERR Interrupt Enable */
    } B;
} hw_usb_erren_t;

/*!
 * @name Constants and macros for entire USB_ERREN register
 */
/*@{*/
#define HW_USB_ERREN_ADDR(x)     ((x) + 0x8CU)

#define HW_USB_ERREN(x)          (*(__IO hw_usb_erren_t *) HW_USB_ERREN_ADDR(x))
#define HW_USB_ERREN_RD(x)       (HW_USB_ERREN(x).U)
#define HW_USB_ERREN_WR(x, v)    (HW_USB_ERREN(x).U = (v))
#define HW_USB_ERREN_SET(x, v)   (HW_USB_ERREN_WR(x, HW_USB_ERREN_RD(x) |  (v)))
#define HW_USB_ERREN_CLR(x, v)   (HW_USB_ERREN_WR(x, HW_USB_ERREN_RD(x) & ~(v)))
#define HW_USB_ERREN_TOG(x, v)   (HW_USB_ERREN_WR(x, HW_USB_ERREN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_ERREN bitfields
 */

/*!
 * @name Register USB_ERREN, field PIDERREN[0] (RW)
 *
 * Values:
 * - 0 - Disables the PIDERR interrupt.
 * - 1 - Enters the PIDERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_PIDERREN (0U)         /*!< Bit position for USB_ERREN_PIDERREN. */
#define BM_USB_ERREN_PIDERREN (0x01U)      /*!< Bit mask for USB_ERREN_PIDERREN. */
#define BS_USB_ERREN_PIDERREN (1U)         /*!< Bit field size in bits for USB_ERREN_PIDERREN. */

/*! @brief Read current value of the USB_ERREN_PIDERREN field. */
#define BR_USB_ERREN_PIDERREN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_PIDERREN))

/*! @brief Format value for bitfield USB_ERREN_PIDERREN. */
#define BF_USB_ERREN_PIDERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_PIDERREN) & BM_USB_ERREN_PIDERREN)

/*! @brief Set the PIDERREN field to a new value. */
#define BW_USB_ERREN_PIDERREN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_PIDERREN) = (v))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC5EOFEN[1] (RW)
 *
 * Values:
 * - 0 - Disables the CRC5/EOF interrupt.
 * - 1 - Enables the CRC5/EOF interrupt.
 */
/*@{*/
#define BP_USB_ERREN_CRC5EOFEN (1U)        /*!< Bit position for USB_ERREN_CRC5EOFEN. */
#define BM_USB_ERREN_CRC5EOFEN (0x02U)     /*!< Bit mask for USB_ERREN_CRC5EOFEN. */
#define BS_USB_ERREN_CRC5EOFEN (1U)        /*!< Bit field size in bits for USB_ERREN_CRC5EOFEN. */

/*! @brief Read current value of the USB_ERREN_CRC5EOFEN field. */
#define BR_USB_ERREN_CRC5EOFEN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_CRC5EOFEN))

/*! @brief Format value for bitfield USB_ERREN_CRC5EOFEN. */
#define BF_USB_ERREN_CRC5EOFEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_CRC5EOFEN) & BM_USB_ERREN_CRC5EOFEN)

/*! @brief Set the CRC5EOFEN field to a new value. */
#define BW_USB_ERREN_CRC5EOFEN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_CRC5EOFEN) = (v))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC16EN[2] (RW)
 *
 * Values:
 * - 0 - Disables the CRC16 interrupt.
 * - 1 - Enables the CRC16 interrupt.
 */
/*@{*/
#define BP_USB_ERREN_CRC16EN (2U)          /*!< Bit position for USB_ERREN_CRC16EN. */
#define BM_USB_ERREN_CRC16EN (0x04U)       /*!< Bit mask for USB_ERREN_CRC16EN. */
#define BS_USB_ERREN_CRC16EN (1U)          /*!< Bit field size in bits for USB_ERREN_CRC16EN. */

/*! @brief Read current value of the USB_ERREN_CRC16EN field. */
#define BR_USB_ERREN_CRC16EN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_CRC16EN))

/*! @brief Format value for bitfield USB_ERREN_CRC16EN. */
#define BF_USB_ERREN_CRC16EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_CRC16EN) & BM_USB_ERREN_CRC16EN)

/*! @brief Set the CRC16EN field to a new value. */
#define BW_USB_ERREN_CRC16EN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_CRC16EN) = (v))
/*@}*/

/*!
 * @name Register USB_ERREN, field DFN8EN[3] (RW)
 *
 * Values:
 * - 0 - Disables the DFN8 interrupt.
 * - 1 - Enables the DFN8 interrupt.
 */
/*@{*/
#define BP_USB_ERREN_DFN8EN  (3U)          /*!< Bit position for USB_ERREN_DFN8EN. */
#define BM_USB_ERREN_DFN8EN  (0x08U)       /*!< Bit mask for USB_ERREN_DFN8EN. */
#define BS_USB_ERREN_DFN8EN  (1U)          /*!< Bit field size in bits for USB_ERREN_DFN8EN. */

/*! @brief Read current value of the USB_ERREN_DFN8EN field. */
#define BR_USB_ERREN_DFN8EN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_DFN8EN))

/*! @brief Format value for bitfield USB_ERREN_DFN8EN. */
#define BF_USB_ERREN_DFN8EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_DFN8EN) & BM_USB_ERREN_DFN8EN)

/*! @brief Set the DFN8EN field to a new value. */
#define BW_USB_ERREN_DFN8EN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_DFN8EN) = (v))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTOERREN[4] (RW)
 *
 * Values:
 * - 0 - Disables the BTOERR interrupt.
 * - 1 - Enables the BTOERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_BTOERREN (4U)         /*!< Bit position for USB_ERREN_BTOERREN. */
#define BM_USB_ERREN_BTOERREN (0x10U)      /*!< Bit mask for USB_ERREN_BTOERREN. */
#define BS_USB_ERREN_BTOERREN (1U)         /*!< Bit field size in bits for USB_ERREN_BTOERREN. */

/*! @brief Read current value of the USB_ERREN_BTOERREN field. */
#define BR_USB_ERREN_BTOERREN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_BTOERREN))

/*! @brief Format value for bitfield USB_ERREN_BTOERREN. */
#define BF_USB_ERREN_BTOERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_BTOERREN) & BM_USB_ERREN_BTOERREN)

/*! @brief Set the BTOERREN field to a new value. */
#define BW_USB_ERREN_BTOERREN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_BTOERREN) = (v))
/*@}*/

/*!
 * @name Register USB_ERREN, field DMAERREN[5] (RW)
 *
 * Values:
 * - 0 - Disables the DMAERR interrupt.
 * - 1 - Enables the DMAERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_DMAERREN (5U)         /*!< Bit position for USB_ERREN_DMAERREN. */
#define BM_USB_ERREN_DMAERREN (0x20U)      /*!< Bit mask for USB_ERREN_DMAERREN. */
#define BS_USB_ERREN_DMAERREN (1U)         /*!< Bit field size in bits for USB_ERREN_DMAERREN. */

/*! @brief Read current value of the USB_ERREN_DMAERREN field. */
#define BR_USB_ERREN_DMAERREN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_DMAERREN))

/*! @brief Format value for bitfield USB_ERREN_DMAERREN. */
#define BF_USB_ERREN_DMAERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_DMAERREN) & BM_USB_ERREN_DMAERREN)

/*! @brief Set the DMAERREN field to a new value. */
#define BW_USB_ERREN_DMAERREN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_DMAERREN) = (v))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTSERREN[7] (RW)
 *
 * Values:
 * - 0 - Disables the BTSERR interrupt.
 * - 1 - Enables the BTSERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_BTSERREN (7U)         /*!< Bit position for USB_ERREN_BTSERREN. */
#define BM_USB_ERREN_BTSERREN (0x80U)      /*!< Bit mask for USB_ERREN_BTSERREN. */
#define BS_USB_ERREN_BTSERREN (1U)         /*!< Bit field size in bits for USB_ERREN_BTSERREN. */

/*! @brief Read current value of the USB_ERREN_BTSERREN field. */
#define BR_USB_ERREN_BTSERREN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_BTSERREN))

/*! @brief Format value for bitfield USB_ERREN_BTSERREN. */
#define BF_USB_ERREN_BTSERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_BTSERREN) & BM_USB_ERREN_BTSERREN)

/*! @brief Set the BTSERREN field to a new value. */
#define BW_USB_ERREN_BTSERREN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_BTSERREN) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_STAT - Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_STAT - Status register (RO)
 *
 * Reset value: 0x00U
 *
 * Reports the transaction status within the USB module. When the processor's
 * interrupt controller has received a TOKDNE, interrupt the Status Register must
 * be read to determine the status of the previous endpoint communication. The
 * data in the status register is valid when TOKDNE interrupt is asserted. The
 * Status register is actually a read window into a status FIFO maintained by the USB
 * module. When the USB module uses a BD, it updates the Status register. If
 * another USB transaction is performed before the TOKDNE interrupt is serviced, the
 * USB module stores the status of the next transaction in the STAT FIFO. Thus
 * STAT is actually a four byte FIFO that allows the processor core to process one
 * transaction while the SIE is processing the next transaction. Clearing the
 * TOKDNE bit in the ISTAT register causes the SIE to update STAT with the contents
 * of the next STAT value. If the data in the STAT holding register is valid, the
 * SIE immediately reasserts to TOKDNE interrupt.
 */
typedef union _hw_usb_stat
{
    uint8_t U;
    struct _hw_usb_stat_bitfields
    {
        uint8_t RESERVED0 : 2;         /*!< [1:0]  */
        uint8_t ODD : 1;               /*!< [2]  */
        uint8_t TX : 1;                /*!< [3] Transmit Indicator */
        uint8_t ENDP : 4;              /*!< [7:4]  */
    } B;
} hw_usb_stat_t;

/*!
 * @name Constants and macros for entire USB_STAT register
 */
/*@{*/
#define HW_USB_STAT_ADDR(x)      ((x) + 0x90U)

#define HW_USB_STAT(x)           (*(__I hw_usb_stat_t *) HW_USB_STAT_ADDR(x))
#define HW_USB_STAT_RD(x)        (HW_USB_STAT(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_STAT bitfields
 */

/*!
 * @name Register USB_STAT, field ODD[2] (RO)
 *
 * This bit is set if the last buffer descriptor updated was in the odd bank of
 * the BDT.
 */
/*@{*/
#define BP_USB_STAT_ODD      (2U)          /*!< Bit position for USB_STAT_ODD. */
#define BM_USB_STAT_ODD      (0x04U)       /*!< Bit mask for USB_STAT_ODD. */
#define BS_USB_STAT_ODD      (1U)          /*!< Bit field size in bits for USB_STAT_ODD. */

/*! @brief Read current value of the USB_STAT_ODD field. */
#define BR_USB_STAT_ODD(x)   (BITBAND_ACCESS8(HW_USB_STAT_ADDR(x), BP_USB_STAT_ODD))
/*@}*/

/*!
 * @name Register USB_STAT, field TX[3] (RO)
 *
 * Values:
 * - 0 - The most recent transaction was a receive operation.
 * - 1 - The most recent transaction was a transmit operation.
 */
/*@{*/
#define BP_USB_STAT_TX       (3U)          /*!< Bit position for USB_STAT_TX. */
#define BM_USB_STAT_TX       (0x08U)       /*!< Bit mask for USB_STAT_TX. */
#define BS_USB_STAT_TX       (1U)          /*!< Bit field size in bits for USB_STAT_TX. */

/*! @brief Read current value of the USB_STAT_TX field. */
#define BR_USB_STAT_TX(x)    (BITBAND_ACCESS8(HW_USB_STAT_ADDR(x), BP_USB_STAT_TX))
/*@}*/

/*!
 * @name Register USB_STAT, field ENDP[7:4] (RO)
 *
 * This four-bit field encodes the endpoint address that received or transmitted
 * the previous token. This allows the processor core to determine the BDT entry
 * that was updated by the last USB transaction.
 */
/*@{*/
#define BP_USB_STAT_ENDP     (4U)          /*!< Bit position for USB_STAT_ENDP. */
#define BM_USB_STAT_ENDP     (0xF0U)       /*!< Bit mask for USB_STAT_ENDP. */
#define BS_USB_STAT_ENDP     (4U)          /*!< Bit field size in bits for USB_STAT_ENDP. */

/*! @brief Read current value of the USB_STAT_ENDP field. */
#define BR_USB_STAT_ENDP(x)  (HW_USB_STAT(x).B.ENDP)
/*@}*/

/*******************************************************************************
 * HW_USB_CTL - Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_CTL - Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Provides various control and configuration information for the USB module.
 */
typedef union _hw_usb_ctl
{
    uint8_t U;
    struct _hw_usb_ctl_bitfields
    {
        uint8_t USBENSOFEN : 1;        /*!< [0] USB Enable */
        uint8_t ODDRST : 1;            /*!< [1]  */
        uint8_t RESUME : 1;            /*!< [2]  */
        uint8_t HOSTMODEEN : 1;        /*!< [3]  */
        uint8_t RESET : 1;             /*!< [4]  */
        uint8_t TXSUSPENDTOKENBUSY : 1; /*!< [5]  */
        uint8_t SE0 : 1;               /*!< [6] Live USB Single Ended Zero signal */
        uint8_t JSTATE : 1;            /*!< [7] Live USB differential receiver JSTATE
                                        * signal */
    } B;
} hw_usb_ctl_t;

/*!
 * @name Constants and macros for entire USB_CTL register
 */
/*@{*/
#define HW_USB_CTL_ADDR(x)       ((x) + 0x94U)

#define HW_USB_CTL(x)            (*(__IO hw_usb_ctl_t *) HW_USB_CTL_ADDR(x))
#define HW_USB_CTL_RD(x)         (HW_USB_CTL(x).U)
#define HW_USB_CTL_WR(x, v)      (HW_USB_CTL(x).U = (v))
#define HW_USB_CTL_SET(x, v)     (HW_USB_CTL_WR(x, HW_USB_CTL_RD(x) |  (v)))
#define HW_USB_CTL_CLR(x, v)     (HW_USB_CTL_WR(x, HW_USB_CTL_RD(x) & ~(v)))
#define HW_USB_CTL_TOG(x, v)     (HW_USB_CTL_WR(x, HW_USB_CTL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_CTL bitfields
 */

/*!
 * @name Register USB_CTL, field USBENSOFEN[0] (RW)
 *
 * Setting this bit enables the USB-FS to operate; clearing it disables the
 * USB-FS. Setting the bit causes the SIE to reset all of its ODD bits to the BDTs.
 * Therefore, setting this bit resets much of the logic in the SIE. When host mode
 * is enabled, clearing this bit causes the SIE to stop sending SOF tokens.
 *
 * Values:
 * - 0 - Disables the USB Module.
 * - 1 - Enables the USB Module.
 */
/*@{*/
#define BP_USB_CTL_USBENSOFEN (0U)         /*!< Bit position for USB_CTL_USBENSOFEN. */
#define BM_USB_CTL_USBENSOFEN (0x01U)      /*!< Bit mask for USB_CTL_USBENSOFEN. */
#define BS_USB_CTL_USBENSOFEN (1U)         /*!< Bit field size in bits for USB_CTL_USBENSOFEN. */

/*! @brief Read current value of the USB_CTL_USBENSOFEN field. */
#define BR_USB_CTL_USBENSOFEN(x) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_USBENSOFEN))

/*! @brief Format value for bitfield USB_CTL_USBENSOFEN. */
#define BF_USB_CTL_USBENSOFEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_USBENSOFEN) & BM_USB_CTL_USBENSOFEN)

/*! @brief Set the USBENSOFEN field to a new value. */
#define BW_USB_CTL_USBENSOFEN(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_USBENSOFEN) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field ODDRST[1] (RW)
 *
 * Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which
 * then specifies the EVEN BDT bank.
 */
/*@{*/
#define BP_USB_CTL_ODDRST    (1U)          /*!< Bit position for USB_CTL_ODDRST. */
#define BM_USB_CTL_ODDRST    (0x02U)       /*!< Bit mask for USB_CTL_ODDRST. */
#define BS_USB_CTL_ODDRST    (1U)          /*!< Bit field size in bits for USB_CTL_ODDRST. */

/*! @brief Read current value of the USB_CTL_ODDRST field. */
#define BR_USB_CTL_ODDRST(x) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_ODDRST))

/*! @brief Format value for bitfield USB_CTL_ODDRST. */
#define BF_USB_CTL_ODDRST(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_ODDRST) & BM_USB_CTL_ODDRST)

/*! @brief Set the ODDRST field to a new value. */
#define BW_USB_CTL_ODDRST(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_ODDRST) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field RESUME[2] (RW)
 *
 * When set to 1 this bit enables the USB Module to execute resume signaling.
 * This allows the USB Module to perform remote wake-up. Software must set RESUME
 * to 1 for the required amount of time and then clear it to 0. If the HOSTMODEEN
 * bit is set, the USB module appends a Low Speed End of Packet to the Resume
 * signaling when the RESUME bit is cleared. For more information on RESUME
 * signaling see Section 7.1.4.5 of the USB specification version 1.0.
 */
/*@{*/
#define BP_USB_CTL_RESUME    (2U)          /*!< Bit position for USB_CTL_RESUME. */
#define BM_USB_CTL_RESUME    (0x04U)       /*!< Bit mask for USB_CTL_RESUME. */
#define BS_USB_CTL_RESUME    (1U)          /*!< Bit field size in bits for USB_CTL_RESUME. */

/*! @brief Read current value of the USB_CTL_RESUME field. */
#define BR_USB_CTL_RESUME(x) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_RESUME))

/*! @brief Format value for bitfield USB_CTL_RESUME. */
#define BF_USB_CTL_RESUME(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_RESUME) & BM_USB_CTL_RESUME)

/*! @brief Set the RESUME field to a new value. */
#define BW_USB_CTL_RESUME(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_RESUME) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field HOSTMODEEN[3] (RW)
 *
 * When set to 1, this bit enables the USB Module to operate in Host mode. In
 * host mode, the USB module performs USB transactions under the programmed control
 * of the host processor.
 */
/*@{*/
#define BP_USB_CTL_HOSTMODEEN (3U)         /*!< Bit position for USB_CTL_HOSTMODEEN. */
#define BM_USB_CTL_HOSTMODEEN (0x08U)      /*!< Bit mask for USB_CTL_HOSTMODEEN. */
#define BS_USB_CTL_HOSTMODEEN (1U)         /*!< Bit field size in bits for USB_CTL_HOSTMODEEN. */

/*! @brief Read current value of the USB_CTL_HOSTMODEEN field. */
#define BR_USB_CTL_HOSTMODEEN(x) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_HOSTMODEEN))

/*! @brief Format value for bitfield USB_CTL_HOSTMODEEN. */
#define BF_USB_CTL_HOSTMODEEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_HOSTMODEEN) & BM_USB_CTL_HOSTMODEEN)

/*! @brief Set the HOSTMODEEN field to a new value. */
#define BW_USB_CTL_HOSTMODEEN(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_HOSTMODEEN) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field RESET[4] (RW)
 *
 * Setting this bit enables the USB Module to generate USB reset signaling. This
 * allows the USB Module to reset USB peripherals. This control signal is only
 * valid in Host mode (HOSTMODEEN=1). Software must set RESET to 1 for the
 * required amount of time and then clear it to 0 to end reset signaling. For more
 * information on reset signaling see Section 7.1.4.3 of the USB specification version
 * 1.0.
 */
/*@{*/
#define BP_USB_CTL_RESET     (4U)          /*!< Bit position for USB_CTL_RESET. */
#define BM_USB_CTL_RESET     (0x10U)       /*!< Bit mask for USB_CTL_RESET. */
#define BS_USB_CTL_RESET     (1U)          /*!< Bit field size in bits for USB_CTL_RESET. */

/*! @brief Read current value of the USB_CTL_RESET field. */
#define BR_USB_CTL_RESET(x)  (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_RESET))

/*! @brief Format value for bitfield USB_CTL_RESET. */
#define BF_USB_CTL_RESET(v)  ((uint8_t)((uint8_t)(v) << BP_USB_CTL_RESET) & BM_USB_CTL_RESET)

/*! @brief Set the RESET field to a new value. */
#define BW_USB_CTL_RESET(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_RESET) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field TXSUSPENDTOKENBUSY[5] (RW)
 *
 * In Host mode, TOKEN_BUSY is set when the USB module is busy executing a USB
 * token. Software must not write more token commands to the Token Register when
 * TOKEN_BUSY is set. Software should check this field before writing any tokens
 * to the Token Register to ensure that token commands are not lost. In Target
 * mode, TXD_SUSPEND is set when the SIE has disabled packet transmission and
 * reception. Clearing this bit allows the SIE to continue token processing. This bit
 * is set by the SIE when a SETUP Token is received allowing software to dequeue
 * any pending packet transactions in the BDT before resuming token processing.
 */
/*@{*/
#define BP_USB_CTL_TXSUSPENDTOKENBUSY (5U) /*!< Bit position for USB_CTL_TXSUSPENDTOKENBUSY. */
#define BM_USB_CTL_TXSUSPENDTOKENBUSY (0x20U) /*!< Bit mask for USB_CTL_TXSUSPENDTOKENBUSY. */
#define BS_USB_CTL_TXSUSPENDTOKENBUSY (1U) /*!< Bit field size in bits for USB_CTL_TXSUSPENDTOKENBUSY. */

/*! @brief Read current value of the USB_CTL_TXSUSPENDTOKENBUSY field. */
#define BR_USB_CTL_TXSUSPENDTOKENBUSY(x) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_TXSUSPENDTOKENBUSY))

/*! @brief Format value for bitfield USB_CTL_TXSUSPENDTOKENBUSY. */
#define BF_USB_CTL_TXSUSPENDTOKENBUSY(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_TXSUSPENDTOKENBUSY) & BM_USB_CTL_TXSUSPENDTOKENBUSY)

/*! @brief Set the TXSUSPENDTOKENBUSY field to a new value. */
#define BW_USB_CTL_TXSUSPENDTOKENBUSY(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_TXSUSPENDTOKENBUSY) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field SE0[6] (RW)
 */
/*@{*/
#define BP_USB_CTL_SE0       (6U)          /*!< Bit position for USB_CTL_SE0. */
#define BM_USB_CTL_SE0       (0x40U)       /*!< Bit mask for USB_CTL_SE0. */
#define BS_USB_CTL_SE0       (1U)          /*!< Bit field size in bits for USB_CTL_SE0. */

/*! @brief Read current value of the USB_CTL_SE0 field. */
#define BR_USB_CTL_SE0(x)    (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_SE0))

/*! @brief Format value for bitfield USB_CTL_SE0. */
#define BF_USB_CTL_SE0(v)    ((uint8_t)((uint8_t)(v) << BP_USB_CTL_SE0) & BM_USB_CTL_SE0)

/*! @brief Set the SE0 field to a new value. */
#define BW_USB_CTL_SE0(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_SE0) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field JSTATE[7] (RW)
 *
 * The polarity of this signal is affected by the current state of LSEN .
 */
/*@{*/
#define BP_USB_CTL_JSTATE    (7U)          /*!< Bit position for USB_CTL_JSTATE. */
#define BM_USB_CTL_JSTATE    (0x80U)       /*!< Bit mask for USB_CTL_JSTATE. */
#define BS_USB_CTL_JSTATE    (1U)          /*!< Bit field size in bits for USB_CTL_JSTATE. */

/*! @brief Read current value of the USB_CTL_JSTATE field. */
#define BR_USB_CTL_JSTATE(x) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_JSTATE))

/*! @brief Format value for bitfield USB_CTL_JSTATE. */
#define BF_USB_CTL_JSTATE(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_JSTATE) & BM_USB_CTL_JSTATE)

/*! @brief Set the JSTATE field to a new value. */
#define BW_USB_CTL_JSTATE(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_JSTATE) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_ADDR - Address register
 ******************************************************************************/

/*!
 * @brief HW_USB_ADDR - Address register (RW)
 *
 * Reset value: 0x00U
 *
 * Holds the unique USB address that the USB module decodes when in Peripheral
 * mode (HOSTMODEEN=0). When operating in Host mode (HOSTMODEEN=1) the USB module
 * transmits this address with a TOKEN packet. This enables the USB module to
 * uniquely address any USB peripheral. In either mode, CTL[USBENSOFEN] must be 1.
 * The Address register is reset to 0x00 after the reset input becomes active or
 * the USB module decodes a USB reset signal. This action initializes the Address
 * register to decode address 0x00 as required by the USB specification.
 */
typedef union _hw_usb_addr
{
    uint8_t U;
    struct _hw_usb_addr_bitfields
    {
        uint8_t ADDR : 7;              /*!< [6:0] USB Address */
        uint8_t LSEN : 1;              /*!< [7] Low Speed Enable bit */
    } B;
} hw_usb_addr_t;

/*!
 * @name Constants and macros for entire USB_ADDR register
 */
/*@{*/
#define HW_USB_ADDR_ADDR(x)      ((x) + 0x98U)

#define HW_USB_ADDR(x)           (*(__IO hw_usb_addr_t *) HW_USB_ADDR_ADDR(x))
#define HW_USB_ADDR_RD(x)        (HW_USB_ADDR(x).U)
#define HW_USB_ADDR_WR(x, v)     (HW_USB_ADDR(x).U = (v))
#define HW_USB_ADDR_SET(x, v)    (HW_USB_ADDR_WR(x, HW_USB_ADDR_RD(x) |  (v)))
#define HW_USB_ADDR_CLR(x, v)    (HW_USB_ADDR_WR(x, HW_USB_ADDR_RD(x) & ~(v)))
#define HW_USB_ADDR_TOG(x, v)    (HW_USB_ADDR_WR(x, HW_USB_ADDR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_ADDR bitfields
 */

/*!
 * @name Register USB_ADDR, field ADDR[6:0] (RW)
 *
 * Defines the USB address that the USB module decodes in peripheral mode, or
 * transmits when in host mode.
 */
/*@{*/
#define BP_USB_ADDR_ADDR     (0U)          /*!< Bit position for USB_ADDR_ADDR. */
#define BM_USB_ADDR_ADDR     (0x7FU)       /*!< Bit mask for USB_ADDR_ADDR. */
#define BS_USB_ADDR_ADDR     (7U)          /*!< Bit field size in bits for USB_ADDR_ADDR. */

/*! @brief Read current value of the USB_ADDR_ADDR field. */
#define BR_USB_ADDR_ADDR(x)  (HW_USB_ADDR(x).B.ADDR)

/*! @brief Format value for bitfield USB_ADDR_ADDR. */
#define BF_USB_ADDR_ADDR(v)  ((uint8_t)((uint8_t)(v) << BP_USB_ADDR_ADDR) & BM_USB_ADDR_ADDR)

/*! @brief Set the ADDR field to a new value. */
#define BW_USB_ADDR_ADDR(x, v) (HW_USB_ADDR_WR(x, (HW_USB_ADDR_RD(x) & ~BM_USB_ADDR_ADDR) | BF_USB_ADDR_ADDR(v)))
/*@}*/

/*!
 * @name Register USB_ADDR, field LSEN[7] (RW)
 *
 * Informs the USB module that the next token command written to the token
 * register must be performed at low speed. This enables the USB module to perform the
 * necessary preamble required for low-speed data transmissions.
 */
/*@{*/
#define BP_USB_ADDR_LSEN     (7U)          /*!< Bit position for USB_ADDR_LSEN. */
#define BM_USB_ADDR_LSEN     (0x80U)       /*!< Bit mask for USB_ADDR_LSEN. */
#define BS_USB_ADDR_LSEN     (1U)          /*!< Bit field size in bits for USB_ADDR_LSEN. */

/*! @brief Read current value of the USB_ADDR_LSEN field. */
#define BR_USB_ADDR_LSEN(x)  (BITBAND_ACCESS8(HW_USB_ADDR_ADDR(x), BP_USB_ADDR_LSEN))

/*! @brief Format value for bitfield USB_ADDR_LSEN. */
#define BF_USB_ADDR_LSEN(v)  ((uint8_t)((uint8_t)(v) << BP_USB_ADDR_LSEN) & BM_USB_ADDR_LSEN)

/*! @brief Set the LSEN field to a new value. */
#define BW_USB_ADDR_LSEN(x, v) (BITBAND_ACCESS8(HW_USB_ADDR_ADDR(x), BP_USB_ADDR_LSEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_BDTPAGE1 - BDT Page register 1
 ******************************************************************************/

/*!
 * @brief HW_USB_BDTPAGE1 - BDT Page register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * Provides address bits 15 through 9 of the base address where the current
 * Buffer Descriptor Table (BDT) resides in system memory. The 32-bit BDT Base
 * Address is always aligned on 512-byte boundaries, so bits 8 through 0 of the base
 * address are always zero.
 */
typedef union _hw_usb_bdtpage1
{
    uint8_t U;
    struct _hw_usb_bdtpage1_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t BDTBA : 7;             /*!< [7:1]  */
    } B;
} hw_usb_bdtpage1_t;

/*!
 * @name Constants and macros for entire USB_BDTPAGE1 register
 */
/*@{*/
#define HW_USB_BDTPAGE1_ADDR(x)  ((x) + 0x9CU)

#define HW_USB_BDTPAGE1(x)       (*(__IO hw_usb_bdtpage1_t *) HW_USB_BDTPAGE1_ADDR(x))
#define HW_USB_BDTPAGE1_RD(x)    (HW_USB_BDTPAGE1(x).U)
#define HW_USB_BDTPAGE1_WR(x, v) (HW_USB_BDTPAGE1(x).U = (v))
#define HW_USB_BDTPAGE1_SET(x, v) (HW_USB_BDTPAGE1_WR(x, HW_USB_BDTPAGE1_RD(x) |  (v)))
#define HW_USB_BDTPAGE1_CLR(x, v) (HW_USB_BDTPAGE1_WR(x, HW_USB_BDTPAGE1_RD(x) & ~(v)))
#define HW_USB_BDTPAGE1_TOG(x, v) (HW_USB_BDTPAGE1_WR(x, HW_USB_BDTPAGE1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE1 bitfields
 */

/*!
 * @name Register USB_BDTPAGE1, field BDTBA[7:1] (RW)
 *
 * Provides address bits 15 through 9 of the BDT base address.
 */
/*@{*/
#define BP_USB_BDTPAGE1_BDTBA (1U)         /*!< Bit position for USB_BDTPAGE1_BDTBA. */
#define BM_USB_BDTPAGE1_BDTBA (0xFEU)      /*!< Bit mask for USB_BDTPAGE1_BDTBA. */
#define BS_USB_BDTPAGE1_BDTBA (7U)         /*!< Bit field size in bits for USB_BDTPAGE1_BDTBA. */

/*! @brief Read current value of the USB_BDTPAGE1_BDTBA field. */
#define BR_USB_BDTPAGE1_BDTBA(x) (HW_USB_BDTPAGE1(x).B.BDTBA)

/*! @brief Format value for bitfield USB_BDTPAGE1_BDTBA. */
#define BF_USB_BDTPAGE1_BDTBA(v) ((uint8_t)((uint8_t)(v) << BP_USB_BDTPAGE1_BDTBA) & BM_USB_BDTPAGE1_BDTBA)

/*! @brief Set the BDTBA field to a new value. */
#define BW_USB_BDTPAGE1_BDTBA(x, v) (HW_USB_BDTPAGE1_WR(x, (HW_USB_BDTPAGE1_RD(x) & ~BM_USB_BDTPAGE1_BDTBA) | BF_USB_BDTPAGE1_BDTBA(v)))
/*@}*/

/*******************************************************************************
 * HW_USB_FRMNUML - Frame Number register Low
 ******************************************************************************/

/*!
 * @brief HW_USB_FRMNUML - Frame Number register Low (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number registers (low and high) contain the 11-bit frame number.
 * These registers are updated with the current frame number whenever a SOF TOKEN
 * is received.
 */
typedef union _hw_usb_frmnuml
{
    uint8_t U;
    struct _hw_usb_frmnuml_bitfields
    {
        uint8_t FRM : 8;               /*!< [7:0]  */
    } B;
} hw_usb_frmnuml_t;

/*!
 * @name Constants and macros for entire USB_FRMNUML register
 */
/*@{*/
#define HW_USB_FRMNUML_ADDR(x)   ((x) + 0xA0U)

#define HW_USB_FRMNUML(x)        (*(__IO hw_usb_frmnuml_t *) HW_USB_FRMNUML_ADDR(x))
#define HW_USB_FRMNUML_RD(x)     (HW_USB_FRMNUML(x).U)
#define HW_USB_FRMNUML_WR(x, v)  (HW_USB_FRMNUML(x).U = (v))
#define HW_USB_FRMNUML_SET(x, v) (HW_USB_FRMNUML_WR(x, HW_USB_FRMNUML_RD(x) |  (v)))
#define HW_USB_FRMNUML_CLR(x, v) (HW_USB_FRMNUML_WR(x, HW_USB_FRMNUML_RD(x) & ~(v)))
#define HW_USB_FRMNUML_TOG(x, v) (HW_USB_FRMNUML_WR(x, HW_USB_FRMNUML_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_FRMNUML bitfields
 */

/*!
 * @name Register USB_FRMNUML, field FRM[7:0] (RW)
 *
 * This 8-bit field and the 3-bit field in the Frame Number Register High are
 * used to compute the address where the current Buffer Descriptor Table (BDT)
 * resides in system memory.
 */
/*@{*/
#define BP_USB_FRMNUML_FRM   (0U)          /*!< Bit position for USB_FRMNUML_FRM. */
#define BM_USB_FRMNUML_FRM   (0xFFU)       /*!< Bit mask for USB_FRMNUML_FRM. */
#define BS_USB_FRMNUML_FRM   (8U)          /*!< Bit field size in bits for USB_FRMNUML_FRM. */

/*! @brief Read current value of the USB_FRMNUML_FRM field. */
#define BR_USB_FRMNUML_FRM(x) (HW_USB_FRMNUML(x).U)

/*! @brief Format value for bitfield USB_FRMNUML_FRM. */
#define BF_USB_FRMNUML_FRM(v) ((uint8_t)((uint8_t)(v) << BP_USB_FRMNUML_FRM) & BM_USB_FRMNUML_FRM)

/*! @brief Set the FRM field to a new value. */
#define BW_USB_FRMNUML_FRM(x, v) (HW_USB_FRMNUML_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_FRMNUMH - Frame Number register High
 ******************************************************************************/

/*!
 * @brief HW_USB_FRMNUMH - Frame Number register High (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number registers (low and high) contain the 11-bit frame number.
 * These registers are updated with the current frame number whenever a SOF TOKEN
 * is received.
 */
typedef union _hw_usb_frmnumh
{
    uint8_t U;
    struct _hw_usb_frmnumh_bitfields
    {
        uint8_t FRM : 3;               /*!< [2:0]  */
        uint8_t RESERVED0 : 5;         /*!< [7:3]  */
    } B;
} hw_usb_frmnumh_t;

/*!
 * @name Constants and macros for entire USB_FRMNUMH register
 */
/*@{*/
#define HW_USB_FRMNUMH_ADDR(x)   ((x) + 0xA4U)

#define HW_USB_FRMNUMH(x)        (*(__IO hw_usb_frmnumh_t *) HW_USB_FRMNUMH_ADDR(x))
#define HW_USB_FRMNUMH_RD(x)     (HW_USB_FRMNUMH(x).U)
#define HW_USB_FRMNUMH_WR(x, v)  (HW_USB_FRMNUMH(x).U = (v))
#define HW_USB_FRMNUMH_SET(x, v) (HW_USB_FRMNUMH_WR(x, HW_USB_FRMNUMH_RD(x) |  (v)))
#define HW_USB_FRMNUMH_CLR(x, v) (HW_USB_FRMNUMH_WR(x, HW_USB_FRMNUMH_RD(x) & ~(v)))
#define HW_USB_FRMNUMH_TOG(x, v) (HW_USB_FRMNUMH_WR(x, HW_USB_FRMNUMH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_FRMNUMH bitfields
 */

/*!
 * @name Register USB_FRMNUMH, field FRM[2:0] (RW)
 *
 * This 3-bit field and the 8-bit field in the Frame Number Register Low are
 * used to compute the address where the current Buffer Descriptor Table (BDT)
 * resides in system memory.
 */
/*@{*/
#define BP_USB_FRMNUMH_FRM   (0U)          /*!< Bit position for USB_FRMNUMH_FRM. */
#define BM_USB_FRMNUMH_FRM   (0x07U)       /*!< Bit mask for USB_FRMNUMH_FRM. */
#define BS_USB_FRMNUMH_FRM   (3U)          /*!< Bit field size in bits for USB_FRMNUMH_FRM. */

/*! @brief Read current value of the USB_FRMNUMH_FRM field. */
#define BR_USB_FRMNUMH_FRM(x) (HW_USB_FRMNUMH(x).B.FRM)

/*! @brief Format value for bitfield USB_FRMNUMH_FRM. */
#define BF_USB_FRMNUMH_FRM(v) ((uint8_t)((uint8_t)(v) << BP_USB_FRMNUMH_FRM) & BM_USB_FRMNUMH_FRM)

/*! @brief Set the FRM field to a new value. */
#define BW_USB_FRMNUMH_FRM(x, v) (HW_USB_FRMNUMH_WR(x, (HW_USB_FRMNUMH_RD(x) & ~BM_USB_FRMNUMH_FRM) | BF_USB_FRMNUMH_FRM(v)))
/*@}*/

/*******************************************************************************
 * HW_USB_TOKEN - Token register
 ******************************************************************************/

/*!
 * @brief HW_USB_TOKEN - Token register (RW)
 *
 * Reset value: 0x00U
 *
 * Used to initiate USB transactions when in host mode (HOSTMODEEN=1). When the
 * software needs to execute a USB transaction to a peripheral, it writes the
 * TOKEN type and endpoint to this register. After this register has been written,
 * the USB module begins the specified USB transaction to the address contained in
 * the address register. The processor core must always check that the
 * TOKEN_BUSY bit in the control register is not 1 before writing to the Token Register.
 * This ensures that the token commands are not overwritten before they can be
 * executed. The address register and endpoint control register 0 are also used when
 * performing a token command and therefore must also be written before the
 * Token Register. The address register is used to select the USB peripheral address
 * transmitted by the token command. The endpoint control register determines the
 * handshake and retry policies used during the transfer.
 */
typedef union _hw_usb_token
{
    uint8_t U;
    struct _hw_usb_token_bitfields
    {
        uint8_t TOKENENDPT : 4;        /*!< [3:0]  */
        uint8_t TOKENPID : 4;          /*!< [7:4]  */
    } B;
} hw_usb_token_t;

/*!
 * @name Constants and macros for entire USB_TOKEN register
 */
/*@{*/
#define HW_USB_TOKEN_ADDR(x)     ((x) + 0xA8U)

#define HW_USB_TOKEN(x)          (*(__IO hw_usb_token_t *) HW_USB_TOKEN_ADDR(x))
#define HW_USB_TOKEN_RD(x)       (HW_USB_TOKEN(x).U)
#define HW_USB_TOKEN_WR(x, v)    (HW_USB_TOKEN(x).U = (v))
#define HW_USB_TOKEN_SET(x, v)   (HW_USB_TOKEN_WR(x, HW_USB_TOKEN_RD(x) |  (v)))
#define HW_USB_TOKEN_CLR(x, v)   (HW_USB_TOKEN_WR(x, HW_USB_TOKEN_RD(x) & ~(v)))
#define HW_USB_TOKEN_TOG(x, v)   (HW_USB_TOKEN_WR(x, HW_USB_TOKEN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_TOKEN bitfields
 */

/*!
 * @name Register USB_TOKEN, field TOKENENDPT[3:0] (RW)
 *
 * Holds the Endpoint address for the token command. The four bit value written
 * must be a valid endpoint.
 */
/*@{*/
#define BP_USB_TOKEN_TOKENENDPT (0U)       /*!< Bit position for USB_TOKEN_TOKENENDPT. */
#define BM_USB_TOKEN_TOKENENDPT (0x0FU)    /*!< Bit mask for USB_TOKEN_TOKENENDPT. */
#define BS_USB_TOKEN_TOKENENDPT (4U)       /*!< Bit field size in bits for USB_TOKEN_TOKENENDPT. */

/*! @brief Read current value of the USB_TOKEN_TOKENENDPT field. */
#define BR_USB_TOKEN_TOKENENDPT(x) (HW_USB_TOKEN(x).B.TOKENENDPT)

/*! @brief Format value for bitfield USB_TOKEN_TOKENENDPT. */
#define BF_USB_TOKEN_TOKENENDPT(v) ((uint8_t)((uint8_t)(v) << BP_USB_TOKEN_TOKENENDPT) & BM_USB_TOKEN_TOKENENDPT)

/*! @brief Set the TOKENENDPT field to a new value. */
#define BW_USB_TOKEN_TOKENENDPT(x, v) (HW_USB_TOKEN_WR(x, (HW_USB_TOKEN_RD(x) & ~BM_USB_TOKEN_TOKENENDPT) | BF_USB_TOKEN_TOKENENDPT(v)))
/*@}*/

/*!
 * @name Register USB_TOKEN, field TOKENPID[7:4] (RW)
 *
 * Contains the token type executed by the USB module.
 *
 * Values:
 * - 0001 - OUT Token. USB Module performs an OUT (TX) transaction.
 * - 1001 - IN Token. USB Module performs an In (RX) transaction.
 * - 1101 - SETUP Token. USB Module performs a SETUP (TX) transaction
 */
/*@{*/
#define BP_USB_TOKEN_TOKENPID (4U)         /*!< Bit position for USB_TOKEN_TOKENPID. */
#define BM_USB_TOKEN_TOKENPID (0xF0U)      /*!< Bit mask for USB_TOKEN_TOKENPID. */
#define BS_USB_TOKEN_TOKENPID (4U)         /*!< Bit field size in bits for USB_TOKEN_TOKENPID. */

/*! @brief Read current value of the USB_TOKEN_TOKENPID field. */
#define BR_USB_TOKEN_TOKENPID(x) (HW_USB_TOKEN(x).B.TOKENPID)

/*! @brief Format value for bitfield USB_TOKEN_TOKENPID. */
#define BF_USB_TOKEN_TOKENPID(v) ((uint8_t)((uint8_t)(v) << BP_USB_TOKEN_TOKENPID) & BM_USB_TOKEN_TOKENPID)

/*! @brief Set the TOKENPID field to a new value. */
#define BW_USB_TOKEN_TOKENPID(x, v) (HW_USB_TOKEN_WR(x, (HW_USB_TOKEN_RD(x) & ~BM_USB_TOKEN_TOKENPID) | BF_USB_TOKEN_TOKENPID(v)))
/*@}*/

/*******************************************************************************
 * HW_USB_SOFTHLD - SOF Threshold register
 ******************************************************************************/

/*!
 * @brief HW_USB_SOFTHLD - SOF Threshold register (RW)
 *
 * Reset value: 0x00U
 *
 * The SOF Threshold Register is used only in Host mode (HOSTMODEEN=1). When in
 * Host mode, the 14-bit SOF counter counts the interval between SOF frames. The
 * SOF must be transmitted every 1ms so therefore the SOF counter is loaded with
 * a value of 12000. When the SOF counter reaches zero, a Start Of Frame (SOF)
 * token is transmitted. The SOF threshold register is used to program the number
 * of USB byte times before the SOF to stop initiating token packet transactions.
 * This register must be set to a value that ensures that other packets are not
 * actively being transmitted when the SOF time counts to zero. When the SOF
 * counter reaches the threshold value, no more tokens are transmitted until after the
 * SOF has been transmitted. The value programmed into the threshold register
 * must reserve enough time to ensure the worst case transaction completes. In
 * general the worst case transaction is an IN token followed by a data packet from
 * the target followed by the response from the host. The actual time required is
 * a function of the maximum packet size on the bus. Typical values for the SOF
 * threshold are: 64-byte packets=74; 32-byte packets=42; 16-byte packets=26;
 * 8-byte packets=18.
 */
typedef union _hw_usb_softhld
{
    uint8_t U;
    struct _hw_usb_softhld_bitfields
    {
        uint8_t CNT : 8;               /*!< [7:0]  */
    } B;
} hw_usb_softhld_t;

/*!
 * @name Constants and macros for entire USB_SOFTHLD register
 */
/*@{*/
#define HW_USB_SOFTHLD_ADDR(x)   ((x) + 0xACU)

#define HW_USB_SOFTHLD(x)        (*(__IO hw_usb_softhld_t *) HW_USB_SOFTHLD_ADDR(x))
#define HW_USB_SOFTHLD_RD(x)     (HW_USB_SOFTHLD(x).U)
#define HW_USB_SOFTHLD_WR(x, v)  (HW_USB_SOFTHLD(x).U = (v))
#define HW_USB_SOFTHLD_SET(x, v) (HW_USB_SOFTHLD_WR(x, HW_USB_SOFTHLD_RD(x) |  (v)))
#define HW_USB_SOFTHLD_CLR(x, v) (HW_USB_SOFTHLD_WR(x, HW_USB_SOFTHLD_RD(x) & ~(v)))
#define HW_USB_SOFTHLD_TOG(x, v) (HW_USB_SOFTHLD_WR(x, HW_USB_SOFTHLD_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_SOFTHLD bitfields
 */

/*!
 * @name Register USB_SOFTHLD, field CNT[7:0] (RW)
 *
 * Represents the SOF count threshold in byte times.
 */
/*@{*/
#define BP_USB_SOFTHLD_CNT   (0U)          /*!< Bit position for USB_SOFTHLD_CNT. */
#define BM_USB_SOFTHLD_CNT   (0xFFU)       /*!< Bit mask for USB_SOFTHLD_CNT. */
#define BS_USB_SOFTHLD_CNT   (8U)          /*!< Bit field size in bits for USB_SOFTHLD_CNT. */

/*! @brief Read current value of the USB_SOFTHLD_CNT field. */
#define BR_USB_SOFTHLD_CNT(x) (HW_USB_SOFTHLD(x).U)

/*! @brief Format value for bitfield USB_SOFTHLD_CNT. */
#define BF_USB_SOFTHLD_CNT(v) ((uint8_t)((uint8_t)(v) << BP_USB_SOFTHLD_CNT) & BM_USB_SOFTHLD_CNT)

/*! @brief Set the CNT field to a new value. */
#define BW_USB_SOFTHLD_CNT(x, v) (HW_USB_SOFTHLD_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_BDTPAGE2 - BDT Page Register 2
 ******************************************************************************/

/*!
 * @brief HW_USB_BDTPAGE2 - BDT Page Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * Contains an 8-bit value used to compute the address where the current Buffer
 * Descriptor Table (BDT) resides in system memory.
 */
typedef union _hw_usb_bdtpage2
{
    uint8_t U;
    struct _hw_usb_bdtpage2_bitfields
    {
        uint8_t BDTBA : 8;             /*!< [7:0]  */
    } B;
} hw_usb_bdtpage2_t;

/*!
 * @name Constants and macros for entire USB_BDTPAGE2 register
 */
/*@{*/
#define HW_USB_BDTPAGE2_ADDR(x)  ((x) + 0xB0U)

#define HW_USB_BDTPAGE2(x)       (*(__IO hw_usb_bdtpage2_t *) HW_USB_BDTPAGE2_ADDR(x))
#define HW_USB_BDTPAGE2_RD(x)    (HW_USB_BDTPAGE2(x).U)
#define HW_USB_BDTPAGE2_WR(x, v) (HW_USB_BDTPAGE2(x).U = (v))
#define HW_USB_BDTPAGE2_SET(x, v) (HW_USB_BDTPAGE2_WR(x, HW_USB_BDTPAGE2_RD(x) |  (v)))
#define HW_USB_BDTPAGE2_CLR(x, v) (HW_USB_BDTPAGE2_WR(x, HW_USB_BDTPAGE2_RD(x) & ~(v)))
#define HW_USB_BDTPAGE2_TOG(x, v) (HW_USB_BDTPAGE2_WR(x, HW_USB_BDTPAGE2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE2 bitfields
 */

/*!
 * @name Register USB_BDTPAGE2, field BDTBA[7:0] (RW)
 *
 * Provides address bits 23 through 16 of the BDT base address that defines the
 * location of Buffer Descriptor Table resides in system memory.
 */
/*@{*/
#define BP_USB_BDTPAGE2_BDTBA (0U)         /*!< Bit position for USB_BDTPAGE2_BDTBA. */
#define BM_USB_BDTPAGE2_BDTBA (0xFFU)      /*!< Bit mask for USB_BDTPAGE2_BDTBA. */
#define BS_USB_BDTPAGE2_BDTBA (8U)         /*!< Bit field size in bits for USB_BDTPAGE2_BDTBA. */

/*! @brief Read current value of the USB_BDTPAGE2_BDTBA field. */
#define BR_USB_BDTPAGE2_BDTBA(x) (HW_USB_BDTPAGE2(x).U)

/*! @brief Format value for bitfield USB_BDTPAGE2_BDTBA. */
#define BF_USB_BDTPAGE2_BDTBA(v) ((uint8_t)((uint8_t)(v) << BP_USB_BDTPAGE2_BDTBA) & BM_USB_BDTPAGE2_BDTBA)

/*! @brief Set the BDTBA field to a new value. */
#define BW_USB_BDTPAGE2_BDTBA(x, v) (HW_USB_BDTPAGE2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_BDTPAGE3 - BDT Page Register 3
 ******************************************************************************/

/*!
 * @brief HW_USB_BDTPAGE3 - BDT Page Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Contains an 8-bit value used to compute the address where the current Buffer
 * Descriptor Table (BDT) resides in system memory.
 */
typedef union _hw_usb_bdtpage3
{
    uint8_t U;
    struct _hw_usb_bdtpage3_bitfields
    {
        uint8_t BDTBA : 8;             /*!< [7:0]  */
    } B;
} hw_usb_bdtpage3_t;

/*!
 * @name Constants and macros for entire USB_BDTPAGE3 register
 */
/*@{*/
#define HW_USB_BDTPAGE3_ADDR(x)  ((x) + 0xB4U)

#define HW_USB_BDTPAGE3(x)       (*(__IO hw_usb_bdtpage3_t *) HW_USB_BDTPAGE3_ADDR(x))
#define HW_USB_BDTPAGE3_RD(x)    (HW_USB_BDTPAGE3(x).U)
#define HW_USB_BDTPAGE3_WR(x, v) (HW_USB_BDTPAGE3(x).U = (v))
#define HW_USB_BDTPAGE3_SET(x, v) (HW_USB_BDTPAGE3_WR(x, HW_USB_BDTPAGE3_RD(x) |  (v)))
#define HW_USB_BDTPAGE3_CLR(x, v) (HW_USB_BDTPAGE3_WR(x, HW_USB_BDTPAGE3_RD(x) & ~(v)))
#define HW_USB_BDTPAGE3_TOG(x, v) (HW_USB_BDTPAGE3_WR(x, HW_USB_BDTPAGE3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE3 bitfields
 */

/*!
 * @name Register USB_BDTPAGE3, field BDTBA[7:0] (RW)
 *
 * Provides address bits 31 through 24 of the BDT base address that defines the
 * location of Buffer Descriptor Table resides in system memory.
 */
/*@{*/
#define BP_USB_BDTPAGE3_BDTBA (0U)         /*!< Bit position for USB_BDTPAGE3_BDTBA. */
#define BM_USB_BDTPAGE3_BDTBA (0xFFU)      /*!< Bit mask for USB_BDTPAGE3_BDTBA. */
#define BS_USB_BDTPAGE3_BDTBA (8U)         /*!< Bit field size in bits for USB_BDTPAGE3_BDTBA. */

/*! @brief Read current value of the USB_BDTPAGE3_BDTBA field. */
#define BR_USB_BDTPAGE3_BDTBA(x) (HW_USB_BDTPAGE3(x).U)

/*! @brief Format value for bitfield USB_BDTPAGE3_BDTBA. */
#define BF_USB_BDTPAGE3_BDTBA(v) ((uint8_t)((uint8_t)(v) << BP_USB_BDTPAGE3_BDTBA) & BM_USB_BDTPAGE3_BDTBA)

/*! @brief Set the BDTBA field to a new value. */
#define BW_USB_BDTPAGE3_BDTBA(x, v) (HW_USB_BDTPAGE3_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_ENDPTn - Endpoint Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_ENDPTn - Endpoint Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains the endpoint control bits for each of the 16 endpoints available
 * within the USB module for a decoded address. The format for these registers is
 * shown in the following figure. Endpoint 0 (ENDPT0) is associated with control
 * pipe 0, which is required for all USB functions. Therefore, after a USBRST
 * interrupt occurs the processor core should set ENDPT0 to contain 0x0D. In Host mode
 * ENDPT0 is used to determine the handshake, retry and low speed
 * characteristics of the host transfer. For Control, Bulk and Interrupt transfers, the EPHSHK
 * bit should be 1. For Isochronous transfers it should be 0. Common values to
 * use for ENDPT0 in host mode are 0x4D for Control, Bulk, and Interrupt transfers,
 * and 0x4C for Isochronous transfers.
 */
typedef union _hw_usb_endptn
{
    uint8_t U;
    struct _hw_usb_endptn_bitfields
    {
        uint8_t EPHSHK : 1;            /*!< [0]  */
        uint8_t EPSTALL : 1;           /*!< [1]  */
        uint8_t EPTXEN : 1;            /*!< [2]  */
        uint8_t EPRXEN : 1;            /*!< [3]  */
        uint8_t EPCTLDIS : 1;          /*!< [4]  */
        uint8_t RESERVED0 : 1;         /*!< [5]  */
        uint8_t RETRYDIS : 1;          /*!< [6]  */
        uint8_t HOSTWOHUB : 1;         /*!< [7]  */
    } B;
} hw_usb_endptn_t;

/*!
 * @name Constants and macros for entire USB_ENDPTn register
 */
/*@{*/
#define HW_USB_ENDPTn_COUNT (16U)

#define HW_USB_ENDPTn_ADDR(x, n) ((x) + 0xC0U + (0x4U * (n)))

#define HW_USB_ENDPTn(x, n)      (*(__IO hw_usb_endptn_t *) HW_USB_ENDPTn_ADDR(x, n))
#define HW_USB_ENDPTn_RD(x, n)   (HW_USB_ENDPTn(x, n).U)
#define HW_USB_ENDPTn_WR(x, n, v) (HW_USB_ENDPTn(x, n).U = (v))
#define HW_USB_ENDPTn_SET(x, n, v) (HW_USB_ENDPTn_WR(x, n, HW_USB_ENDPTn_RD(x, n) |  (v)))
#define HW_USB_ENDPTn_CLR(x, n, v) (HW_USB_ENDPTn_WR(x, n, HW_USB_ENDPTn_RD(x, n) & ~(v)))
#define HW_USB_ENDPTn_TOG(x, n, v) (HW_USB_ENDPTn_WR(x, n, HW_USB_ENDPTn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_ENDPTn bitfields
 */

/*!
 * @name Register USB_ENDPTn, field EPHSHK[0] (RW)
 *
 * When set this bit enables an endpoint to perform handshaking during a
 * transaction to this endpoint. This bit is generally 1 unless the endpoint is
 * Isochronous.
 */
/*@{*/
#define BP_USB_ENDPTn_EPHSHK (0U)          /*!< Bit position for USB_ENDPTn_EPHSHK. */
#define BM_USB_ENDPTn_EPHSHK (0x01U)       /*!< Bit mask for USB_ENDPTn_EPHSHK. */
#define BS_USB_ENDPTn_EPHSHK (1U)          /*!< Bit field size in bits for USB_ENDPTn_EPHSHK. */

/*! @brief Read current value of the USB_ENDPTn_EPHSHK field. */
#define BR_USB_ENDPTn_EPHSHK(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPHSHK))

/*! @brief Format value for bitfield USB_ENDPTn_EPHSHK. */
#define BF_USB_ENDPTn_EPHSHK(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPHSHK) & BM_USB_ENDPTn_EPHSHK)

/*! @brief Set the EPHSHK field to a new value. */
#define BW_USB_ENDPTn_EPHSHK(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPHSHK) = (v))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPSTALL[1] (RW)
 *
 * When set this bit indicates that the endpoint is called. This bit has
 * priority over all other control bits in the EndPoint Enable Register, but it is only
 * valid if EPTXEN=1 or EPRXEN=1. Any access to this endpoint causes the USB
 * Module to return a STALL handshake. After an endpoint is stalled it requires
 * intervention from the Host Controller.
 */
/*@{*/
#define BP_USB_ENDPTn_EPSTALL (1U)         /*!< Bit position for USB_ENDPTn_EPSTALL. */
#define BM_USB_ENDPTn_EPSTALL (0x02U)      /*!< Bit mask for USB_ENDPTn_EPSTALL. */
#define BS_USB_ENDPTn_EPSTALL (1U)         /*!< Bit field size in bits for USB_ENDPTn_EPSTALL. */

/*! @brief Read current value of the USB_ENDPTn_EPSTALL field. */
#define BR_USB_ENDPTn_EPSTALL(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPSTALL))

/*! @brief Format value for bitfield USB_ENDPTn_EPSTALL. */
#define BF_USB_ENDPTn_EPSTALL(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPSTALL) & BM_USB_ENDPTn_EPSTALL)

/*! @brief Set the EPSTALL field to a new value. */
#define BW_USB_ENDPTn_EPSTALL(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPSTALL) = (v))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPTXEN[2] (RW)
 *
 * This bit, when set, enables the endpoint for TX transfers.
 */
/*@{*/
#define BP_USB_ENDPTn_EPTXEN (2U)          /*!< Bit position for USB_ENDPTn_EPTXEN. */
#define BM_USB_ENDPTn_EPTXEN (0x04U)       /*!< Bit mask for USB_ENDPTn_EPTXEN. */
#define BS_USB_ENDPTn_EPTXEN (1U)          /*!< Bit field size in bits for USB_ENDPTn_EPTXEN. */

/*! @brief Read current value of the USB_ENDPTn_EPTXEN field. */
#define BR_USB_ENDPTn_EPTXEN(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPTXEN))

/*! @brief Format value for bitfield USB_ENDPTn_EPTXEN. */
#define BF_USB_ENDPTn_EPTXEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPTXEN) & BM_USB_ENDPTn_EPTXEN)

/*! @brief Set the EPTXEN field to a new value. */
#define BW_USB_ENDPTn_EPTXEN(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPTXEN) = (v))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPRXEN[3] (RW)
 *
 * This bit, when set, enables the endpoint for RX transfers.
 */
/*@{*/
#define BP_USB_ENDPTn_EPRXEN (3U)          /*!< Bit position for USB_ENDPTn_EPRXEN. */
#define BM_USB_ENDPTn_EPRXEN (0x08U)       /*!< Bit mask for USB_ENDPTn_EPRXEN. */
#define BS_USB_ENDPTn_EPRXEN (1U)          /*!< Bit field size in bits for USB_ENDPTn_EPRXEN. */

/*! @brief Read current value of the USB_ENDPTn_EPRXEN field. */
#define BR_USB_ENDPTn_EPRXEN(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPRXEN))

/*! @brief Format value for bitfield USB_ENDPTn_EPRXEN. */
#define BF_USB_ENDPTn_EPRXEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPRXEN) & BM_USB_ENDPTn_EPRXEN)

/*! @brief Set the EPRXEN field to a new value. */
#define BW_USB_ENDPTn_EPRXEN(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPRXEN) = (v))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPCTLDIS[4] (RW)
 *
 * This bit, when set, disables control (SETUP) transfers. When cleared, control
 * transfers are enabled. This applies if and only if the EPRXEN and EPTXEN bits
 * are also set.
 */
/*@{*/
#define BP_USB_ENDPTn_EPCTLDIS (4U)        /*!< Bit position for USB_ENDPTn_EPCTLDIS. */
#define BM_USB_ENDPTn_EPCTLDIS (0x10U)     /*!< Bit mask for USB_ENDPTn_EPCTLDIS. */
#define BS_USB_ENDPTn_EPCTLDIS (1U)        /*!< Bit field size in bits for USB_ENDPTn_EPCTLDIS. */

/*! @brief Read current value of the USB_ENDPTn_EPCTLDIS field. */
#define BR_USB_ENDPTn_EPCTLDIS(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPCTLDIS))

/*! @brief Format value for bitfield USB_ENDPTn_EPCTLDIS. */
#define BF_USB_ENDPTn_EPCTLDIS(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPCTLDIS) & BM_USB_ENDPTn_EPCTLDIS)

/*! @brief Set the EPCTLDIS field to a new value. */
#define BW_USB_ENDPTn_EPCTLDIS(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPCTLDIS) = (v))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field RETRYDIS[6] (RW)
 *
 * This is a Host mode only bit and is present in the control register for
 * endpoint 0 (ENDPT0) only. When set this bit causes the host to not retry NAK'ed
 * (Negative Acknowledgement) transactions. When a transaction is NAKed, the BDT PID
 * field is updated with the NAK PID, and the TOKEN_DNE interrupt is set. When
 * this bit is cleared, NAKed transactions are retried in hardware. This bit must
 * be set when the host is attempting to poll an interrupt endpoint.
 */
/*@{*/
#define BP_USB_ENDPTn_RETRYDIS (6U)        /*!< Bit position for USB_ENDPTn_RETRYDIS. */
#define BM_USB_ENDPTn_RETRYDIS (0x40U)     /*!< Bit mask for USB_ENDPTn_RETRYDIS. */
#define BS_USB_ENDPTn_RETRYDIS (1U)        /*!< Bit field size in bits for USB_ENDPTn_RETRYDIS. */

/*! @brief Read current value of the USB_ENDPTn_RETRYDIS field. */
#define BR_USB_ENDPTn_RETRYDIS(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_RETRYDIS))

/*! @brief Format value for bitfield USB_ENDPTn_RETRYDIS. */
#define BF_USB_ENDPTn_RETRYDIS(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_RETRYDIS) & BM_USB_ENDPTn_RETRYDIS)

/*! @brief Set the RETRYDIS field to a new value. */
#define BW_USB_ENDPTn_RETRYDIS(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_RETRYDIS) = (v))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field HOSTWOHUB[7] (RW)
 *
 * This is a Host mode only field and is present in the control register for
 * endpoint 0 (ENDPT0) only. When set this bit allows the host to communicate to a
 * directly connected low speed device. When cleared, the host produces the
 * PRE_PID. It then switches to low-speed signaling when sending a token to a low speed
 * device as required to communicate with a low speed device through a hub.
 */
/*@{*/
#define BP_USB_ENDPTn_HOSTWOHUB (7U)       /*!< Bit position for USB_ENDPTn_HOSTWOHUB. */
#define BM_USB_ENDPTn_HOSTWOHUB (0x80U)    /*!< Bit mask for USB_ENDPTn_HOSTWOHUB. */
#define BS_USB_ENDPTn_HOSTWOHUB (1U)       /*!< Bit field size in bits for USB_ENDPTn_HOSTWOHUB. */

/*! @brief Read current value of the USB_ENDPTn_HOSTWOHUB field. */
#define BR_USB_ENDPTn_HOSTWOHUB(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_HOSTWOHUB))

/*! @brief Format value for bitfield USB_ENDPTn_HOSTWOHUB. */
#define BF_USB_ENDPTn_HOSTWOHUB(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_HOSTWOHUB) & BM_USB_ENDPTn_HOSTWOHUB)

/*! @brief Set the HOSTWOHUB field to a new value. */
#define BW_USB_ENDPTn_HOSTWOHUB(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_HOSTWOHUB) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_USBCTRL - USB Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_USBCTRL - USB Control register (RW)
 *
 * Reset value: 0xC0U
 */
typedef union _hw_usb_usbctrl
{
    uint8_t U;
    struct _hw_usb_usbctrl_bitfields
    {
        uint8_t RESERVED0 : 6;         /*!< [5:0]  */
        uint8_t PDE : 1;               /*!< [6]  */
        uint8_t SUSP : 1;              /*!< [7]  */
    } B;
} hw_usb_usbctrl_t;

/*!
 * @name Constants and macros for entire USB_USBCTRL register
 */
/*@{*/
#define HW_USB_USBCTRL_ADDR(x)   ((x) + 0x100U)

#define HW_USB_USBCTRL(x)        (*(__IO hw_usb_usbctrl_t *) HW_USB_USBCTRL_ADDR(x))
#define HW_USB_USBCTRL_RD(x)     (HW_USB_USBCTRL(x).U)
#define HW_USB_USBCTRL_WR(x, v)  (HW_USB_USBCTRL(x).U = (v))
#define HW_USB_USBCTRL_SET(x, v) (HW_USB_USBCTRL_WR(x, HW_USB_USBCTRL_RD(x) |  (v)))
#define HW_USB_USBCTRL_CLR(x, v) (HW_USB_USBCTRL_WR(x, HW_USB_USBCTRL_RD(x) & ~(v)))
#define HW_USB_USBCTRL_TOG(x, v) (HW_USB_USBCTRL_WR(x, HW_USB_USBCTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_USBCTRL bitfields
 */

/*!
 * @name Register USB_USBCTRL, field PDE[6] (RW)
 *
 * Enables the weak pulldowns on the USB transceiver.
 *
 * Values:
 * - 0 - Weak pulldowns are disabled on D+ and D-.
 * - 1 - Weak pulldowns are enabled on D+ and D-.
 */
/*@{*/
#define BP_USB_USBCTRL_PDE   (6U)          /*!< Bit position for USB_USBCTRL_PDE. */
#define BM_USB_USBCTRL_PDE   (0x40U)       /*!< Bit mask for USB_USBCTRL_PDE. */
#define BS_USB_USBCTRL_PDE   (1U)          /*!< Bit field size in bits for USB_USBCTRL_PDE. */

/*! @brief Read current value of the USB_USBCTRL_PDE field. */
#define BR_USB_USBCTRL_PDE(x) (BITBAND_ACCESS8(HW_USB_USBCTRL_ADDR(x), BP_USB_USBCTRL_PDE))

/*! @brief Format value for bitfield USB_USBCTRL_PDE. */
#define BF_USB_USBCTRL_PDE(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBCTRL_PDE) & BM_USB_USBCTRL_PDE)

/*! @brief Set the PDE field to a new value. */
#define BW_USB_USBCTRL_PDE(x, v) (BITBAND_ACCESS8(HW_USB_USBCTRL_ADDR(x), BP_USB_USBCTRL_PDE) = (v))
/*@}*/

/*!
 * @name Register USB_USBCTRL, field SUSP[7] (RW)
 *
 * Places the USB transceiver into the suspend state.
 *
 * Values:
 * - 0 - USB transceiver is not in suspend state.
 * - 1 - USB transceiver is in suspend state.
 */
/*@{*/
#define BP_USB_USBCTRL_SUSP  (7U)          /*!< Bit position for USB_USBCTRL_SUSP. */
#define BM_USB_USBCTRL_SUSP  (0x80U)       /*!< Bit mask for USB_USBCTRL_SUSP. */
#define BS_USB_USBCTRL_SUSP  (1U)          /*!< Bit field size in bits for USB_USBCTRL_SUSP. */

/*! @brief Read current value of the USB_USBCTRL_SUSP field. */
#define BR_USB_USBCTRL_SUSP(x) (BITBAND_ACCESS8(HW_USB_USBCTRL_ADDR(x), BP_USB_USBCTRL_SUSP))

/*! @brief Format value for bitfield USB_USBCTRL_SUSP. */
#define BF_USB_USBCTRL_SUSP(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBCTRL_SUSP) & BM_USB_USBCTRL_SUSP)

/*! @brief Set the SUSP field to a new value. */
#define BW_USB_USBCTRL_SUSP(x, v) (BITBAND_ACCESS8(HW_USB_USBCTRL_ADDR(x), BP_USB_USBCTRL_SUSP) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_OBSERVE - USB OTG Observe register
 ******************************************************************************/

/*!
 * @brief HW_USB_OBSERVE - USB OTG Observe register (RO)
 *
 * Reset value: 0x50U
 *
 * Provides visibility on the state of the pull-ups and pull-downs at the
 * transceiver. Useful when interfacing to an external OTG control module via a serial
 * interface.
 */
typedef union _hw_usb_observe
{
    uint8_t U;
    struct _hw_usb_observe_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t DMPD : 1;              /*!< [4]  */
        uint8_t RESERVED1 : 1;         /*!< [5]  */
        uint8_t DPPD : 1;              /*!< [6]  */
        uint8_t DPPU : 1;              /*!< [7]  */
    } B;
} hw_usb_observe_t;

/*!
 * @name Constants and macros for entire USB_OBSERVE register
 */
/*@{*/
#define HW_USB_OBSERVE_ADDR(x)   ((x) + 0x104U)

#define HW_USB_OBSERVE(x)        (*(__I hw_usb_observe_t *) HW_USB_OBSERVE_ADDR(x))
#define HW_USB_OBSERVE_RD(x)     (HW_USB_OBSERVE(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_OBSERVE bitfields
 */

/*!
 * @name Register USB_OBSERVE, field DMPD[4] (RO)
 *
 * Provides observability of the D- Pulldown enable at the USB transceiver.
 *
 * Values:
 * - 0 - D- pulldown disabled.
 * - 1 - D- pulldown enabled.
 */
/*@{*/
#define BP_USB_OBSERVE_DMPD  (4U)          /*!< Bit position for USB_OBSERVE_DMPD. */
#define BM_USB_OBSERVE_DMPD  (0x10U)       /*!< Bit mask for USB_OBSERVE_DMPD. */
#define BS_USB_OBSERVE_DMPD  (1U)          /*!< Bit field size in bits for USB_OBSERVE_DMPD. */

/*! @brief Read current value of the USB_OBSERVE_DMPD field. */
#define BR_USB_OBSERVE_DMPD(x) (BITBAND_ACCESS8(HW_USB_OBSERVE_ADDR(x), BP_USB_OBSERVE_DMPD))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPD[6] (RO)
 *
 * Provides observability of the D+ Pulldown enable at the USB transceiver.
 *
 * Values:
 * - 0 - D+ pulldown disabled.
 * - 1 - D+ pulldown enabled.
 */
/*@{*/
#define BP_USB_OBSERVE_DPPD  (6U)          /*!< Bit position for USB_OBSERVE_DPPD. */
#define BM_USB_OBSERVE_DPPD  (0x40U)       /*!< Bit mask for USB_OBSERVE_DPPD. */
#define BS_USB_OBSERVE_DPPD  (1U)          /*!< Bit field size in bits for USB_OBSERVE_DPPD. */

/*! @brief Read current value of the USB_OBSERVE_DPPD field. */
#define BR_USB_OBSERVE_DPPD(x) (BITBAND_ACCESS8(HW_USB_OBSERVE_ADDR(x), BP_USB_OBSERVE_DPPD))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPU[7] (RO)
 *
 * Provides observability of the D+ Pullup enable at the USB transceiver.
 *
 * Values:
 * - 0 - D+ pullup disabled.
 * - 1 - D+ pullup enabled.
 */
/*@{*/
#define BP_USB_OBSERVE_DPPU  (7U)          /*!< Bit position for USB_OBSERVE_DPPU. */
#define BM_USB_OBSERVE_DPPU  (0x80U)       /*!< Bit mask for USB_OBSERVE_DPPU. */
#define BS_USB_OBSERVE_DPPU  (1U)          /*!< Bit field size in bits for USB_OBSERVE_DPPU. */

/*! @brief Read current value of the USB_OBSERVE_DPPU field. */
#define BR_USB_OBSERVE_DPPU(x) (BITBAND_ACCESS8(HW_USB_OBSERVE_ADDR(x), BP_USB_OBSERVE_DPPU))
/*@}*/

/*******************************************************************************
 * HW_USB_CONTROL - USB OTG Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_CONTROL - USB OTG Control register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_usb_control
{
    uint8_t U;
    struct _hw_usb_control_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t DPPULLUPNONOTG : 1;    /*!< [4]  */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_usb_control_t;

/*!
 * @name Constants and macros for entire USB_CONTROL register
 */
/*@{*/
#define HW_USB_CONTROL_ADDR(x)   ((x) + 0x108U)

#define HW_USB_CONTROL(x)        (*(__IO hw_usb_control_t *) HW_USB_CONTROL_ADDR(x))
#define HW_USB_CONTROL_RD(x)     (HW_USB_CONTROL(x).U)
#define HW_USB_CONTROL_WR(x, v)  (HW_USB_CONTROL(x).U = (v))
#define HW_USB_CONTROL_SET(x, v) (HW_USB_CONTROL_WR(x, HW_USB_CONTROL_RD(x) |  (v)))
#define HW_USB_CONTROL_CLR(x, v) (HW_USB_CONTROL_WR(x, HW_USB_CONTROL_RD(x) & ~(v)))
#define HW_USB_CONTROL_TOG(x, v) (HW_USB_CONTROL_WR(x, HW_USB_CONTROL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_CONTROL bitfields
 */

/*!
 * @name Register USB_CONTROL, field DPPULLUPNONOTG[4] (RW)
 *
 * Provides control of the DP Pullup in USBOTG, if USB is configured in non-OTG
 * device mode.
 *
 * Values:
 * - 0 - DP Pullup in non-OTG device mode is not enabled.
 * - 1 - DP Pullup in non-OTG device mode is enabled.
 */
/*@{*/
#define BP_USB_CONTROL_DPPULLUPNONOTG (4U) /*!< Bit position for USB_CONTROL_DPPULLUPNONOTG. */
#define BM_USB_CONTROL_DPPULLUPNONOTG (0x10U) /*!< Bit mask for USB_CONTROL_DPPULLUPNONOTG. */
#define BS_USB_CONTROL_DPPULLUPNONOTG (1U) /*!< Bit field size in bits for USB_CONTROL_DPPULLUPNONOTG. */

/*! @brief Read current value of the USB_CONTROL_DPPULLUPNONOTG field. */
#define BR_USB_CONTROL_DPPULLUPNONOTG(x) (BITBAND_ACCESS8(HW_USB_CONTROL_ADDR(x), BP_USB_CONTROL_DPPULLUPNONOTG))

/*! @brief Format value for bitfield USB_CONTROL_DPPULLUPNONOTG. */
#define BF_USB_CONTROL_DPPULLUPNONOTG(v) ((uint8_t)((uint8_t)(v) << BP_USB_CONTROL_DPPULLUPNONOTG) & BM_USB_CONTROL_DPPULLUPNONOTG)

/*! @brief Set the DPPULLUPNONOTG field to a new value. */
#define BW_USB_CONTROL_DPPULLUPNONOTG(x, v) (BITBAND_ACCESS8(HW_USB_CONTROL_ADDR(x), BP_USB_CONTROL_DPPULLUPNONOTG) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_USBTRC0 - USB Transceiver Control register 0
 ******************************************************************************/

/*!
 * @brief HW_USB_USBTRC0 - USB Transceiver Control register 0 (RW)
 *
 * Reset value: 0x00U
 *
 * Includes signals for basic operation of the on-chip USB Full Speed
 * transceiver and configuration of the USB data connection that are not otherwise included
 * in the USB Full Speed controller registers.
 */
typedef union _hw_usb_usbtrc0
{
    uint8_t U;
    struct _hw_usb_usbtrc0_bitfields
    {
        uint8_t USB_RESUME_INT : 1;    /*!< [0] USB Asynchronous Interrupt */
        uint8_t SYNC_DET : 1;          /*!< [1] Synchronous USB Interrupt Detect */
        uint8_t USB_CLK_RECOVERY_INT : 1; /*!< [2] Combined USB Clock
                                        * Recovery interrupt status */
        uint8_t RESERVED0 : 2;         /*!< [4:3]  */
        uint8_t USBRESMEN : 1;         /*!< [5] Asynchronous Resume Interrupt Enable
                                        * */
        uint8_t RESERVED1 : 1;         /*!< [6]  */
        uint8_t USBRESET : 1;          /*!< [7] USB Reset */
    } B;
} hw_usb_usbtrc0_t;

/*!
 * @name Constants and macros for entire USB_USBTRC0 register
 */
/*@{*/
#define HW_USB_USBTRC0_ADDR(x)   ((x) + 0x10CU)

#define HW_USB_USBTRC0(x)        (*(__IO hw_usb_usbtrc0_t *) HW_USB_USBTRC0_ADDR(x))
#define HW_USB_USBTRC0_RD(x)     (HW_USB_USBTRC0(x).U)
#define HW_USB_USBTRC0_WR(x, v)  (HW_USB_USBTRC0(x).U = (v))
#define HW_USB_USBTRC0_SET(x, v) (HW_USB_USBTRC0_WR(x, HW_USB_USBTRC0_RD(x) |  (v)))
#define HW_USB_USBTRC0_CLR(x, v) (HW_USB_USBTRC0_WR(x, HW_USB_USBTRC0_RD(x) & ~(v)))
#define HW_USB_USBTRC0_TOG(x, v) (HW_USB_USBTRC0_WR(x, HW_USB_USBTRC0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_USBTRC0 bitfields
 */

/*!
 * @name Register USB_USBTRC0, field USB_RESUME_INT[0] (RO)
 *
 * Values:
 * - 0 - No interrupt was generated.
 * - 1 - Interrupt was generated because of the USB asynchronous interrupt.
 */
/*@{*/
#define BP_USB_USBTRC0_USB_RESUME_INT (0U) /*!< Bit position for USB_USBTRC0_USB_RESUME_INT. */
#define BM_USB_USBTRC0_USB_RESUME_INT (0x01U) /*!< Bit mask for USB_USBTRC0_USB_RESUME_INT. */
#define BS_USB_USBTRC0_USB_RESUME_INT (1U) /*!< Bit field size in bits for USB_USBTRC0_USB_RESUME_INT. */

/*! @brief Read current value of the USB_USBTRC0_USB_RESUME_INT field. */
#define BR_USB_USBTRC0_USB_RESUME_INT(x) (BITBAND_ACCESS8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USB_RESUME_INT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field SYNC_DET[1] (RO)
 *
 * Values:
 * - 0 - Synchronous interrupt has not been detected.
 * - 1 - Synchronous interrupt has been detected.
 */
/*@{*/
#define BP_USB_USBTRC0_SYNC_DET (1U)       /*!< Bit position for USB_USBTRC0_SYNC_DET. */
#define BM_USB_USBTRC0_SYNC_DET (0x02U)    /*!< Bit mask for USB_USBTRC0_SYNC_DET. */
#define BS_USB_USBTRC0_SYNC_DET (1U)       /*!< Bit field size in bits for USB_USBTRC0_SYNC_DET. */

/*! @brief Read current value of the USB_USBTRC0_SYNC_DET field. */
#define BR_USB_USBTRC0_SYNC_DET(x) (BITBAND_ACCESS8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_SYNC_DET))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USB_CLK_RECOVERY_INT[2] (RO)
 *
 * This read-only field will be set to value high at 1'b1 when any of USB clock
 * recovery interrupt conditions are detected and those interrupts are unmasked.
 * For customer use the only unmasked USB clock recovery interrupt condition
 * results from an overflow of the frequency trim setting values indicating that the
 * frequency trim calculated is out of the adjustment range of the IRC48M output
 * clock. To clear this bit after it has been set, Write 0xFF to register
 * USB_CLK_RECOVER_INT_STATUS.
 */
/*@{*/
#define BP_USB_USBTRC0_USB_CLK_RECOVERY_INT (2U) /*!< Bit position for USB_USBTRC0_USB_CLK_RECOVERY_INT. */
#define BM_USB_USBTRC0_USB_CLK_RECOVERY_INT (0x04U) /*!< Bit mask for USB_USBTRC0_USB_CLK_RECOVERY_INT. */
#define BS_USB_USBTRC0_USB_CLK_RECOVERY_INT (1U) /*!< Bit field size in bits for USB_USBTRC0_USB_CLK_RECOVERY_INT. */

/*! @brief Read current value of the USB_USBTRC0_USB_CLK_RECOVERY_INT field. */
#define BR_USB_USBTRC0_USB_CLK_RECOVERY_INT(x) (BITBAND_ACCESS8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USB_CLK_RECOVERY_INT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESMEN[5] (RW)
 *
 * This bit, when set, allows the USB module to send an asynchronous wakeup
 * event to the MCU upon detection of resume signaling on the USB bus. The MCU then
 * re-enables clocks to the USB module. It is used for low-power suspend mode when
 * USB module clocks are stopped or the USB transceiver is in Suspend mode.
 * Async wakeup only works in device mode.
 *
 * Values:
 * - 0 - USB asynchronous wakeup from suspend mode disabled.
 * - 1 - USB asynchronous wakeup from suspend mode enabled. The asynchronous
 *     resume interrupt differs from the synchronous resume interrupt in that it
 *     asynchronously detects K-state using the unfiltered state of the D+ and D-
 *     pins. This interrupt should only be enabled when the Transceiver is
 *     suspended.
 */
/*@{*/
#define BP_USB_USBTRC0_USBRESMEN (5U)      /*!< Bit position for USB_USBTRC0_USBRESMEN. */
#define BM_USB_USBTRC0_USBRESMEN (0x20U)   /*!< Bit mask for USB_USBTRC0_USBRESMEN. */
#define BS_USB_USBTRC0_USBRESMEN (1U)      /*!< Bit field size in bits for USB_USBTRC0_USBRESMEN. */

/*! @brief Read current value of the USB_USBTRC0_USBRESMEN field. */
#define BR_USB_USBTRC0_USBRESMEN(x) (BITBAND_ACCESS8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USBRESMEN))

/*! @brief Format value for bitfield USB_USBTRC0_USBRESMEN. */
#define BF_USB_USBTRC0_USBRESMEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBTRC0_USBRESMEN) & BM_USB_USBTRC0_USBRESMEN)

/*! @brief Set the USBRESMEN field to a new value. */
#define BW_USB_USBTRC0_USBRESMEN(x, v) (BITBAND_ACCESS8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USBRESMEN) = (v))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESET[7] (WO)
 *
 * Generates a hard reset to USBOTG. After this bit is set and the reset occurs,
 * this bit is automatically cleared. This bit is always read as zero. Wait two
 * USB clock cycles after setting this bit.
 *
 * Values:
 * - 0 - Normal USB module operation.
 * - 1 - Returns the USB module to its reset state.
 */
/*@{*/
#define BP_USB_USBTRC0_USBRESET (7U)       /*!< Bit position for USB_USBTRC0_USBRESET. */
#define BM_USB_USBTRC0_USBRESET (0x80U)    /*!< Bit mask for USB_USBTRC0_USBRESET. */
#define BS_USB_USBTRC0_USBRESET (1U)       /*!< Bit field size in bits for USB_USBTRC0_USBRESET. */

/*! @brief Format value for bitfield USB_USBTRC0_USBRESET. */
#define BF_USB_USBTRC0_USBRESET(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBTRC0_USBRESET) & BM_USB_USBTRC0_USBRESET)
/*@}*/

/*******************************************************************************
 * HW_USB_USBFRMADJUST - Frame Adjust Register
 ******************************************************************************/

/*!
 * @brief HW_USB_USBFRMADJUST - Frame Adjust Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_usb_usbfrmadjust
{
    uint8_t U;
    struct _hw_usb_usbfrmadjust_bitfields
    {
        uint8_t ADJ : 8;               /*!< [7:0] Frame Adjustment */
    } B;
} hw_usb_usbfrmadjust_t;

/*!
 * @name Constants and macros for entire USB_USBFRMADJUST register
 */
/*@{*/
#define HW_USB_USBFRMADJUST_ADDR(x) ((x) + 0x114U)

#define HW_USB_USBFRMADJUST(x)   (*(__IO hw_usb_usbfrmadjust_t *) HW_USB_USBFRMADJUST_ADDR(x))
#define HW_USB_USBFRMADJUST_RD(x) (HW_USB_USBFRMADJUST(x).U)
#define HW_USB_USBFRMADJUST_WR(x, v) (HW_USB_USBFRMADJUST(x).U = (v))
#define HW_USB_USBFRMADJUST_SET(x, v) (HW_USB_USBFRMADJUST_WR(x, HW_USB_USBFRMADJUST_RD(x) |  (v)))
#define HW_USB_USBFRMADJUST_CLR(x, v) (HW_USB_USBFRMADJUST_WR(x, HW_USB_USBFRMADJUST_RD(x) & ~(v)))
#define HW_USB_USBFRMADJUST_TOG(x, v) (HW_USB_USBFRMADJUST_WR(x, HW_USB_USBFRMADJUST_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_USBFRMADJUST bitfields
 */

/*!
 * @name Register USB_USBFRMADJUST, field ADJ[7:0] (RW)
 *
 * In Host mode, the frame adjustment is a twos complement number that adjusts
 * the period of each USB frame in 12-MHz clock periods. A SOF is normally
 * generated every 12,000 12-MHz clock cycles. The Frame Adjust Register can adjust this
 * by -128 to +127 to compensate for inaccuracies in the USB 48-MHz clock.
 * Changes to the ADJ bit take effect at the next start of the next frame.
 */
/*@{*/
#define BP_USB_USBFRMADJUST_ADJ (0U)       /*!< Bit position for USB_USBFRMADJUST_ADJ. */
#define BM_USB_USBFRMADJUST_ADJ (0xFFU)    /*!< Bit mask for USB_USBFRMADJUST_ADJ. */
#define BS_USB_USBFRMADJUST_ADJ (8U)       /*!< Bit field size in bits for USB_USBFRMADJUST_ADJ. */

/*! @brief Read current value of the USB_USBFRMADJUST_ADJ field. */
#define BR_USB_USBFRMADJUST_ADJ(x) (HW_USB_USBFRMADJUST(x).U)

/*! @brief Format value for bitfield USB_USBFRMADJUST_ADJ. */
#define BF_USB_USBFRMADJUST_ADJ(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBFRMADJUST_ADJ) & BM_USB_USBFRMADJUST_ADJ)

/*! @brief Set the ADJ field to a new value. */
#define BW_USB_USBFRMADJUST_ADJ(x, v) (HW_USB_USBFRMADJUST_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_CTRL - USB Clock recovery control
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_CTRL - USB Clock recovery control (RW)
 *
 * Reset value: 0x00U
 *
 * Signals in this register control the crystal-less USB clock mode in which the
 * internal IRC48M oscillator is tuned to match the clock extracted from the
 * incoming USB data stream. The IRC48M internal oscillator module must be enabled
 * in register USB_CLK_RECOVER_IRC_EN for this mode.
 */
typedef union _hw_usb_clk_recover_ctrl
{
    uint8_t U;
    struct _hw_usb_clk_recover_ctrl_bitfields
    {
        uint8_t RESERVED0 : 5;         /*!< [4:0]  */
        uint8_t RESTART_IFRTRIM_EN : 1; /*!< [5] Restart from IFR trim value
                                        * */
        uint8_t RESET_RESUME_ROUGH_EN : 1; /*!< [6] Reset/resume to rough
                                        * phase enable */
        uint8_t CLOCK_RECOVER_EN : 1;  /*!< [7] Crystal-less USB enable */
    } B;
} hw_usb_clk_recover_ctrl_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_CTRL register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_CTRL_ADDR(x) ((x) + 0x140U)

#define HW_USB_CLK_RECOVER_CTRL(x) (*(__IO hw_usb_clk_recover_ctrl_t *) HW_USB_CLK_RECOVER_CTRL_ADDR(x))
#define HW_USB_CLK_RECOVER_CTRL_RD(x) (HW_USB_CLK_RECOVER_CTRL(x).U)
#define HW_USB_CLK_RECOVER_CTRL_WR(x, v) (HW_USB_CLK_RECOVER_CTRL(x).U = (v))
#define HW_USB_CLK_RECOVER_CTRL_SET(x, v) (HW_USB_CLK_RECOVER_CTRL_WR(x, HW_USB_CLK_RECOVER_CTRL_RD(x) |  (v)))
#define HW_USB_CLK_RECOVER_CTRL_CLR(x, v) (HW_USB_CLK_RECOVER_CTRL_WR(x, HW_USB_CLK_RECOVER_CTRL_RD(x) & ~(v)))
#define HW_USB_CLK_RECOVER_CTRL_TOG(x, v) (HW_USB_CLK_RECOVER_CTRL_WR(x, HW_USB_CLK_RECOVER_CTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_CTRL bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field RESTART_IFRTRIM_EN[5] (RW)
 *
 * IRC48 has a default trim fine value whose default value is factory trimmed
 * (the IFR trim value). Clock recover block tracks the accuracy of the clock 48Mhz
 * and keeps updating the trim fine value accordingly
 *
 * Values:
 * - 0 - Trim fine adjustment always works based on the previous updated trim
 *     fine value (default)
 * - 1 - Trim fine restarts from the IFR trim value whenever
 *     bus_reset/bus_resume is detected or module enable is desasserted
 */
/*@{*/
#define BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN (5U) /*!< Bit position for USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */
#define BM_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN (0x20U) /*!< Bit mask for USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */
#define BS_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN field. */
#define BR_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(x) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */
#define BF_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN) & BM_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN)

/*! @brief Set the RESTART_IFRTRIM_EN field to a new value. */
#define BW_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(x, v) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN) = (v))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field RESET_RESUME_ROUGH_EN[6] (RW)
 *
 * The clock recovery block tracks the IRC48Mhz to get an accurate 48Mhz clock.
 * It has two phases after user enables clock_recover_en bit, rough phase and
 * tracking phase. The step to fine tune the IRC 48Mhz by adjusting the trim fine
 * value is different during these two phases. The step in rough phase is larger
 * than that in tracking phase. Switch back to rough stage whenever USB bus reset
 * or bus resume occurs.
 *
 * Values:
 * - 0 - Always works in tracking phase after the 1st time rough to track
 *     transition (default)
 * - 1 - Go back to rough stage whenever bus reset or bus resume occurs
 */
/*@{*/
#define BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN (6U) /*!< Bit position for USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */
#define BM_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN (0x40U) /*!< Bit mask for USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */
#define BS_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN field. */
#define BR_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(x) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */
#define BF_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN) & BM_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN)

/*! @brief Set the RESET_RESUME_ROUGH_EN field to a new value. */
#define BW_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(x, v) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN) = (v))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field CLOCK_RECOVER_EN[7] (RW)
 *
 * This bit must be enabled if user wants to use the crystal-less USB mode for
 * the Full Speed USB controller and transceiver. This bit should not be set for
 * USB host mode or OTG.
 *
 * Values:
 * - 0 - Disable clock recovery block (default)
 * - 1 - Enable clock recovery block
 */
/*@{*/
#define BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN (7U) /*!< Bit position for USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */
#define BM_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN (0x80U) /*!< Bit mask for USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */
#define BS_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN field. */
#define BR_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(x) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */
#define BF_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN) & BM_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN)

/*! @brief Set the CLOCK_RECOVER_EN field to a new value. */
#define BW_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(x, v) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register (RW)
 *
 * Reset value: 0x01U
 *
 * Controls basic operation of the on-chip IRC48M module used to produce nominal
 * 48MHz clocks for USB crystal-less operation and other functions. See
 * additional information about the IRC48M operation in the Clock Distribution chapter.
 */
typedef union _hw_usb_clk_recover_irc_en
{
    uint8_t U;
    struct _hw_usb_clk_recover_irc_en_bitfields
    {
        uint8_t REG_EN : 1;            /*!< [0] IRC48M regulator enable */
        uint8_t IRC_EN : 1;            /*!< [1] IRC48M enable */
        uint8_t RESERVED0 : 6;         /*!< [7:2]  */
    } B;
} hw_usb_clk_recover_irc_en_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_IRC_EN register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_IRC_EN_ADDR(x) ((x) + 0x144U)

#define HW_USB_CLK_RECOVER_IRC_EN(x) (*(__IO hw_usb_clk_recover_irc_en_t *) HW_USB_CLK_RECOVER_IRC_EN_ADDR(x))
#define HW_USB_CLK_RECOVER_IRC_EN_RD(x) (HW_USB_CLK_RECOVER_IRC_EN(x).U)
#define HW_USB_CLK_RECOVER_IRC_EN_WR(x, v) (HW_USB_CLK_RECOVER_IRC_EN(x).U = (v))
#define HW_USB_CLK_RECOVER_IRC_EN_SET(x, v) (HW_USB_CLK_RECOVER_IRC_EN_WR(x, HW_USB_CLK_RECOVER_IRC_EN_RD(x) |  (v)))
#define HW_USB_CLK_RECOVER_IRC_EN_CLR(x, v) (HW_USB_CLK_RECOVER_IRC_EN_WR(x, HW_USB_CLK_RECOVER_IRC_EN_RD(x) & ~(v)))
#define HW_USB_CLK_RECOVER_IRC_EN_TOG(x, v) (HW_USB_CLK_RECOVER_IRC_EN_WR(x, HW_USB_CLK_RECOVER_IRC_EN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_IRC_EN bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_IRC_EN, field REG_EN[0] (RW)
 *
 * This bit is used to enable the local analog regulator for IRC48Mhz module.
 * This bit must be set if user wants to use the crystal-less USB clock
 * configuration.
 *
 * Values:
 * - 0 - IRC48M local regulator is disabled
 * - 1 - IRC48M local regulator is enabled (default)
 */
/*@{*/
#define BP_USB_CLK_RECOVER_IRC_EN_REG_EN (0U) /*!< Bit position for USB_CLK_RECOVER_IRC_EN_REG_EN. */
#define BM_USB_CLK_RECOVER_IRC_EN_REG_EN (0x01U) /*!< Bit mask for USB_CLK_RECOVER_IRC_EN_REG_EN. */
#define BS_USB_CLK_RECOVER_IRC_EN_REG_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_IRC_EN_REG_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_IRC_EN_REG_EN field. */
#define BR_USB_CLK_RECOVER_IRC_EN_REG_EN(x) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), BP_USB_CLK_RECOVER_IRC_EN_REG_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_IRC_EN_REG_EN. */
#define BF_USB_CLK_RECOVER_IRC_EN_REG_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_IRC_EN_REG_EN) & BM_USB_CLK_RECOVER_IRC_EN_REG_EN)

/*! @brief Set the REG_EN field to a new value. */
#define BW_USB_CLK_RECOVER_IRC_EN_REG_EN(x, v) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), BP_USB_CLK_RECOVER_IRC_EN_REG_EN) = (v))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_IRC_EN, field IRC_EN[1] (RW)
 *
 * This bit is used to enable the on-chip IRC48Mhz module to generate clocks for
 * crystal-less USB. It can only be used for FS USB device mode operation. This
 * bit must be set before using the crystal-less USB clock configuration.
 *
 * Values:
 * - 0 - Disable the IRC48M module (default)
 * - 1 - Enable the IRC48M module
 */
/*@{*/
#define BP_USB_CLK_RECOVER_IRC_EN_IRC_EN (1U) /*!< Bit position for USB_CLK_RECOVER_IRC_EN_IRC_EN. */
#define BM_USB_CLK_RECOVER_IRC_EN_IRC_EN (0x02U) /*!< Bit mask for USB_CLK_RECOVER_IRC_EN_IRC_EN. */
#define BS_USB_CLK_RECOVER_IRC_EN_IRC_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_IRC_EN_IRC_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_IRC_EN_IRC_EN field. */
#define BR_USB_CLK_RECOVER_IRC_EN_IRC_EN(x) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), BP_USB_CLK_RECOVER_IRC_EN_IRC_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_IRC_EN_IRC_EN. */
#define BF_USB_CLK_RECOVER_IRC_EN_IRC_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_IRC_EN_IRC_EN) & BM_USB_CLK_RECOVER_IRC_EN_IRC_EN)

/*! @brief Set the IRC_EN field to a new value. */
#define BW_USB_CLK_RECOVER_IRC_EN_IRC_EN(x, v) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), BP_USB_CLK_RECOVER_IRC_EN_IRC_EN) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status (W1C)
 *
 * Reset value: 0x00U
 *
 * A Write operation with value high at 1'b1 on any combination of individual
 * bits will clear those bits.
 */
typedef union _hw_usb_clk_recover_int_status
{
    uint8_t U;
    struct _hw_usb_clk_recover_int_status_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t OVF_ERROR : 1;         /*!< [4]  */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_usb_clk_recover_int_status_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_INT_STATUS register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x) ((x) + 0x15CU)

#define HW_USB_CLK_RECOVER_INT_STATUS(x) (*(__IO hw_usb_clk_recover_int_status_t *) HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x))
#define HW_USB_CLK_RECOVER_INT_STATUS_RD(x) (HW_USB_CLK_RECOVER_INT_STATUS(x).U)
#define HW_USB_CLK_RECOVER_INT_STATUS_WR(x, v) (HW_USB_CLK_RECOVER_INT_STATUS(x).U = (v))
#define HW_USB_CLK_RECOVER_INT_STATUS_SET(x, v) (HW_USB_CLK_RECOVER_INT_STATUS_WR(x, HW_USB_CLK_RECOVER_INT_STATUS_RD(x) |  (v)))
#define HW_USB_CLK_RECOVER_INT_STATUS_CLR(x, v) (HW_USB_CLK_RECOVER_INT_STATUS_WR(x, HW_USB_CLK_RECOVER_INT_STATUS_RD(x) & ~(v)))
#define HW_USB_CLK_RECOVER_INT_STATUS_TOG(x, v) (HW_USB_CLK_RECOVER_INT_STATUS_WR(x, HW_USB_CLK_RECOVER_INT_STATUS_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_INT_STATUS bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_INT_STATUS, field OVF_ERROR[4] (W1C)
 *
 * Indicates that the USB clock recovery algorithm has detected that the
 * frequency trim adjustment needed for the IRC48M output clock is outside the available
 * TRIM_FINE adjustment range for the IRC48M module.
 *
 * Values:
 * - 0 - No interrupt is reported
 * - 1 - Unmasked interrupt has been generated
 */
/*@{*/
#define BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR (4U) /*!< Bit position for USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */
#define BM_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR (0x10U) /*!< Bit mask for USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */
#define BS_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */

/*! @brief Read current value of the USB_CLK_RECOVER_INT_STATUS_OVF_ERROR field. */
#define BR_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(x) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR))

/*! @brief Format value for bitfield USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */
#define BF_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR) & BM_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR)

/*! @brief Set the OVF_ERROR field to a new value. */
#define BW_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(x, v) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR) = (v))
/*@}*/

/*******************************************************************************
 * hw_usb_t - module struct
 ******************************************************************************/
/*!
 * @brief All USB module registers.
 */
#pragma pack(1)
typedef struct _hw_usb
{
    __I hw_usb_perid_t PERID;              /*!< [0x0] Peripheral ID register */
    uint8_t _reserved0[3];
    __I hw_usb_idcomp_t IDCOMP;            /*!< [0x4] Peripheral ID Complement register */
    uint8_t _reserved1[3];
    __I hw_usb_rev_t REV;                  /*!< [0x8] Peripheral Revision register */
    uint8_t _reserved2[3];
    __I hw_usb_addinfo_t ADDINFO;          /*!< [0xC] Peripheral Additional Info register */
    uint8_t _reserved3[3];
    __IO hw_usb_otgistat_t OTGISTAT;       /*!< [0x10] OTG Interrupt Status register */
    uint8_t _reserved4[3];
    __IO hw_usb_otgicr_t OTGICR;           /*!< [0x14] OTG Interrupt Control register */
    uint8_t _reserved5[3];
    __IO hw_usb_otgstat_t OTGSTAT;         /*!< [0x18] OTG Status register */
    uint8_t _reserved6[3];
    __IO hw_usb_otgctl_t OTGCTL;           /*!< [0x1C] OTG Control register */
    uint8_t _reserved7[99];
    __IO hw_usb_istat_t ISTAT;             /*!< [0x80] Interrupt Status register */
    uint8_t _reserved8[3];
    __IO hw_usb_inten_t INTEN;             /*!< [0x84] Interrupt Enable register */
    uint8_t _reserved9[3];
    __IO hw_usb_errstat_t ERRSTAT;         /*!< [0x88] Error Interrupt Status register */
    uint8_t _reserved10[3];
    __IO hw_usb_erren_t ERREN;             /*!< [0x8C] Error Interrupt Enable register */
    uint8_t _reserved11[3];
    __I hw_usb_stat_t STAT;                /*!< [0x90] Status register */
    uint8_t _reserved12[3];
    __IO hw_usb_ctl_t CTL;                 /*!< [0x94] Control register */
    uint8_t _reserved13[3];
    __IO hw_usb_addr_t ADDR;               /*!< [0x98] Address register */
    uint8_t _reserved14[3];
    __IO hw_usb_bdtpage1_t BDTPAGE1;       /*!< [0x9C] BDT Page register 1 */
    uint8_t _reserved15[3];
    __IO hw_usb_frmnuml_t FRMNUML;         /*!< [0xA0] Frame Number register Low */
    uint8_t _reserved16[3];
    __IO hw_usb_frmnumh_t FRMNUMH;         /*!< [0xA4] Frame Number register High */
    uint8_t _reserved17[3];
    __IO hw_usb_token_t TOKEN;             /*!< [0xA8] Token register */
    uint8_t _reserved18[3];
    __IO hw_usb_softhld_t SOFTHLD;         /*!< [0xAC] SOF Threshold register */
    uint8_t _reserved19[3];
    __IO hw_usb_bdtpage2_t BDTPAGE2;       /*!< [0xB0] BDT Page Register 2 */
    uint8_t _reserved20[3];
    __IO hw_usb_bdtpage3_t BDTPAGE3;       /*!< [0xB4] BDT Page Register 3 */
    uint8_t _reserved21[11];
    struct {
        __IO hw_usb_endptn_t ENDPTn;       /*!< [0xC0] Endpoint Control register */
        uint8_t _reserved0[3];
    } ENDPOINT[16];
    __IO hw_usb_usbctrl_t USBCTRL;         /*!< [0x100] USB Control register */
    uint8_t _reserved22[3];
    __I hw_usb_observe_t OBSERVE;          /*!< [0x104] USB OTG Observe register */
    uint8_t _reserved23[3];
    __IO hw_usb_control_t CONTROL;         /*!< [0x108] USB OTG Control register */
    uint8_t _reserved24[3];
    __IO hw_usb_usbtrc0_t USBTRC0;         /*!< [0x10C] USB Transceiver Control register 0 */
    uint8_t _reserved25[7];
    __IO hw_usb_usbfrmadjust_t USBFRMADJUST; /*!< [0x114] Frame Adjust Register */
    uint8_t _reserved26[43];
    __IO hw_usb_clk_recover_ctrl_t CLK_RECOVER_CTRL; /*!< [0x140] USB Clock recovery control */
    uint8_t _reserved27[3];
    __IO hw_usb_clk_recover_irc_en_t CLK_RECOVER_IRC_EN; /*!< [0x144] IRC48M oscillator enable register */
    uint8_t _reserved28[23];
    __IO hw_usb_clk_recover_int_status_t CLK_RECOVER_INT_STATUS; /*!< [0x15C] Clock recovery separated interrupt status */
} hw_usb_t;
#pragma pack()

/*! @brief Macro to access all USB registers. */
/*! @param x USB module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_USB(USB0_BASE)</code>. */
#define HW_USB(x)      (*(hw_usb_t *)(x))

#endif /* __HW_USB_REGISTERS_H__ */
/* EOF */
